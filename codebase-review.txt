========================================
THREE-MAN-LEAGUE CODEBASE REVIEW
Generated: Fri Nov 28 17:21:11 EST 2025
========================================

--- PROJECT CONFIGURATION ---

========================================
FILE: package.json
========================================

{
  "name": "three-man-league",
  "version": "1.0.0",
  "private": true,
  "description": "Fantasy football pick 'em game with Google sign-in, leagues, and weekly picks",
  "scripts": {
    "dev": "cd frontend && npm run dev",
    "build": "npm run build:frontend && npm run build:functions",
    "build:frontend": "cd frontend && npm run build",
    "build:functions": "cd functions && npm run build",
    "lint": "npm run lint:frontend && npm run lint:functions",
    "lint:frontend": "cd frontend && npm run lint",
    "lint:functions": "cd functions && npm run lint",
    "test": "npm run test:frontend && npm run test:functions",
    "test:frontend": "cd frontend && npm run test:run",
    "test:functions": "cd functions && npm test",
    "typecheck": "npm run typecheck:frontend && npm run typecheck:functions",
    "typecheck:frontend": "cd frontend && npx tsc --noEmit",
    "typecheck:functions": "cd functions && npx tsc --noEmit",
    "deploy": "firebase deploy",
    "deploy:functions": "firebase deploy --only functions",
    "deploy:hosting": "firebase deploy --only hosting",
    "emulators": "firebase emulators:start",
    "install:all": "npm install && cd frontend && npm install && cd ../functions && npm install"
  },
  "keywords": [
    "fantasy-football",
    "firebase",
    "react",
    "typescript"
  ],
  "author": "",
  "license": "MIT",
  "engines": {
    "node": ">=20"
  }
}



========================================
FILE: firebase.json
========================================

{
  "hosting": {
    "public": "frontend/dist",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "/submitPicks",
        "function": "submitPicks"
      },
      {
        "source": "/aiChat",
        "function": "aiChat"
      },
      {
        "source": "/syncSchedule",
        "function": "syncSchedule"
      },
      {
        "source": "/syncPlayers",
        "function": "syncPlayers"
      },
      {
        "source": "/syncPlayerStats",
        "function": "syncPlayerStats"
      },
      {
        "source": "/scoreWeek",
        "function": "scoreWeek"
      },
      {
        "source": "/computeSeasonStandings",
        "function": "computeSeasonStandings"
      },
      {
        "source": "/initializeLeague",
        "function": "initializeLeague"
      },
      {
        "source": "/createLeague",
        "function": "createLeague"
      },
      {
        "source": "/joinLeague",
        "function": "joinLeague"
      },
      {
        "source": "/getUserLeagues",
        "function": "getUserLeagues"
      },
      {
        "source": "/getLeagueDetails",
        "function": "getLeagueDetails"
      },
      {
        "source": "/updateLeagueSettings",
        "function": "updateLeagueSettings"
      },
      {
        "source": "/regenerateJoinCode",
        "function": "regenerateJoinCode"
      },
      {
        "source": "/leaveOrRemoveMember",
        "function": "leaveOrRemoveMember"
      },
      {
        "source": "/setActiveLeague",
        "function": "setActiveLeague"
      },
      {
        "source": "/enableBackfill",
        "function": "enableBackfill"
      },
      {
        "source": "/getBackfillStatus",
        "function": "getBackfillStatus"
      },
      {
        "source": "/backfillWeekForLeague",
        "function": "backfillWeekForLeague"
      },
      {
        "source": "/getBackfillWeekScores",
        "function": "getBackfillWeekScores"
      },
      {
        "source": "/completeBackfill",
        "function": "completeBackfill"
      },
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "functions": {
    "source": "functions"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "functions": {
      "port": 5001
    },
    "firestore": {
      "port": 8080
    },
    "hosting": {
      "port": 5000
    },
    "ui": {
      "enabled": true
    }
  }
}



========================================
FILE: firestore.rules
========================================

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper to check if this is the owner of the resource
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Helper to check if user is a member of a league
    function isLeagueMember(leagueId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/leagues/$(leagueId)/members/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/leagues/$(leagueId)/members/$(request.auth.uid)).data.isActive == true;
    }

    // Helper to check if user is the league owner
    function isLeagueOwner(leagueId) {
      return isSignedIn() &&
        get(/databases/$(database)/documents/leagues/$(leagueId)).data.ownerId == request.auth.uid;
    }

    // ===== Users =====
    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if isOwner(userId);

      // Player usage - read by user, write only by backend functions
      match /playerUsage/{usageId} {
        allow read: if isOwner(userId);
        allow write: if false; // Only backend functions can write player usage
      }
    }

    // ===== Leagues =====
    match /leagues/{leagueId} {
      // Anyone signed in can read league info (for join flow)
      allow read: if isSignedIn();
      // Only backend can create/update leagues
      allow write: if false;

      // League members - readable by all signed in users, writable only by backend
      match /members/{memberId} {
        allow read: if isSignedIn();
        // Members can only be added/updated via Cloud Functions for security
        allow write: if false;
      }

      // Weeks
      match /weeks/{weekId} {
        allow read: if isLeagueMember(leagueId);
        allow write: if false; // Only backend can manage weeks

        // Picks - league members can read all, write only their own
        match /picks/{userId} {
          allow read: if isLeagueMember(leagueId);
          allow write: if isOwner(userId) && isLeagueMember(leagueId);
        }

        // Scores - read only for league members, backend writes
        match /scores/{userId} {
          allow read: if isLeagueMember(leagueId);
          allow write: if false;
        }
      }

      // Season standings - read only for league members
      match /seasonStandings/{userId} {
        allow read: if isLeagueMember(leagueId);
        allow write: if false;
      }
    }

    // ===== Players =====
    match /players/{playerId} {
      allow read: if isSignedIn();
      allow write: if false; // Only backend can sync players
    }

    // ===== Games =====
    match /games/{gameId} {
      allow read: if true; // Public for schedule display
      allow write: if false; // Only backend can sync schedule
    }

    // ===== Config =====
    match /config/{docId} {
      allow read: if true; // Public for season config
      allow write: if false; // Only backend can update config
    }
  }
}



========================================
FILE: firestore.indexes.json
========================================

{
  "indexes": [
    {
      "collectionGroup": "leagues",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "joinCode", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "leagues",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "ownerId", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "members",
      "queryScope": "COLLECTION_GROUP",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "isActive", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "members",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "isActive", "order": "ASCENDING" },
        { "fieldPath": "joinedAt", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "playerUsage",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "leagueId", "order": "ASCENDING" },
        { "fieldPath": "season", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "games",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "weekNumber", "order": "ASCENDING" },
        { "fieldPath": "kickoffTime", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "scores",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "totalPoints", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "seasonStandings",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "seasonTotalPoints", "order": "DESCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}



--- FRONTEND CONFIGURATION ---

========================================
FILE: frontend/package.json
========================================

{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "typecheck": "tsc --noEmit",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "firebase": "^12.6.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.9.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


========================================
FILE: frontend/tsconfig.json
========================================

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


========================================
FILE: frontend/vite.config.ts
========================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

/**
 * Vite Configuration for Three Man League
 *
 * Note: Firebase Functions v2 uses direct URLs (https://{function}-{hash}-uc.a.run.app)
 * rather than the v1 pattern (https://us-central1-{project}.cloudfunctions.net/{function}).
 * The frontend API layer (src/lib/api.ts) handles URL construction directly.
 *
 * For local development with the Firebase Emulator, set VITE_FUNCTIONS_URL
 * environment variable to point to the emulator (e.g., http://localhost:5001).
 */

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // Split Firebase into its own chunk
          firebase: ['firebase/app', 'firebase/auth', 'firebase/firestore'],
          // Split React and React Router
          react: ['react', 'react-dom', 'react-router-dom'],
          // Split icons into their own chunk
          icons: ['react-icons/lu', 'react-icons/fi'],
        },
      },
    },
    // Enable source maps for production debugging
    sourcemap: true,
    // Use esbuild for minification (faster than terser, built-in)
    minify: true,
  },
  server: {
    // Port for local development
    port: 5173,
    // Strict port - fail if port is already in use
    strictPort: true,
  },
  // Define environment variable types
  define: {
    // Ensure process.env is available for libraries that expect it
    'process.env': {},
  },
})


========================================
FILE: frontend/tailwind.config.js
========================================

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{ts,tsx,js,jsx}",
  ],
  theme: {
    extend: {
      colors: {
        // Light theme backgrounds
        page: '#F8FAFC',        // Very light neutral (slate-50)
        surface: '#FFFFFF',      // White cards
        subtle: '#F1F5F9',       // Light gray sections (slate-100)
        elevated: '#FFFFFF',     // Elevated surfaces

        // Primary accent - Emerald/Teal sports theme
        primary: {
          DEFAULT: '#059669',    // emerald-600
          soft: '#D1FAE5',       // emerald-100
          hover: '#047857',      // emerald-700
          active: '#065F46',     // emerald-800
          muted: '#A7F3D0',      // emerald-200
        },

        // Secondary accent - Blue for additional emphasis
        secondary: {
          DEFAULT: '#0284C7',    // sky-600
          soft: '#E0F2FE',       // sky-100
          hover: '#0369A1',      // sky-700
        },

        // Neutral text colors
        text: {
          primary: '#1E293B',    // slate-800 - Strong dark gray
          secondary: '#475569',  // slate-600 - Medium gray
          muted: '#64748B',      // slate-500 - Labels
          subtle: '#94A3B8',     // slate-400 - Very subtle
          inverted: '#FFFFFF',   // White text on dark
        },

        // Border colors
        border: {
          DEFAULT: '#E2E8F0',    // slate-200 - Default border
          subtle: '#F1F5F9',     // slate-100 - Very subtle
          strong: '#CBD5E1',     // slate-300 - Strong border
        },

        // Feedback colors
        success: {
          DEFAULT: '#059669',    // emerald-600
          soft: '#ECFDF5',       // emerald-50
          text: '#065F46',       // emerald-800
        },
        warning: {
          DEFAULT: '#D97706',    // amber-600
          soft: '#FFFBEB',       // amber-50
          text: '#92400E',       // amber-800
        },
        error: {
          DEFAULT: '#DC2626',    // red-600
          soft: '#FEF2F2',       // red-50
          text: '#991B1B',       // red-800
        },
        info: {
          DEFAULT: '#0284C7',    // sky-600
          soft: '#F0F9FF',       // sky-50
          text: '#075985',       // sky-800
        },
      },
      fontFamily: {
        sans: [
          'Inter',
          '-apple-system',
          'BlinkMacSystemFont',
          '"Segoe UI"',
          'Roboto',
          '"Helvetica Neue"',
          'Arial',
          'sans-serif',
        ],
      },
      fontSize: {
        'page-title': ['1.875rem', { lineHeight: '2.25rem', fontWeight: '600' }],  // 30px
        'section-title': ['1.25rem', { lineHeight: '1.75rem', fontWeight: '600' }], // 20px
        'card-title': ['1rem', { lineHeight: '1.5rem', fontWeight: '600' }],        // 16px
        'body': ['0.9375rem', { lineHeight: '1.5rem', fontWeight: '400' }],         // 15px
        'body-sm': ['0.875rem', { lineHeight: '1.25rem', fontWeight: '400' }],      // 14px
        'caption': ['0.75rem', { lineHeight: '1rem', fontWeight: '400' }],          // 12px
        'tiny': ['0.6875rem', { lineHeight: '0.875rem', fontWeight: '400' }],       // 11px
      },
      boxShadow: {
        'card': '0 1px 3px 0 rgb(0 0 0 / 0.06), 0 1px 2px -1px rgb(0 0 0 / 0.06)',
        'card-hover': '0 4px 6px -1px rgb(0 0 0 / 0.08), 0 2px 4px -2px rgb(0 0 0 / 0.06)',
        'dropdown': '0 10px 15px -3px rgb(0 0 0 / 0.08), 0 4px 6px -4px rgb(0 0 0 / 0.06)',
        'modal': '0 25px 50px -12px rgb(0 0 0 / 0.15)',
      },
      borderRadius: {
        'card': '0.75rem',   // 12px
        'button': '0.5rem',  // 8px
        'input': '0.5rem',   // 8px
        'badge': '0.375rem', // 6px
        'full': '9999px',
      },
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
        '128': '32rem',
      },
      maxWidth: {
        'container': '72rem', // 1152px
      },
      ringColor: {
        primary: '#059669',
      },
      animation: {
        'fade-in': 'fadeIn 0.2s ease-out',
        'slide-up': 'slideUp 0.2s ease-out',
        'pulse-soft': 'pulseSoft 2s ease-in-out infinite',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { opacity: '0', transform: 'translateY(8px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        pulseSoft: {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.7' },
        },
      },
    },
  },
  plugins: [],
};



========================================
FILE: frontend/index.html
========================================

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Three-Man League - Fantasy Football Pick 'Em Game" />
    <meta name="theme-color" content="#059669" />
    <title>Three-Man League</title>
    <!-- Preconnect to Google Fonts for faster loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


--- FRONTEND SOURCE CODE ---

========================================
FILE: frontend/src/auth/AuthContext.tsx
========================================

import { createContext, useContext } from "react";
import type { User } from "firebase/auth";

// Auth context to share user state across the app
export interface AuthContextType {
  user: User | null;
  loading: boolean;
}

export const AuthContext = createContext<AuthContextType>({ user: null, loading: true });

export const useAuth = () => useContext(AuthContext);



========================================
FILE: frontend/src/auth/AuthGate.tsx
========================================

import React, { useEffect, useState, useRef } from "react";
import { Link } from "react-router-dom";
import { auth, signInWithGoogle, signInWithEmail, signUpWithEmail, logout, db } from "../firebase";
import { onAuthStateChanged } from "firebase/auth";
import { doc, setDoc } from "firebase/firestore";
import type { User } from "firebase/auth";
import { FiCalendar } from "react-icons/fi";
import { LuTrophy, LuUsers, LuLoader, LuMail, LuLock, LuUser, LuLogOut, LuUserCog } from "react-icons/lu";
import { AuthContext } from "./AuthContext";

// Google icon SVG
const GoogleIcon = () => (
  <svg className="w-5 h-5" viewBox="0 0 24 24">
    <path
      fill="#4285F4"
      d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
    />
    <path
      fill="#34A853"
      d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
    />
    <path
      fill="#FBBC05"
      d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
    />
    <path
      fill="#EA4335"
      d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
    />
  </svg>
);

// Loading spinner
const LoadingSpinner = () => (
  <div className="flex flex-col items-center gap-4">
    <div className="w-10 h-10 border-3 border-primary border-t-transparent rounded-full animate-spin" />
    <p className="text-body-sm text-text-muted">Loading your league...</p>
  </div>
);

// Login screen component
const LoginScreen: React.FC = () => {
  const [mode, setMode] = useState<"login" | "signup">("login");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [displayName, setDisplayName] = useState("");
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  const handleEmailAuth = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      if (mode === "signup") {
        if (!displayName.trim()) {
          setError("Please enter your name");
          setLoading(false);
          return;
        }
        await signUpWithEmail(email, password, displayName.trim());
      } else {
        await signInWithEmail(email, password);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : "Authentication failed";
      // Clean up Firebase error messages
      if (message.includes("auth/email-already-in-use")) {
        setError("This email is already registered. Please sign in instead.");
      } else if (message.includes("auth/weak-password")) {
        setError("Password should be at least 6 characters.");
      } else if (message.includes("auth/invalid-email")) {
        setError("Please enter a valid email address.");
      } else if (message.includes("auth/invalid-credential")) {
        setError("Invalid email or password.");
      } else {
        setError(message);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-page flex items-center justify-center p-4">
      {/* Background decoration */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-primary/5 rounded-full blur-3xl" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-secondary/5 rounded-full blur-3xl" />
      </div>

      <div className="relative max-w-md w-full">
        {/* Login card */}
        <div className="bg-surface rounded-card shadow-modal border border-border p-8">
          {/* Logo and title */}
          <div className="text-center mb-6">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-primary rounded-2xl mb-4">
              <span className="text-white font-bold text-2xl">3</span>
            </div>
            <h1 className="text-page-title text-text-primary mb-2">
              three<span className="text-primary">man</span>league
            </h1>
            <p className="text-body text-text-secondary">
              Fantasy football pick 'em game
            </p>
          </div>

          {/* Error message */}
          {error && (
            <div className="mb-4 p-3 bg-danger/10 border border-danger/20 rounded-button text-body-sm text-danger">
              {error}
            </div>
          )}

          {/* Email form */}
          <form onSubmit={handleEmailAuth} className="space-y-4">
            {mode === "signup" && (
              <div>
                <label className="flex items-center gap-2 text-caption text-text-muted mb-1.5">
                  <LuUser className="w-4 h-4" /> Name
                </label>
                <input
                  type="text"
                  value={displayName}
                  onChange={(e) => setDisplayName(e.target.value)}
                  placeholder="Your name"
                  className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                  required
                />
              </div>
            )}
            <div>
              <label className="flex items-center gap-2 text-caption text-text-muted mb-1.5">
                <LuMail className="w-4 h-4" /> Email
              </label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="you@example.com"
                className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                required
              />
            </div>
            <div>
              <label className="flex items-center gap-2 text-caption text-text-muted mb-1.5">
                <LuLock className="w-4 h-4" /> Password
              </label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="••••••••"
                className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                required
                minLength={6}
              />
            </div>
            <button
              type="submit"
              disabled={loading}
              className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50"
            >
              {loading ? <LuLoader className="w-5 h-5 animate-spin" /> : null}
              {mode === "signup" ? "Create Account" : "Sign In"}
            </button>
          </form>

          {/* Switch mode */}
          <p className="text-center text-body-sm text-text-muted mt-4">
            {mode === "login" ? "Don't have an account?" : "Already have an account?"}{" "}
            <button
              onClick={() => { setMode(mode === "login" ? "signup" : "login"); setError(""); }}
              className="text-primary hover:underline font-medium"
            >
              {mode === "login" ? "Sign up" : "Sign in"}
            </button>
          </p>

          {/* Divider */}
          <div className="flex items-center gap-4 my-6">
            <div className="flex-1 h-px bg-border" />
            <span className="text-caption text-text-muted">or</span>
            <div className="flex-1 h-px bg-border" />
          </div>

          {/* Google sign in */}
          <button
            onClick={signInWithGoogle}
            className="w-full flex items-center justify-center gap-3 px-4 py-3 bg-surface border border-border rounded-button font-medium text-text-primary hover:bg-subtle hover:border-border-strong transition-all duration-150 shadow-sm hover:shadow focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
          >
            <GoogleIcon />
            <span>Continue with Google</span>
          </button>

          {/* Features preview */}
          <div className="mt-6 pt-6 border-t border-border">
            <div className="grid grid-cols-3 gap-4 text-center">
              <div className="flex flex-col items-center">
                <FiCalendar className="w-6 h-6 text-primary mb-1" />
                <p className="text-caption text-text-muted">Weekly Picks</p>
              </div>
              <div className="flex flex-col items-center">
                <LuTrophy className="w-6 h-6 text-primary mb-1" />
                <p className="text-caption text-text-muted">Compete</p>
              </div>
              <div className="flex flex-col items-center">
                <LuUsers className="w-6 h-6 text-primary mb-1" />
                <p className="text-caption text-text-muted">Join Leagues</p>
              </div>
            </div>
          </div>
        </div>

        {/* Footer text */}
        <p className="text-center text-caption text-text-subtle mt-6">
          By signing in, you agree to participate in the league and its rules.
        </p>
      </div>
    </div>
  );
};

// User menu dropdown component
const UserMenu: React.FC<{ user: User }> = ({ user }) => {
  const [open, setOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close on click outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const initials = user.displayName
    ? user.displayName.split(" ").map((n) => n[0]).join("").toUpperCase().slice(0, 2)
    : user.email?.slice(0, 2).toUpperCase() || "U";

  return (
    <div ref={menuRef} className="relative">
      <button
        onClick={() => setOpen(!open)}
        className="flex items-center gap-2 p-1.5 rounded-button hover:bg-subtle transition-colors focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
        aria-label="User menu"
        aria-expanded={open}
      >
        {user.photoURL ? (
          <img
            src={user.photoURL}
            alt={user.displayName || "User"}
            className="w-8 h-8 rounded-full object-cover border border-border"
          />
        ) : (
          <div className="w-8 h-8 rounded-full bg-primary-soft text-primary flex items-center justify-center text-caption font-semibold">
            {initials}
          </div>
        )}
        <svg
          className={`w-4 h-4 text-text-muted transition-transform ${open ? "rotate-180" : ""}`}
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
        </svg>
      </button>

      {open && (
        <div className="absolute right-0 top-full mt-2 w-64 bg-surface rounded-card shadow-dropdown border border-border animate-fade-in z-50">
          <div className="px-4 py-3 border-b border-border">
            <p className="text-body-sm font-medium text-text-primary truncate">
              {user.displayName || "Player"}
            </p>
            <p className="text-caption text-text-muted truncate">{user.email}</p>
          </div>
          <div className="p-2 space-y-1">
            <Link
              to="/profile"
              onClick={() => setOpen(false)}
              className="w-full flex items-center gap-2 px-3 py-2 text-body-sm text-text-secondary hover:text-text-primary hover:bg-subtle rounded-button transition-colors"
            >
              <LuUserCog className="w-4 h-4" />
              Edit Profile
            </Link>
            <button
              onClick={logout}
              className="w-full flex items-center gap-2 px-3 py-2 text-body-sm text-text-secondary hover:text-text-primary hover:bg-subtle rounded-button transition-colors"
            >
              <LuLogOut className="w-4 h-4" />
              Sign out
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export const AuthGate: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    return onAuthStateChanged(auth, async (u) => {
      setUser(u);
      setLoading(false);

      // Sync user profile to Firestore on sign-in
      if (u) {
        try {
          await setDoc(doc(db, "users", u.uid), {
            displayName: u.displayName || "Unknown",
            email: u.email || "",
            photoURL: u.photoURL || "",
            lastSignIn: new Date(),
          }, { merge: true });
        } catch {
          // Silently fail - user doc creation is not critical
        }
      }
    });
  }, []);

  if (loading) {
    return (
      <div className="min-h-screen bg-page flex items-center justify-center">
        <LoadingSpinner />
      </div>
    );
  }

  if (!user) {
    return <LoginScreen />;
  }

  // Authenticated state - provide user context to children
  return (
    <AuthContext.Provider value={{ user, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

export { UserMenu };



========================================
FILE: frontend/src/components/Badge.test.tsx
========================================

import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { Badge } from './Badge'

describe('Badge', () => {
  it('renders children correctly', () => {
    render(<Badge>Active</Badge>)
    expect(screen.getByText('Active')).toBeInTheDocument()
  })

  it('applies neutral variant by default', () => {
    render(<Badge>Default</Badge>)
    const badge = screen.getByText('Default')
    expect(badge).toHaveClass('bg-subtle', 'text-text-secondary')
  })

  it('applies primary variant styles', () => {
    render(<Badge variant="primary">Primary</Badge>)
    const badge = screen.getByText('Primary')
    expect(badge).toHaveClass('bg-primary-soft', 'text-primary')
  })

  it('applies secondary variant styles', () => {
    render(<Badge variant="secondary">Secondary</Badge>)
    const badge = screen.getByText('Secondary')
    expect(badge).toHaveClass('bg-secondary-soft', 'text-secondary')
  })

  it('applies success variant styles', () => {
    render(<Badge variant="success">Success</Badge>)
    const badge = screen.getByText('Success')
    expect(badge).toHaveClass('bg-success-soft', 'text-success-text')
  })

  it('applies warning variant styles', () => {
    render(<Badge variant="warning">Warning</Badge>)
    const badge = screen.getByText('Warning')
    expect(badge).toHaveClass('bg-warning-soft', 'text-warning-text')
  })

  it('applies error variant styles', () => {
    render(<Badge variant="error">Error</Badge>)
    const badge = screen.getByText('Error')
    expect(badge).toHaveClass('bg-error-soft', 'text-error-text')
  })

  it('applies info variant styles', () => {
    render(<Badge variant="info">Info</Badge>)
    const badge = screen.getByText('Info')
    expect(badge).toHaveClass('bg-info-soft', 'text-info-text')
  })

  it('applies sm size by default', () => {
    render(<Badge>Small</Badge>)
    const badge = screen.getByText('Small')
    expect(badge).toHaveClass('px-1.5', 'py-0.5', 'text-tiny')
  })

  it('applies md size styles', () => {
    render(<Badge size="md">Medium</Badge>)
    const badge = screen.getByText('Medium')
    expect(badge).toHaveClass('px-2', 'py-0.5', 'text-caption')
  })

  it('renders icon when provided', () => {
    render(<Badge icon={<span data-testid="icon">★</span>}>With Icon</Badge>)
    expect(screen.getByTestId('icon')).toBeInTheDocument()
  })

  it('hides icon from screen readers', () => {
    render(<Badge icon={<span>★</span>}>With Icon</Badge>)
    const iconWrapper = screen.getByText('With Icon').querySelector('[aria-hidden="true"]')
    expect(iconWrapper).toBeInTheDocument()
  })

  it('applies custom className', () => {
    render(<Badge className="custom-class">Custom</Badge>)
    expect(screen.getByText('Custom')).toHaveClass('custom-class')
  })

  it('has correct base styles', () => {
    render(<Badge>Base</Badge>)
    const badge = screen.getByText('Base')
    expect(badge).toHaveClass('inline-flex', 'items-center', 'gap-1', 'font-medium', 'rounded-badge')
  })
})



========================================
FILE: frontend/src/components/Badge.tsx
========================================

import React, { memo } from "react";

type BadgeVariant =
  | "primary"
  | "secondary"
  | "success"
  | "warning"
  | "error"
  | "info"
  | "neutral";
type BadgeSize = "sm" | "md";

interface BadgeProps {
  variant?: BadgeVariant;
  size?: BadgeSize;
  children: React.ReactNode;
  className?: string;
  icon?: React.ReactNode;
}

const variantStyles: Record<BadgeVariant, string> = {
  primary: "bg-primary-soft text-primary",
  secondary: "bg-secondary-soft text-secondary",
  success: "bg-success-soft text-success-text",
  warning: "bg-warning-soft text-warning-text",
  error: "bg-error-soft text-error-text",
  info: "bg-info-soft text-info-text",
  neutral: "bg-subtle text-text-secondary",
};

const sizeStyles: Record<BadgeSize, string> = {
  sm: "px-1.5 py-0.5 text-tiny",
  md: "px-2 py-0.5 text-caption",
};

export const Badge: React.FC<BadgeProps> = memo(({
  variant = "neutral",
  size = "sm",
  children,
  className = "",
  icon,
}) => {
  return (
    <span
      className={`
        inline-flex items-center gap-1 font-medium rounded-badge
        ${variantStyles[variant]}
        ${sizeStyles[size]}
        ${className}
      `}
    >
      {icon && <span className="shrink-0" aria-hidden="true">{icon}</span>}
      {children}
    </span>
  );
});

Badge.displayName = "Badge";

export default Badge;



========================================
FILE: frontend/src/components/Button.test.tsx
========================================

import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { Button } from './Button'

describe('Button', () => {
  it('renders children correctly', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button')).toHaveTextContent('Click me')
  })

  it('applies primary variant styles by default', () => {
    render(<Button>Primary</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-primary')
  })

  it('applies secondary variant styles', () => {
    render(<Button variant="secondary">Secondary</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-surface')
  })

  it('applies ghost variant styles', () => {
    render(<Button variant="ghost">Ghost</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('text-text-secondary')
  })

  it('applies danger variant styles', () => {
    render(<Button variant="danger">Danger</Button>)
    const button = screen.getByRole('button')
    expect(button).toHaveClass('bg-error')
  })

  it('applies size styles correctly', () => {
    const { rerender } = render(<Button size="sm">Small</Button>)
    expect(screen.getByRole('button')).toHaveClass('px-3', 'py-1.5')

    rerender(<Button size="md">Medium</Button>)
    expect(screen.getByRole('button')).toHaveClass('px-4', 'py-2.5')

    rerender(<Button size="lg">Large</Button>)
    expect(screen.getByRole('button')).toHaveClass('px-5', 'py-3')
  })

  it('handles click events', () => {
    const handleClick = vi.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled</Button>)
    const button = screen.getByRole('button')
    expect(button).toBeDisabled()
    expect(button).toHaveAttribute('aria-disabled', 'true')
  })

  it('is disabled when loading', () => {
    render(<Button loading>Loading</Button>)
    const button = screen.getByRole('button')
    expect(button).toBeDisabled()
    expect(button).toHaveAttribute('aria-busy', 'true')
  })

  it('shows loading spinner when loading', () => {
    render(<Button loading>Loading</Button>)
    // Check for the spinner SVG
    const svg = screen.getByRole('button').querySelector('svg')
    expect(svg).toBeInTheDocument()
    expect(svg).toHaveClass('animate-spin')
  })

  it('shows sr-only loading text when loading', () => {
    render(<Button loading>Submit</Button>)
    expect(screen.getByText('Loading...')).toHaveClass('sr-only')
  })

  it('does not call onClick when disabled', () => {
    const handleClick = vi.fn()
    render(<Button disabled onClick={handleClick}>Disabled</Button>)
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).not.toHaveBeenCalled()
  })

  it('does not call onClick when loading', () => {
    const handleClick = vi.fn()
    render(<Button loading onClick={handleClick}>Loading</Button>)
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).not.toHaveBeenCalled()
  })

  it('renders icon when provided', () => {
    render(<Button icon={<span data-testid="icon">★</span>}>With Icon</Button>)
    expect(screen.getByTestId('icon')).toBeInTheDocument()
  })

  it('hides icon from screen readers', () => {
    render(<Button icon={<span>★</span>}>With Icon</Button>)
    const iconWrapper = screen.getByRole('button').querySelector('[aria-hidden="true"]')
    expect(iconWrapper).toBeInTheDocument()
  })

  it('applies custom className', () => {
    render(<Button className="custom-class">Custom</Button>)
    expect(screen.getByRole('button')).toHaveClass('custom-class')
  })

  it('passes through additional props', () => {
    render(<Button type="submit" data-testid="submit-btn">Submit</Button>)
    const button = screen.getByTestId('submit-btn')
    expect(button).toHaveAttribute('type', 'submit')
  })
})



========================================
FILE: frontend/src/components/Button.tsx
========================================

import React from "react";

type ButtonVariant = "primary" | "secondary" | "ghost" | "danger";
type ButtonSize = "sm" | "md" | "lg";

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: ButtonVariant;
  size?: ButtonSize;
  loading?: boolean;
  icon?: React.ReactNode;
  children: React.ReactNode;
}

const variantStyles: Record<ButtonVariant, string> = {
  primary:
    "bg-primary text-white hover:bg-primary-hover active:bg-primary-active shadow-sm",
  secondary:
    "bg-surface text-text-primary hover:bg-subtle border border-border",
  ghost:
    "text-text-secondary hover:bg-subtle hover:text-text-primary",
  danger:
    "bg-error text-white hover:bg-red-700 active:bg-red-800 shadow-sm",
};

const sizeStyles: Record<ButtonSize, string> = {
  sm: "px-3 py-1.5 text-body-sm gap-1.5",
  md: "px-4 py-2.5 text-body-sm gap-2",
  lg: "px-5 py-3 text-body gap-2",
};

export const Button: React.FC<ButtonProps> = ({
  variant = "primary",
  size = "md",
  loading = false,
  disabled,
  icon,
  children,
  className = "",
  ...props
}) => {
  const isDisabled = disabled || loading;

  return (
    <button
      className={`
        inline-flex items-center justify-center font-medium rounded-button
        transition-all duration-150
        focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary
        disabled:opacity-50 disabled:cursor-not-allowed
        ${variantStyles[variant]}
        ${sizeStyles[size]}
        ${className}
      `}
      disabled={isDisabled}
      aria-disabled={isDisabled}
      aria-busy={loading}
      {...props}
    >
      {loading ? (
        <svg
          className="animate-spin h-4 w-4"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          aria-hidden="true"
        >
          <circle
            className="opacity-25"
            cx="12"
            cy="12"
            r="10"
            stroke="currentColor"
            strokeWidth="4"
          />
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          />
        </svg>
      ) : icon ? (
        <span className="shrink-0" aria-hidden="true">{icon}</span>
      ) : null}
      <span>{children}</span>
      {loading && <span className="sr-only">Loading...</span>}
    </button>
  );
};

export default Button;



========================================
FILE: frontend/src/components/Card.tsx
========================================

import React, { memo } from "react";

interface CardProps {
  children: React.ReactNode;
  className?: string;
  padding?: "none" | "sm" | "md" | "lg";
  hover?: boolean;
}

interface CardHeaderProps {
  title: string;
  subtitle?: string;
  action?: React.ReactNode;
  className?: string;
}

interface CardBodyProps {
  children: React.ReactNode;
  className?: string;
}

interface CardFooterProps {
  children: React.ReactNode;
  className?: string;
}

const paddingStyles = {
  none: "",
  sm: "p-3",
  md: "p-4",
  lg: "p-6",
};

export const Card: React.FC<CardProps> = memo(({
  children,
  className = "",
  padding = "md",
  hover = false,
}) => {
  return (
    <div
      className={`
        bg-surface rounded-card shadow-card border border-border
        ${hover ? "hover:shadow-card-hover transition-shadow duration-200" : ""}
        ${paddingStyles[padding]}
        ${className}
      `}
    >
      {children}
    </div>
  );
});

Card.displayName = "Card";

export const CardHeader: React.FC<CardHeaderProps> = memo(({
  title,
  subtitle,
  action,
  className = "",
}) => {
  return (
    <div className={`flex items-start justify-between ${className}`}>
      <div>
        <h3 className="text-card-title text-text-primary">{title}</h3>
        {subtitle && (
          <p className="mt-0.5 text-caption text-text-muted">{subtitle}</p>
        )}
      </div>
      {action && <div className="shrink-0 ml-4">{action}</div>}
    </div>
  );
});

CardHeader.displayName = "CardHeader";

export const CardBody: React.FC<CardBodyProps> = memo(({
  children,
  className = "",
}) => {
  return <div className={`${className}`}>{children}</div>;
});

CardBody.displayName = "CardBody";

export const CardFooter: React.FC<CardFooterProps> = memo(({
  children,
  className = "",
}) => {
  return (
    <div
      className={`border-t border-border pt-4 mt-4 flex items-center justify-end gap-3 ${className}`}
    >
      {children}
    </div>
  );
});

CardFooter.displayName = "CardFooter";

export default Card;



========================================
FILE: frontend/src/components/EmptyState.tsx
========================================

import React from "react";

interface EmptyStateProps {
  icon?: React.ReactNode;
  title: string;
  description?: string;
  action?: {
    label: string;
    onClick: () => void;
  };
  className?: string;
}

export const EmptyState: React.FC<EmptyStateProps> = ({
  icon,
  title,
  description,
  action,
  className = "",
}) => {
  return (
    <div className={`flex flex-col items-center justify-center py-12 px-4 text-center ${className}`}>
      {icon && (
        <div className="w-16 h-16 rounded-full bg-subtle flex items-center justify-center mb-4">
          <div className="text-text-muted">{icon}</div>
        </div>
      )}
      <h3 className="text-card-title font-semibold text-text-primary mb-2">{title}</h3>
      {description && (
        <p className="text-body-sm text-text-secondary max-w-sm">{description}</p>
      )}
      {action && (
        <button
          onClick={action.onClick}
          className="mt-4 px-4 py-2 bg-primary text-white rounded-button text-body-sm font-medium hover:bg-primary-hover transition-colors"
        >
          {action.label}
        </button>
      )}
    </div>
  );
};

// Specific empty states for common scenarios
export const NoDataEmptyState: React.FC<{ message?: string }> = ({
  message = "No data available",
}) => (
  <EmptyState
    icon={
      <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4" />
      </svg>
    }
    title={message}
  />
);

export const NoPicksEmptyState: React.FC<{ onMakePicks?: () => void }> = ({
  onMakePicks,
}) => (
  <EmptyState
    icon={
      <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
      </svg>
    }
    title="No picks yet"
    description="Select your QB, RB, and WR for this week"
    action={onMakePicks ? { label: "Make Picks", onClick: onMakePicks } : undefined}
  />
);

export const NoPlayersEmptyState: React.FC = () => (
  <EmptyState
    icon={
      <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
      </svg>
    }
    title="No players found"
    description="Try adjusting your search or filters"
  />
);

export const ErrorEmptyState: React.FC<{ message?: string; onRetry?: () => void }> = ({
  message = "Something went wrong",
  onRetry,
}) => (
  <EmptyState
    icon={
      <svg className="w-8 h-8 text-error" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
      </svg>
    }
    title="Error"
    description={message}
    action={onRetry ? { label: "Try Again", onClick: onRetry } : undefined}
  />
);

export default EmptyState;



========================================
FILE: frontend/src/components/ErrorBoundary.tsx
========================================

import { Component, type ErrorInfo, type ReactNode } from "react";
import { Button } from "./Button";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

/**
 * Error Boundary component to catch and display React errors gracefully
 */
export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
    window.location.href = "/";
  };

  handleReload = () => {
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="min-h-screen flex items-center justify-center bg-page p-4">
          <div className="max-w-md w-full text-center">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-error/10 rounded-full mb-6">
              <svg
                className="w-8 h-8 text-error"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={1.5}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                />
              </svg>
            </div>

            <h1 className="text-section-title font-bold text-text-primary mb-2">
              Something went wrong
            </h1>
            <p className="text-body text-text-secondary mb-6">
              We encountered an unexpected error. Please try refreshing the page or go back to the home screen.
            </p>

            {import.meta.env.DEV && this.state.error && (
              <div className="mb-6 p-4 bg-subtle rounded-card text-left overflow-auto max-h-40">
                <p className="text-caption font-mono text-error break-all">
                  {this.state.error.message}
                </p>
              </div>
            )}

            <div className="flex flex-col sm:flex-row gap-3 justify-center">
              <Button variant="secondary" onClick={this.handleReload}>
                Refresh Page
              </Button>
              <Button variant="primary" onClick={this.handleReset}>
                Go Home
              </Button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;



========================================
FILE: frontend/src/components/index.ts
========================================

// Export all UI components
export { Button } from "./Button";
export { Card, CardHeader, CardBody, CardFooter } from "./Card";
export { Badge } from "./Badge";
export { Input } from "./Input";
export { Select } from "./Select";
export { Toast, Alert } from "./Toast";
export { Skeleton, CardSkeleton, TableSkeleton, PlayerListSkeleton } from "./Skeleton";
export { Tabs } from "./Tabs";
export { EmptyState, NoDataEmptyState, NoPicksEmptyState, NoPlayersEmptyState, ErrorEmptyState } from "./EmptyState";
export { PageLoader } from "./PageLoader";
export { ErrorBoundary } from "./ErrorBoundary";



========================================
FILE: frontend/src/components/Input.test.tsx
========================================

import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { Input } from './Input'

describe('Input', () => {
  it('renders input element', () => {
    render(<Input placeholder="Enter text" />)
    expect(screen.getByPlaceholderText('Enter text')).toBeInTheDocument()
  })

  it('renders label when provided', () => {
    render(<Input label="Email" />)
    expect(screen.getByText('Email')).toBeInTheDocument()
    expect(screen.getByLabelText('Email')).toBeInTheDocument()
  })

  it('associates label with input via htmlFor', () => {
    render(<Input label="Username" name="username" />)
    const label = screen.getByText('Username')
    const input = screen.getByLabelText('Username')
    expect(label).toHaveAttribute('for', 'username')
    expect(input).toHaveAttribute('id', 'username')
  })

  it('handles value changes', () => {
    const handleChange = vi.fn()
    render(<Input onChange={handleChange} />)
    const input = screen.getByRole('textbox')
    fireEvent.change(input, { target: { value: 'test' } })
    expect(handleChange).toHaveBeenCalled()
  })

  it('displays error message', () => {
    render(<Input error="This field is required" />)
    expect(screen.getByText('This field is required')).toBeInTheDocument()
    expect(screen.getByRole('alert')).toHaveTextContent('This field is required')
  })

  it('sets aria-invalid when error is present', () => {
    render(<Input error="Invalid input" />)
    expect(screen.getByRole('textbox')).toHaveAttribute('aria-invalid', 'true')
  })

  it('displays hint message', () => {
    render(<Input hint="Enter your email address" />)
    expect(screen.getByText('Enter your email address')).toBeInTheDocument()
  })

  it('hides hint when error is present', () => {
    render(<Input hint="Helpful hint" error="Error message" />)
    expect(screen.queryByText('Helpful hint')).not.toBeInTheDocument()
    expect(screen.getByText('Error message')).toBeInTheDocument()
  })

  it('renders left icon', () => {
    render(<Input leftIcon={<span data-testid="left-icon">🔍</span>} />)
    expect(screen.getByTestId('left-icon')).toBeInTheDocument()
  })

  it('renders right icon', () => {
    render(<Input rightIcon={<span data-testid="right-icon">✓</span>} />)
    expect(screen.getByTestId('right-icon')).toBeInTheDocument()
  })

  it('applies error styles when error is present', () => {
    render(<Input error="Error" />)
    const input = screen.getByRole('textbox')
    expect(input).toHaveClass('border-error')
  })

  it('is disabled when disabled prop is true', () => {
    render(<Input disabled />)
    expect(screen.getByRole('textbox')).toBeDisabled()
  })

  it('applies custom className', () => {
    render(<Input className="custom-class" />)
    expect(screen.getByRole('textbox')).toHaveClass('custom-class')
  })

  it('passes through additional props', () => {
    render(<Input type="email" data-testid="email-input" />)
    const input = screen.getByTestId('email-input')
    expect(input).toHaveAttribute('type', 'email')
  })

  it('sets aria-describedby for error', () => {
    render(<Input name="test" error="Error message" />)
    const input = screen.getByRole('textbox')
    expect(input).toHaveAttribute('aria-describedby', 'test-error')
  })

  it('sets aria-describedby for hint', () => {
    render(<Input name="test" hint="Hint message" />)
    const input = screen.getByRole('textbox')
    expect(input).toHaveAttribute('aria-describedby', 'test-hint')
  })

  it('generates unique id when not provided', () => {
    render(<Input label="Test" />)
    const input = screen.getByLabelText('Test')
    expect(input).toHaveAttribute('id')
    expect(input.id).toBeTruthy()
  })
})



========================================
FILE: frontend/src/components/Input.tsx
========================================

import React, { useId } from "react";

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  error?: string;
  hint?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

export const Input: React.FC<InputProps> = ({
  label,
  error,
  hint,
  leftIcon,
  rightIcon,
  className = "",
  id,
  ...props
}) => {
  const generatedId = useId();
  const inputId = id || props.name || generatedId;
  const errorId = `${inputId}-error`;
  const hintId = `${inputId}-hint`;

  // Build aria-describedby from error and hint
  const describedBy = [
    error ? errorId : null,
    hint && !error ? hintId : null,
  ].filter(Boolean).join(" ") || undefined;

  return (
    <div className="w-full">
      {label && (
        <label
          htmlFor={inputId}
          className="block text-body-sm font-medium text-text-primary mb-1.5"
        >
          {label}
        </label>
      )}
      <div className="relative">
        {leftIcon && (
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-text-muted">
            {leftIcon}
          </div>
        )}
        <input
          id={inputId}
          aria-invalid={error ? "true" : undefined}
          aria-describedby={describedBy}
          className={`
            w-full px-3.5 py-2.5 bg-surface border rounded-input text-body-sm text-text-primary
            placeholder:text-text-subtle
            transition-all duration-150
            focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary
            disabled:bg-subtle disabled:text-text-muted disabled:cursor-not-allowed
            ${error ? "border-error focus:ring-error/20 focus:border-error" : "border-border"}
            ${leftIcon ? "pl-10" : ""}
            ${rightIcon ? "pr-10" : ""}
            ${className}
          `}
          {...props}
        />
        {rightIcon && (
          <div className="absolute inset-y-0 right-0 pr-3 flex items-center text-text-muted">
            {rightIcon}
          </div>
        )}
      </div>
      {error && (
        <p id={errorId} className="mt-1.5 text-caption text-error" role="alert">
          {error}
        </p>
      )}
      {hint && !error && (
        <p id={hintId} className="mt-1.5 text-caption text-text-muted">
          {hint}
        </p>
      )}
    </div>
  );
};

export default Input;



========================================
FILE: frontend/src/components/PageLoader.tsx
========================================

import React from "react";

/**
 * Loading fallback component for lazy-loaded pages
 */
export const PageLoader: React.FC = () => (
  <div className="flex items-center justify-center min-h-[50vh]">
    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
  </div>
);



========================================
FILE: frontend/src/components/Select.test.tsx
========================================

import { describe, it, expect, vi } from 'vitest'
import { render, screen, fireEvent } from '@testing-library/react'
import { Select } from './Select'

const mockOptions = [
  { value: 'option1', label: 'Option 1' },
  { value: 'option2', label: 'Option 2' },
  { value: 'option3', label: 'Option 3' },
]

describe('Select', () => {
  it('renders select element with options', () => {
    render(<Select options={mockOptions} />)
    const select = screen.getByRole('combobox')
    expect(select).toBeInTheDocument()
    expect(screen.getByText('Option 1')).toBeInTheDocument()
    expect(screen.getByText('Option 2')).toBeInTheDocument()
    expect(screen.getByText('Option 3')).toBeInTheDocument()
  })

  it('renders label when provided', () => {
    render(<Select label="Choose option" options={mockOptions} />)
    expect(screen.getByText('Choose option')).toBeInTheDocument()
    expect(screen.getByLabelText('Choose option')).toBeInTheDocument()
  })

  it('associates label with select via htmlFor', () => {
    render(<Select label="Category" name="category" options={mockOptions} />)
    const label = screen.getByText('Category')
    const select = screen.getByLabelText('Category')
    expect(label).toHaveAttribute('for', 'category')
    expect(select).toHaveAttribute('id', 'category')
  })

  it('renders placeholder option when provided', () => {
    render(<Select placeholder="Select an option" options={mockOptions} />)
    expect(screen.getByText('Select an option')).toBeInTheDocument()
  })

  it('placeholder option is disabled', () => {
    render(<Select placeholder="Select an option" options={mockOptions} />)
    const placeholderOption = screen.getByText('Select an option')
    expect(placeholderOption).toBeDisabled()
  })

  it('handles value changes', () => {
    const handleChange = vi.fn()
    render(<Select options={mockOptions} onChange={handleChange} />)
    const select = screen.getByRole('combobox')
    fireEvent.change(select, { target: { value: 'option2' } })
    expect(handleChange).toHaveBeenCalled()
  })

  it('displays error message', () => {
    render(<Select options={mockOptions} error="Please select an option" />)
    expect(screen.getByText('Please select an option')).toBeInTheDocument()
    expect(screen.getByRole('alert')).toHaveTextContent('Please select an option')
  })

  it('sets aria-invalid when error is present', () => {
    render(<Select options={mockOptions} error="Invalid selection" />)
    expect(screen.getByRole('combobox')).toHaveAttribute('aria-invalid', 'true')
  })

  it('displays hint message', () => {
    render(<Select options={mockOptions} hint="Choose your preferred option" />)
    expect(screen.getByText('Choose your preferred option')).toBeInTheDocument()
  })

  it('hides hint when error is present', () => {
    render(<Select options={mockOptions} hint="Helpful hint" error="Error message" />)
    expect(screen.queryByText('Helpful hint')).not.toBeInTheDocument()
    expect(screen.getByText('Error message')).toBeInTheDocument()
  })

  it('applies error styles when error is present', () => {
    render(<Select options={mockOptions} error="Error" />)
    const select = screen.getByRole('combobox')
    expect(select).toHaveClass('border-error')
  })

  it('is disabled when disabled prop is true', () => {
    render(<Select options={mockOptions} disabled />)
    expect(screen.getByRole('combobox')).toBeDisabled()
  })

  it('applies custom className', () => {
    render(<Select options={mockOptions} className="custom-class" />)
    expect(screen.getByRole('combobox')).toHaveClass('custom-class')
  })

  it('passes through additional props', () => {
    render(<Select options={mockOptions} data-testid="test-select" />)
    expect(screen.getByTestId('test-select')).toBeInTheDocument()
  })

  it('sets aria-describedby for error', () => {
    render(<Select name="test" options={mockOptions} error="Error message" />)
    const select = screen.getByRole('combobox')
    expect(select).toHaveAttribute('aria-describedby', 'test-error')
  })

  it('sets aria-describedby for hint', () => {
    render(<Select name="test" options={mockOptions} hint="Hint message" />)
    const select = screen.getByRole('combobox')
    expect(select).toHaveAttribute('aria-describedby', 'test-hint')
  })

  it('generates unique id when not provided', () => {
    render(<Select label="Test" options={mockOptions} />)
    const select = screen.getByLabelText('Test')
    expect(select).toHaveAttribute('id')
    expect(select.id).toBeTruthy()
  })

  it('renders dropdown arrow icon', () => {
    render(<Select options={mockOptions} />)
    const svg = document.querySelector('svg[aria-hidden="true"]')
    expect(svg).toBeInTheDocument()
  })
})



========================================
FILE: frontend/src/components/Select.tsx
========================================

import React, { useId } from "react";

interface SelectOption {
  value: string;
  label: string;
}

interface SelectProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, "children"> {
  label?: string;
  error?: string;
  hint?: string;
  options: SelectOption[];
  placeholder?: string;
}

export const Select: React.FC<SelectProps> = ({
  label,
  error,
  hint,
  options,
  placeholder,
  className = "",
  id,
  ...props
}) => {
  const generatedId = useId();
  const selectId = id || props.name || generatedId;
  const errorId = `${selectId}-error`;
  const hintId = `${selectId}-hint`;

  // Build aria-describedby from error and hint
  const describedBy = [
    error ? errorId : null,
    hint && !error ? hintId : null,
  ].filter(Boolean).join(" ") || undefined;

  return (
    <div className="w-full">
      {label && (
        <label
          htmlFor={selectId}
          className="block text-body-sm font-medium text-text-primary mb-1.5"
        >
          {label}
        </label>
      )}
      <div className="relative">
        <select
          id={selectId}
          aria-invalid={error ? "true" : undefined}
          aria-describedby={describedBy}
          className={`
            w-full px-3.5 py-2.5 bg-surface border rounded-input text-body-sm text-text-primary
            appearance-none cursor-pointer pr-10
            transition-all duration-150
            focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary
            disabled:bg-subtle disabled:text-text-muted disabled:cursor-not-allowed
            ${error ? "border-error focus:ring-error/20 focus:border-error" : "border-border"}
            ${className}
          `}
          {...props}
        >
          {placeholder && (
            <option value="" disabled>
              {placeholder}
            </option>
          )}
          {options.map((option) => (
            <option key={option.value} value={option.value}>
              {option.label}
            </option>
          ))}
        </select>
        <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none text-text-muted">
          <svg
            className="h-4 w-4"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            aria-hidden="true"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </div>
      </div>
      {error && (
        <p id={errorId} className="mt-1.5 text-caption text-error" role="alert">
          {error}
        </p>
      )}
      {hint && !error && (
        <p id={hintId} className="mt-1.5 text-caption text-text-muted">
          {hint}
        </p>
      )}
    </div>
  );
};

export default Select;



========================================
FILE: frontend/src/components/Skeleton.tsx
========================================

import React, { memo } from "react";

interface SkeletonProps {
  className?: string;
  variant?: "text" | "rectangular" | "circular";
  width?: string | number;
  height?: string | number;
  lines?: number;
}

export const Skeleton: React.FC<SkeletonProps> = memo(({
  className = "",
  variant = "rectangular",
  width,
  height,
  lines = 1,
}) => {
  const baseStyle = "bg-subtle animate-pulse";

  const getVariantStyles = () => {
    switch (variant) {
      case "text":
        return "h-4 rounded";
      case "circular":
        return "rounded-full";
      case "rectangular":
      default:
        return "rounded-card";
    }
  };

  const style: React.CSSProperties = {
    width: width || "100%",
    height: height || (variant === "text" ? undefined : "100%"),
  };

  if (variant === "text" && lines > 1) {
    return (
      <div className="space-y-2">
        {Array.from({ length: lines }).map((_, i) => (
          <div
            key={i}
            className={`${baseStyle} ${getVariantStyles()} ${className}`}
            style={{
              ...style,
              width: i === lines - 1 ? "75%" : "100%",
            }}
          />
        ))}
      </div>
    );
  }

  return (
    <div
      className={`${baseStyle} ${getVariantStyles()} ${className}`}
      style={style}
    />
  );
});

Skeleton.displayName = "Skeleton";

// Card skeleton for loading states
export const CardSkeleton: React.FC<{ className?: string }> = memo(({
  className = "",
}) => {
  return (
    <div className={`bg-surface rounded-card shadow-card border border-border p-4 ${className}`}>
      <div className="flex items-center gap-3 mb-4">
        <Skeleton variant="circular" width={40} height={40} />
        <div className="flex-1">
          <Skeleton variant="text" width="60%" className="mb-2" />
          <Skeleton variant="text" width="40%" />
        </div>
      </div>
      <Skeleton variant="text" lines={3} />
    </div>
  );
});

CardSkeleton.displayName = "CardSkeleton";

// Table skeleton for loading states
export const TableSkeleton: React.FC<{
  rows?: number;
  columns?: number;
  className?: string;
}> = memo(({ rows = 5, columns = 4, className = "" }) => {
  return (
    <div className={`bg-surface rounded-card shadow-card border border-border overflow-hidden ${className}`}>
      {/* Header */}
      <div className="border-b border-border bg-subtle px-4 py-3 flex gap-4">
        {Array.from({ length: columns }).map((_, i) => (
          <Skeleton key={i} variant="text" width={`${100 / columns}%`} height={16} />
        ))}
      </div>
      {/* Rows */}
      {Array.from({ length: rows }).map((_, rowIndex) => (
        <div
          key={rowIndex}
          className={`px-4 py-3 flex gap-4 ${rowIndex % 2 === 0 ? "bg-surface" : "bg-subtle/50"}`}
        >
          {Array.from({ length: columns }).map((_, colIndex) => (
            <Skeleton
              key={colIndex}
              variant="text"
              width={`${100 / columns}%`}
              height={14}
            />
          ))}
        </div>
      ))}
    </div>
  );
});

TableSkeleton.displayName = "TableSkeleton";

// Player list skeleton
export const PlayerListSkeleton: React.FC<{ count?: number }> = memo(({ count = 5 }) => {
  return (
    <div className="space-y-2">
      {Array.from({ length: count }).map((_, i) => (
        <div
          key={i}
          className="flex items-center gap-3 p-3 bg-surface border border-border rounded-card"
        >
          <Skeleton variant="rectangular" width={48} height={48} className="rounded-lg shrink-0" />
          <div className="flex-1">
            <Skeleton variant="text" width="50%" className="mb-2" />
            <Skeleton variant="text" width="30%" />
          </div>
          <Skeleton variant="rectangular" width={60} height={28} className="rounded-button shrink-0" />
        </div>
      ))}
    </div>
  );
});

PlayerListSkeleton.displayName = "PlayerListSkeleton";

export default Skeleton;



========================================
FILE: frontend/src/components/Tabs.tsx
========================================

import React, { useId } from "react";

interface Tab {
  id: string;
  label: string;
  icon?: React.ReactNode;
}

interface TabsProps {
  tabs: Tab[];
  activeTab: string;
  onChange: (tabId: string) => void;
  variant?: "underline" | "pills" | "segmented";
  size?: "sm" | "md";
  className?: string;
  ariaLabel?: string;
}

export const Tabs: React.FC<TabsProps> = ({
  tabs,
  activeTab,
  onChange,
  variant = "underline",
  size = "md",
  className = "",
  ariaLabel = "Tabs",
}) => {
  const tablistId = useId();

  const sizeStyles = {
    sm: "text-caption px-3 py-1.5",
    md: "text-body-sm px-4 py-2",
  };

  const handleKeyDown = (e: React.KeyboardEvent, currentIndex: number) => {
    let newIndex = currentIndex;

    if (e.key === "ArrowRight" || e.key === "ArrowDown") {
      e.preventDefault();
      newIndex = (currentIndex + 1) % tabs.length;
    } else if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
      e.preventDefault();
      newIndex = (currentIndex - 1 + tabs.length) % tabs.length;
    } else if (e.key === "Home") {
      e.preventDefault();
      newIndex = 0;
    } else if (e.key === "End") {
      e.preventDefault();
      newIndex = tabs.length - 1;
    }

    if (newIndex !== currentIndex) {
      onChange(tabs[newIndex].id);
    }
  };

  if (variant === "underline") {
    return (
      <div
        role="tablist"
        aria-label={ariaLabel}
        className={`flex border-b border-border ${className}`}
      >
        {tabs.map((tab, index) => (
          <button
            key={tab.id}
            role="tab"
            id={`${tablistId}-tab-${tab.id}`}
            aria-selected={activeTab === tab.id}
            aria-controls={`${tablistId}-panel-${tab.id}`}
            tabIndex={activeTab === tab.id ? 0 : -1}
            onClick={() => onChange(tab.id)}
            onKeyDown={(e) => handleKeyDown(e, index)}
            className={`
              relative ${sizeStyles[size]} font-medium transition-colors
              focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2
              ${activeTab === tab.id
                ? "text-primary"
                : "text-text-muted hover:text-text-primary"
              }
            `}
          >
            <div className="flex items-center gap-2">
              {tab.icon && <span aria-hidden="true">{tab.icon}</span>}
              <span>{tab.label}</span>
            </div>
            {activeTab === tab.id && (
              <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-primary" aria-hidden="true" />
            )}
          </button>
        ))}
      </div>
    );
  }

  if (variant === "pills") {
    return (
      <div
        role="tablist"
        aria-label={ariaLabel}
        className={`flex gap-1 ${className}`}
      >
        {tabs.map((tab, index) => (
          <button
            key={tab.id}
            role="tab"
            id={`${tablistId}-tab-${tab.id}`}
            aria-selected={activeTab === tab.id}
            aria-controls={`${tablistId}-panel-${tab.id}`}
            tabIndex={activeTab === tab.id ? 0 : -1}
            onClick={() => onChange(tab.id)}
            onKeyDown={(e) => handleKeyDown(e, index)}
            className={`
              ${sizeStyles[size]} font-medium rounded-button transition-all
              focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2
              ${activeTab === tab.id
                ? "bg-primary text-white"
                : "text-text-muted hover:text-text-primary hover:bg-subtle"
              }
            `}
          >
            <div className="flex items-center gap-2">
              {tab.icon && <span aria-hidden="true">{tab.icon}</span>}
              <span>{tab.label}</span>
            </div>
          </button>
        ))}
      </div>
    );
  }

  // Segmented control style
  return (
    <div
      role="tablist"
      aria-label={ariaLabel}
      className={`inline-flex bg-subtle rounded-button p-1 ${className}`}
    >
      {tabs.map((tab, index) => (
        <button
          key={tab.id}
          role="tab"
          id={`${tablistId}-tab-${tab.id}`}
          aria-selected={activeTab === tab.id}
          aria-controls={`${tablistId}-panel-${tab.id}`}
          tabIndex={activeTab === tab.id ? 0 : -1}
          onClick={() => onChange(tab.id)}
          onKeyDown={(e) => handleKeyDown(e, index)}
          className={`
            ${sizeStyles[size]} font-medium rounded-badge transition-all
            focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2
            ${activeTab === tab.id
              ? "bg-surface text-text-primary shadow-sm"
              : "text-text-muted hover:text-text-primary"
            }
          `}
        >
          <div className="flex items-center gap-2">
            {tab.icon && <span aria-hidden="true">{tab.icon}</span>}
            <span>{tab.label}</span>
          </div>
        </button>
      ))}
    </div>
  );
};

export default Tabs;



========================================
FILE: frontend/src/components/Toast.tsx
========================================

import React, { useEffect } from "react";

type ToastType = "success" | "error" | "warning" | "info";

interface ToastProps {
  type: ToastType;
  message: string;
  onClose?: () => void;
  duration?: number;
  visible: boolean;
}

const typeStyles: Record<ToastType, { bg: string; icon: string; text: string }> = {
  success: {
    bg: "bg-success-soft border-success/30",
    icon: "✓",
    text: "text-success-text",
  },
  error: {
    bg: "bg-error-soft border-error/30",
    icon: "✕",
    text: "text-error-text",
  },
  warning: {
    bg: "bg-warning-soft border-warning/30",
    icon: "⚠",
    text: "text-warning-text",
  },
  info: {
    bg: "bg-info-soft border-info/30",
    icon: "ℹ",
    text: "text-info-text",
  },
};

export const Toast: React.FC<ToastProps> = ({
  type,
  message,
  onClose,
  duration = 5000,
  visible,
}) => {
  const styles = typeStyles[type];

  useEffect(() => {
    if (visible && duration > 0 && onClose) {
      const timer = setTimeout(() => {
        onClose();
      }, duration);
      return () => clearTimeout(timer);
    }
  }, [visible, duration, onClose]);

  if (!visible) return null;

  return (
    <div
      className={`
        fixed bottom-4 right-4 z-50
        flex items-center gap-3 px-4 py-3 rounded-card border shadow-dropdown
        animate-slide-up
        ${styles.bg}
      `}
      role="alert"
    >
      <span className={`text-lg ${styles.text}`}>{styles.icon}</span>
      <p className={`text-body-sm font-medium ${styles.text}`}>{message}</p>
      {onClose && (
        <button
          onClick={onClose}
          className={`ml-2 p-1 rounded hover:bg-black/5 transition-colors ${styles.text}`}
          aria-label="Close"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      )}
    </div>
  );
};

// Inline alert for in-page feedback
interface AlertProps {
  type: ToastType;
  message: string;
  className?: string;
  onClose?: () => void;
}

export const Alert: React.FC<AlertProps> = ({
  type,
  message,
  className = "",
  onClose,
}) => {
  const styles = typeStyles[type];

  return (
    <div
      className={`
        flex items-center gap-3 px-4 py-3 rounded-card border
        ${styles.bg}
        ${className}
      `}
      role="alert"
    >
      <span className={`text-base shrink-0 ${styles.text}`}>{styles.icon}</span>
      <p className={`flex-1 text-body-sm ${styles.text}`}>{message}</p>
      {onClose && (
        <button
          onClick={onClose}
          className={`shrink-0 p-1 rounded hover:bg-black/5 transition-colors ${styles.text}`}
          aria-label="Close"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      )}
    </div>
  );
};

export default Toast;



========================================
FILE: frontend/src/features/admin/BackfillPage.tsx
========================================

/**
 * Admin Backfill Page - Mid-season setup wizard for league owners
 * Allows backfilling historical weeks with picks and scores
 */

import React, { useState, useEffect, useCallback } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../auth/AuthContext";
import { useLeague } from "../../league/LeagueContext";
import { apiGet, apiPost, getErrorMessage } from "../../lib/api";
import { mapLeagueMember, mapDocs } from "../../lib/firestore";
import { collection, getDocs, query, where } from "firebase/firestore";
import { db } from "../../firebase";
import { LuArrowLeft, LuCalendar, LuCheck, LuCircleAlert, LuLoader, LuChevronRight, LuLock, LuSparkles, LuTrophy } from "react-icons/lu";
import type { LeagueMember, BackfillStatusResponse, BackfillWeekStatus, BackfillWeekResponse } from "../../types";
import { BackfillWeekForm } from "./BackfillWeekForm";

export const BackfillPage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { activeLeagueId, userRole } = useLeague();

  const [members, setMembers] = useState<LeagueMember[]>([]);
  const [backfillStatus, setBackfillStatus] = useState<BackfillStatusResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  // Setup state
  const [setupMode, setSetupMode] = useState(false);
  const [fromWeek, setFromWeek] = useState(1);
  const [toWeek, setToWeek] = useState(1);
  const [enablingBackfill, setEnablingBackfill] = useState(false);

  // Active week being edited
  const [activeWeek, setActiveWeek] = useState<number | null>(null);

  // Load members and backfill status
  const loadData = useCallback(async () => {
    if (!activeLeagueId || !user) return;

    try {
      setLoading(true);
      setError(null);

      // Load members
      const membersRef = collection(db, "leagues", activeLeagueId, "members");
      const q = query(membersRef, where("isActive", "==", true));
      const snap = await getDocs(q);

      const memberList = mapDocs(snap.docs, mapLeagueMember);

      setMembers(memberList.sort((a, b) => a.displayName.localeCompare(b.displayName)));

      // Load backfill status
      try {
        const data = await apiGet<BackfillStatusResponse>(
          `/getBackfillStatus?leagueId=${activeLeagueId}`,
          user
        );
        setBackfillStatus(data);
        if (data.backfillFromWeek) setFromWeek(data.backfillFromWeek);
        if (data.backfillToWeek) setToWeek(data.backfillToWeek);
      } catch {
        // Backfill status not available is not an error
      }
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setLoading(false);
    }
  }, [activeLeagueId, user]);

  useEffect(() => {
    loadData();
  }, [loadData]);

  // Enable backfill mode
  const handleEnableBackfill = async () => {
    if (!user || !activeLeagueId) return;

    setEnablingBackfill(true);
    setError(null);

    try {
      await apiPost("/enableBackfill", { leagueId: activeLeagueId, fromWeek, toWeek }, user);
      setSetupMode(false);
      await loadData();
      setSuccessMessage("Backfill mode enabled! Select a week to begin.");
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setEnablingBackfill(false);
    }
  };

  // Handle week backfill completion
  const handleWeekBackfilled = async (weekNumber: number, response: BackfillWeekResponse) => {
    setActiveWeek(null);
    await loadData();
    setSuccessMessage(`Week ${weekNumber} backfilled successfully! ${response.results.length} members scored.`);
    setTimeout(() => setSuccessMessage(null), 5000);
  };

  // Redirect if not owner
  if (userRole !== "owner" && userRole !== "coOwner") {
    return (
      <div className="max-w-lg mx-auto text-center py-12">
        <LuLock className="w-12 h-12 text-text-muted mx-auto mb-4" />
        <h1 className="text-section-title font-bold text-text-primary mb-2">Access Denied</h1>
        <p className="text-body text-text-secondary mb-6">
          Only league owners can access the backfill wizard.
        </p>
        <button onClick={() => navigate(-1)} className="px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors">
          Go Back
        </button>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="max-w-lg mx-auto text-center py-12">
        <LuLoader className="w-8 h-8 text-primary mx-auto animate-spin" />
        <p className="text-body text-text-secondary mt-4">Loading backfill data...</p>
      </div>
    );
  }

  // If editing a specific week, show the week form
  if (activeWeek !== null) {
    return (
      <BackfillWeekForm
        leagueId={activeLeagueId!}
        weekNumber={activeWeek}
        members={members}
        onBack={() => setActiveWeek(null)}
        onComplete={(response) => handleWeekBackfilled(activeWeek, response)}
      />
    );
  }

  return (
    <div className="max-w-3xl mx-auto">
      {/* Header */}
      <div className="mb-8">
        <button onClick={() => navigate("/league-settings")} className="flex items-center gap-2 text-body-sm text-text-secondary hover:text-text-primary mb-4">
          <LuArrowLeft className="w-4 h-4" />
          Back to Settings
        </button>
        <h1 className="text-page-title font-bold text-text-primary">Mid-Season Setup</h1>
        <p className="text-body text-text-secondary mt-1">
          Backfill historical weeks with picks and scores from your spreadsheet.
        </p>
      </div>

      {/* Messages */}
      {error && (
        <div className="mb-6 p-4 bg-danger/10 border border-danger/20 rounded-card text-danger text-body-sm flex items-center gap-2">
          <LuCircleAlert className="w-5 h-5 flex-shrink-0" />
          {error}
        </div>
      )}
      {successMessage && (
        <div className="mb-6 p-4 bg-success/10 border border-success/20 rounded-card text-success text-body-sm flex items-center gap-2">
          <LuCheck className="w-5 h-5 flex-shrink-0" />
          {successMessage}
        </div>
      )}

      {/* Setup Mode - Enable Backfill */}
      {!backfillStatus?.backfillEnabled && !setupMode && (
        <div className="bg-surface rounded-card border border-border p-8 text-center">
          <LuCalendar className="w-12 h-12 text-primary mx-auto mb-4" />
          <h2 className="text-section-title font-bold text-text-primary mb-2">Enable Mid-Season Setup</h2>
          <p className="text-body text-text-secondary mb-6 max-w-md mx-auto">
            This wizard helps you import historical data from your spreadsheet. 
            You'll enter picks for each member for past weeks, and scores will be calculated automatically.
          </p>
          <button onClick={() => setSetupMode(true)} className="px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors">
            Start Setup
          </button>
        </div>
      )}

      {/* Week Range Selection */}
      {setupMode && !backfillStatus?.backfillEnabled && (
        <div className="bg-surface rounded-card border border-border p-6">
          <h2 className="text-body font-semibold text-text-primary mb-4">Select Week Range to Backfill</h2>
          <p className="text-body-sm text-text-secondary mb-6">
            Choose the range of weeks you need to import from your spreadsheet.
          </p>

          <div className="grid grid-cols-2 gap-4 mb-6">
            <div>
              <label className="block text-body-sm font-medium text-text-primary mb-2">From Week</label>
              <select value={fromWeek} onChange={(e) => setFromWeek(parseInt(e.target.value))} className="w-full px-4 py-2 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary">
                {Array.from({ length: 18 }, (_, i) => i + 1).map(w => (
                  <option key={w} value={w}>Week {w}</option>
                ))}
              </select>
            </div>
            <div>
              <label className="block text-body-sm font-medium text-text-primary mb-2">To Week</label>
              <select value={toWeek} onChange={(e) => setToWeek(parseInt(e.target.value))} className="w-full px-4 py-2 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary">
                {Array.from({ length: 18 }, (_, i) => i + 1).filter(w => w >= fromWeek).map(w => (
                  <option key={w} value={w}>Week {w}</option>
                ))}
              </select>
            </div>
          </div>

          <div className="flex gap-3">
            <button onClick={() => setSetupMode(false)} className="px-4 py-2 bg-subtle text-text-secondary rounded-button font-medium hover:bg-border transition-colors">
              Cancel
            </button>
            <button onClick={handleEnableBackfill} disabled={enablingBackfill || fromWeek > toWeek} className="px-6 py-2 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50 flex items-center gap-2">
              {enablingBackfill && <LuLoader className="w-4 h-4 animate-spin" />}
              Enable Backfill
            </button>
          </div>
        </div>
      )}

      {/* Week List */}
      {backfillStatus?.backfillEnabled && (
        <div className="space-y-6">
          {/* Progress Header */}
          <div className="bg-surface rounded-card border border-border p-6">
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-full bg-primary-soft flex items-center justify-center">
                  <LuSparkles className="w-5 h-5 text-primary" />
                </div>
                <div>
                  <h2 className="text-body font-semibold text-text-primary">Backfill Progress</h2>
                  <p className="text-body-sm text-text-muted">
                    Weeks {backfillStatus.backfillFromWeek} - {backfillStatus.backfillToWeek}
                  </p>
                </div>
              </div>
              <div className="text-right">
                <p className="text-section-title font-bold text-primary">
                  {backfillStatus.weeks.filter(w => w.status === "backfilled").length} / {backfillStatus.weeks.length}
                </p>
                <p className="text-caption text-text-muted">weeks completed</p>
              </div>
            </div>

            {/* Progress Bar */}
            <div className="w-full bg-subtle rounded-full h-2 overflow-hidden">
              <div
                className="bg-primary h-full rounded-full transition-all duration-500"
                style={{
                  width: `${(backfillStatus.weeks.filter(w => w.status === "backfilled").length / backfillStatus.weeks.length) * 100}%`
                }}
              />
            </div>
          </div>

          {/* Week Cards */}
          <div className="grid gap-3">
            {backfillStatus.weeks.map((week: BackfillWeekStatus) => (
              <WeekRow key={week.weekNumber} week={week} onSelect={() => setActiveWeek(week.weekNumber)} />
            ))}
          </div>

          {/* Completion Message */}
          {backfillStatus.weeks.every(w => w.status === "backfilled") && (
            <div className="bg-gradient-to-r from-success/10 to-primary/10 border border-success/20 rounded-card p-8 text-center">
              <div className="w-16 h-16 bg-success/20 rounded-full flex items-center justify-center mx-auto mb-4">
                <LuTrophy className="w-8 h-8 text-success" />
              </div>
              <h3 className="text-section-title font-bold text-success mb-2">All Weeks Backfilled!</h3>
              <p className="text-body text-text-secondary mb-6 max-w-md mx-auto">
                Your league is now fully set up with historical data. Season standings have been calculated and updated.
              </p>
              <button
                onClick={() => navigate("/standings")}
                className="px-6 py-3 bg-success text-white rounded-button font-medium hover:bg-success/90 transition-colors"
              >
                View Standings
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// Week row component
const WeekRow: React.FC<{ week: BackfillWeekStatus; onSelect: () => void }> = ({ week, onSelect }) => {
  const isBackfilled = week.status === "backfilled";

  return (
    <button
      onClick={onSelect}
      className={`w-full flex items-center justify-between p-4 bg-surface border rounded-card transition-all text-left group ${
        isBackfilled
          ? "border-success/30 hover:border-success/50"
          : "border-border hover:border-primary hover:shadow-sm"
      }`}
    >
      <div className="flex items-center gap-4">
        <div className={`w-12 h-12 rounded-full flex items-center justify-center font-bold ${
          isBackfilled
            ? "bg-success/10 text-success"
            : "bg-subtle text-text-muted group-hover:bg-primary-soft group-hover:text-primary"
        }`}>
          {isBackfilled ? <LuCheck className="w-5 h-5" /> : <span className="text-body">{week.weekNumber}</span>}
        </div>
        <div>
          <p className="text-body font-semibold text-text-primary">Week {week.weekNumber}</p>
          <p className="text-caption text-text-muted">
            {isBackfilled
              ? `${week.memberCount} members scored`
              : "Click to enter picks"
            }
          </p>
        </div>
      </div>
      <div className="flex items-center gap-3">
        {isBackfilled ? (
          <span className="px-3 py-1 bg-success/10 text-success text-caption font-medium rounded-full">
            Completed
          </span>
        ) : (
          <span className="px-3 py-1 bg-warning/10 text-warning text-caption font-medium rounded-full">
            Pending
          </span>
        )}
        <LuChevronRight className={`w-5 h-5 transition-transform ${
          isBackfilled ? "text-success" : "text-text-muted group-hover:text-primary group-hover:translate-x-1"
        }`} />
      </div>
    </button>
  );
};

export default BackfillPage;



========================================
FILE: frontend/src/features/admin/BackfillWeekForm.tsx
========================================

/**
 * Backfill Week Form - Enter picks for all members for a specific week
 * Optimized UI with existing picks loading and inline editing
 */

import React, { useState, useEffect, useCallback, useMemo } from "react";
import { useAuth } from "../../auth/AuthContext";
import { apiPost, apiGet, getErrorMessage } from "../../lib/api";
import { mapPlayer, mapDocs } from "../../lib/firestore";
import { collection, getDocs } from "firebase/firestore";
import { db } from "../../firebase";
import { LuArrowLeft, LuCircleAlert, LuLoader, LuCheck, LuSave } from "react-icons/lu";
import type { LeagueMember, Player, BackfillMemberPick, BackfillWeekResponse, BackfillMemberResult } from "../../types";
import { PlayerSearchDropdown } from "./PlayerSearchDropdown";

interface BackfillWeekFormProps {
  leagueId: string;
  weekNumber: number;
  members: LeagueMember[];
  onBack: () => void;
  onComplete: (response: BackfillWeekResponse) => void;
}

type PositionKey = "qb" | "rb" | "wr";

interface MemberPickState {
  qbPlayerId?: string;
  rbPlayerId?: string;
  wrPlayerId?: string;
  // Track scores from existing data
  qbPoints?: number;
  rbPoints?: number;
  wrPoints?: number;
  totalPoints?: number;
}

const positions: PositionKey[] = ["qb", "rb", "wr"];

export const BackfillWeekForm: React.FC<BackfillWeekFormProps> = ({
  leagueId,
  weekNumber,
  members,
  onBack,
  onComplete,
}) => {
  const { user } = useAuth();
  const [players, setPlayers] = useState<Player[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [memberPicks, setMemberPicks] = useState<Record<string, MemberPickState>>({});
  const [originalPicks, setOriginalPicks] = useState<Record<string, MemberPickState>>({});
  const [hasExistingData, setHasExistingData] = useState(false);

  // Create player lookup map for quick access
  const playerMap = useMemo(() => {
    const map = new Map<string, Player>();
    players.forEach(p => {
      if (p.id) map.set(p.id, p);
    });
    return map;
  }, [players]);

  // Load players and existing picks
  useEffect(() => {
    async function loadData() {
      if (!user) return;

      try {
        setLoading(true);

        // Load players
        const playersRef = collection(db, "players");
        const snap = await getDocs(playersRef);
        const playerList = mapDocs(snap.docs, mapPlayer);
        setPlayers(playerList);

        // Initialize member picks
        const initialPicks: Record<string, MemberPickState> = {};
        members.forEach(m => {
          initialPicks[m.userId] = {};
        });

        // Try to load existing picks for this week
        try {
          const response = await apiGet<{ ok: boolean; scores: BackfillMemberResult[] }>(
            `getBackfillWeekScores?leagueId=${leagueId}&weekNumber=${weekNumber}`,
            user
          );

          if (response.ok && response.scores && response.scores.length > 0) {
            setHasExistingData(true);
            response.scores.forEach((score: BackfillMemberResult) => {
              initialPicks[score.userId] = {
                qbPlayerId: score.qbPlayerId,
                rbPlayerId: score.rbPlayerId,
                wrPlayerId: score.wrPlayerId,
                qbPoints: score.qbPoints,
                rbPoints: score.rbPoints,
                wrPoints: score.wrPoints,
                totalPoints: score.totalPoints,
              };
            });
          }
        } catch {
          // No existing data - that's fine
        }

        setMemberPicks(initialPicks);
        setOriginalPicks(JSON.parse(JSON.stringify(initialPicks)));
      } catch (err) {
        setError(err instanceof Error ? err.message : "Failed to load data");
      } finally {
        setLoading(false);
      }
    }
    loadData();
  }, [leagueId, weekNumber, members, user]);

  // Check if there are unsaved changes
  const hasChanges = useMemo(() => {
    return JSON.stringify(memberPicks) !== JSON.stringify(originalPicks);
  }, [memberPicks, originalPicks]);

  // Update a member's pick
  const handlePickChange = (userId: string, position: PositionKey, playerId: string | undefined) => {
    setMemberPicks(prev => ({
      ...prev,
      [userId]: {
        ...prev[userId],
        [`${position}PlayerId`]: playerId,
        // Clear points when pick changes - will be recalculated on save
        [`${position}Points`]: undefined,
        totalPoints: undefined,
      },
    }));
  };

  // Filter players by position
  const getPlayersForPosition = useCallback((position: PositionKey): Player[] => {
    const posUpper = position.toUpperCase();
    return players.filter(p => {
      if (posUpper === "QB") return p.position === "QB";
      if (posUpper === "RB") return p.position === "RB";
      if (posUpper === "WR") return p.position === "WR" || p.position === "TE";
      return false;
    });
  }, [players]);

  // Submit backfill
  const handleSubmit = async () => {
    if (!user) return;

    setSaving(true);
    setError(null);

    try {
      const memberPicksArray: BackfillMemberPick[] = Object.entries(memberPicks).map(([userId, picks]) => ({
        userId,
        qbPlayerId: picks.qbPlayerId,
        rbPlayerId: picks.rbPlayerId,
        wrPlayerId: picks.wrPlayerId,
      }));

      const data = await apiPost<BackfillWeekResponse>("/backfillWeekForLeague", {
        leagueId,
        weekNumber,
        memberPicks: memberPicksArray,
      }, user);

      onComplete(data);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setSaving(false);
    }
  };

  // Count filled picks
  const filledCount = Object.values(memberPicks).filter(p => p.qbPlayerId || p.rbPlayerId || p.wrPlayerId).length;

  if (loading) {
    return (
      <div className="max-w-lg mx-auto text-center py-12">
        <LuLoader className="w-8 h-8 text-primary mx-auto animate-spin" />
        <p className="text-body text-text-secondary mt-4">Loading data...</p>
      </div>
    );
  }

  return (
    <div className="max-w-5xl mx-auto pb-24">
      {/* Header */}
      <div className="mb-6">
        <button onClick={onBack} className="flex items-center gap-2 text-body-sm text-text-secondary hover:text-text-primary mb-4 group">
          <LuArrowLeft className="w-4 h-4 transition-transform group-hover:-translate-x-1" />
          Back to Week List
        </button>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-12 h-12 rounded-full bg-primary-soft flex items-center justify-center">
              <span className="text-section-title font-bold text-primary">{weekNumber}</span>
            </div>
            <div>
              <h1 className="text-page-title font-bold text-text-primary">Week {weekNumber}</h1>
              <p className="text-body-sm text-text-secondary">
                {hasExistingData ? "Edit existing picks" : "Enter picks for each member"}
              </p>
            </div>
          </div>
          <div className="flex items-center gap-4">
            {hasExistingData && (
              <span className="px-3 py-1 bg-success/10 text-success text-caption font-medium rounded-full flex items-center gap-1">
                <LuCheck className="w-3.5 h-3.5" />
                Previously saved
              </span>
            )}
            <div className="text-right bg-surface px-4 py-2 rounded-card border border-border">
              <p className="text-section-title font-bold text-text-primary">{filledCount}/{members.length}</p>
              <p className="text-caption text-text-muted">members</p>
            </div>
          </div>
        </div>
      </div>

      {/* Error */}
      {error && (
        <div className="mb-4 p-3 bg-danger/10 border border-danger/20 rounded-card text-danger text-body-sm flex items-center gap-2">
          <LuCircleAlert className="w-5 h-5 flex-shrink-0" />
          {error}
        </div>
      )}

      {/* Compact Table Header */}
      <div className="bg-subtle rounded-t-card border border-border border-b-0 px-4 py-3 grid grid-cols-[1fr,180px,180px,180px,80px] gap-3 text-caption font-semibold text-text-secondary">
        <div>Member</div>
        <div className="text-center text-red-600">QB</div>
        <div className="text-center text-blue-600">RB</div>
        <div className="text-center text-amber-600">WR/TE</div>
        <div className="text-right">Points</div>
      </div>

      {/* Member Rows */}
      <div className="border border-border rounded-b-card divide-y divide-border bg-surface">
        {members.map(member => {
          const picks = memberPicks[member.userId] || {};
          const hasPicks = picks.qbPlayerId || picks.rbPlayerId || picks.wrPlayerId;

          return (
            <div
              key={member.userId}
              className={`px-4 py-3 grid grid-cols-[1fr,180px,180px,180px,80px] gap-3 items-center ${
                hasPicks ? "bg-surface" : "bg-subtle/30"
              }`}
            >
              {/* Member Name */}
              <div className="flex items-center gap-2 min-w-0">
                <div className="w-8 h-8 rounded-full bg-primary-soft text-primary flex items-center justify-center text-caption font-semibold flex-shrink-0">
                  {member.displayName?.split(" ").map(n => n[0]).join("").toUpperCase().slice(0, 2) || "?"}
                </div>
                <span className="text-body-sm font-medium text-text-primary truncate">
                  {member.displayName}
                </span>
              </div>

              {/* Position Dropdowns */}
              {positions.map(pos => (
                <div key={pos}>
                  <PlayerSearchDropdown
                    players={getPlayersForPosition(pos)}
                    selectedPlayerId={picks[`${pos}PlayerId` as keyof MemberPickState] as string | undefined}
                    onSelect={(playerId) => handlePickChange(member.userId, pos, playerId)}
                    placeholder="Select..."
                    position={pos}
                    playerMap={playerMap}
                  />
                </div>
              ))}

              {/* Points */}
              <div className="text-right">
                {picks.totalPoints !== undefined ? (
                  <span className="text-body-sm font-semibold text-text-primary">
                    {picks.totalPoints.toFixed(1)}
                  </span>
                ) : hasPicks ? (
                  <span className="text-caption text-text-muted">—</span>
                ) : null}
              </div>
            </div>
          );
        })}
      </div>

      {/* Sticky Save Button */}
      <div className="fixed bottom-0 left-0 right-0 bg-background/95 backdrop-blur-sm border-t border-border py-4 px-4 shadow-lg z-50">
        <div className="max-w-5xl mx-auto flex items-center justify-between">
          <div>
            <p className="text-body-sm font-medium text-text-primary">
              {filledCount === 0 ? "No picks entered" : `${filledCount} of ${members.length} members have picks`}
            </p>
            {hasChanges && (
              <p className="text-caption text-warning">You have unsaved changes</p>
            )}
          </div>
          <div className="flex items-center gap-3">
            <button
              onClick={onBack}
              disabled={saving}
              className="px-4 py-2.5 text-text-secondary hover:text-text-primary transition-colors disabled:opacity-50"
            >
              {hasChanges ? "Discard" : "Back"}
            </button>
            <button
              onClick={handleSubmit}
              disabled={saving || filledCount === 0}
              className="px-6 py-2.5 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50 flex items-center gap-2 shadow-sm"
            >
              {saving ? (
                <LuLoader className="w-4 h-4 animate-spin" />
              ) : (
                <LuSave className="w-4 h-4" />
              )}
              {saving ? "Saving..." : "Save & Calculate"}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};



========================================
FILE: frontend/src/features/admin/PlayerSearchDropdown.tsx
========================================

/**
 * Player Search Dropdown - Compact searchable dropdown for selecting players
 */

import React, { useState, useRef, useEffect, useMemo } from "react";
import { LuSearch, LuX, LuChevronDown } from "react-icons/lu";
import type { Player } from "../../types";

interface PlayerSearchDropdownProps {
  players: Player[];
  selectedPlayerId?: string;
  onSelect: (playerId: string | undefined) => void;
  placeholder?: string;
  position: "qb" | "rb" | "wr";
  playerMap?: Map<string, Player>;
}

const positionColors = {
  qb: { bg: "bg-red-50", border: "border-red-200", text: "text-red-600", ring: "ring-red-200" },
  rb: { bg: "bg-blue-50", border: "border-blue-200", text: "text-blue-600", ring: "ring-blue-200" },
  wr: { bg: "bg-amber-50", border: "border-amber-200", text: "text-amber-600", ring: "ring-amber-200" },
};

export const PlayerSearchDropdown: React.FC<PlayerSearchDropdownProps> = ({
  players,
  selectedPlayerId,
  onSelect,
  placeholder = "Select...",
  position,
  playerMap,
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const colors = positionColors[position];

  // Find selected player - use map if available for O(1) lookup
  const selectedPlayer = useMemo(() => {
    if (playerMap && selectedPlayerId) {
      return playerMap.get(selectedPlayerId);
    }
    return players.find(p => p.id === selectedPlayerId);
  }, [players, selectedPlayerId, playerMap]);

  // Filter players by search query
  const filteredPlayers = useMemo(() => {
    if (!searchQuery.trim()) return players.slice(0, 50); // Limit initial list
    const query = searchQuery.toLowerCase();
    return players
      .filter(p => 
        p.name.toLowerCase().includes(query) ||
        p.teamName?.toLowerCase().includes(query)
      )
      .slice(0, 50);
  }, [players, searchQuery]);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        setIsOpen(false);
        setSearchQuery("");
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // Focus input when opening
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen]);

  const handleSelect = (playerId: string) => {
    onSelect(playerId);
    setIsOpen(false);
    setSearchQuery("");
  };

  const handleClear = (e: React.MouseEvent) => {
    e.stopPropagation();
    onSelect(undefined);
    setSearchQuery("");
  };

  return (
    <div ref={containerRef} className="relative">
      {/* Trigger Button - Compact */}
      <button
        type="button"
        onClick={() => setIsOpen(!isOpen)}
        className={`w-full flex items-center justify-between px-2 py-1.5 text-left border rounded transition-colors ${
          selectedPlayer
            ? `${colors.bg} ${colors.border}`
            : "bg-white border-border hover:border-text-muted"
        } ${isOpen ? `ring-2 ${colors.ring}` : ""}`}
      >
        <span className={`text-caption truncate ${selectedPlayer ? `${colors.text} font-medium` : "text-text-muted"}`}>
          {selectedPlayer ? selectedPlayer.name : placeholder}
        </span>
        <div className="flex items-center gap-0.5 flex-shrink-0 ml-1">
          {selectedPlayer && (
            <button
              type="button"
              onClick={handleClear}
              className="p-0.5 hover:bg-border rounded"
            >
              <LuX className="w-3 h-3 text-text-muted" />
            </button>
          )}
          <LuChevronDown className={`w-3 h-3 text-text-muted transition-transform ${isOpen ? "rotate-180" : ""}`} />
        </div>
      </button>

      {/* Dropdown */}
      {isOpen && (
        <div className="absolute z-50 w-64 mt-1 bg-surface border border-border rounded-card shadow-lg max-h-72 overflow-hidden">
          {/* Search Input */}
          <div className="p-2 border-b border-border">
            <div className="relative">
              <LuSearch className="absolute left-2.5 top-1/2 -translate-y-1/2 w-4 h-4 text-text-muted" />
              <input
                ref={inputRef}
                type="text"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                placeholder="Search by name or team..."
                className="w-full pl-8 pr-3 py-1.5 text-body-sm bg-subtle border border-border rounded-button focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              />
            </div>
          </div>

          {/* Player List */}
          <div className="overflow-y-auto max-h-48">
            {filteredPlayers.length === 0 ? (
              <div className="p-4 text-center text-body-sm text-text-muted">
                No players found
              </div>
            ) : (
              filteredPlayers.filter(p => p.id).map(player => (
                <button
                  key={player.id}
                  type="button"
                  onClick={() => handleSelect(player.id!)}
                  className={`w-full flex items-center justify-between px-3 py-2 text-left hover:bg-subtle transition-colors ${
                    player.id === selectedPlayerId ? colors.bg : ""
                  }`}
                >
                  <div className="min-w-0">
                    <p className="text-body-sm font-medium text-text-primary truncate">
                      {player.name}
                    </p>
                    <p className="text-caption text-text-muted truncate">
                      {player.teamName || player.teamId} • {player.position}
                    </p>
                  </div>
                  {player.id === selectedPlayerId && (
                    <span className={`text-caption font-medium ${colors.text}`}>Selected</span>
                  )}
                </button>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default PlayerSearchDropdown;



========================================
FILE: frontend/src/features/league/CreateLeaguePage.tsx
========================================

/**
 * Create League Page - Multi-step wizard for creating a new league
 */

import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../auth/AuthContext";
import { useLeague } from "../../league/LeagueContext";
import { apiPost, getErrorMessage } from "../../lib/api";
import { LuArrowLeft, LuArrowRight, LuCheck, LuCopy, LuUsers, LuDollarSign, LuTrophy } from "react-icons/lu";
import type { PayoutEntry } from "../../types";

type Step = "name" | "payouts" | "review" | "success";

const DEFAULT_PAYOUTS: PayoutEntry[] = [
  { rank: 1, amount: 1200 },
  { rank: 2, amount: 750 },
  { rank: 3, amount: 500 },
  { rank: 4, amount: 415 },
  { rank: 5, amount: 270 },
  { rank: 6, amount: 195 },
  { rank: 7, amount: 120 },
];

export const CreateLeaguePage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { refreshLeagues, setActiveLeague } = useLeague();
  
  const [step, setStep] = useState<Step>("name");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Form state
  const [name, setName] = useState("");
  const [entryFee, setEntryFee] = useState(50);
  const [maxPlayers, setMaxPlayers] = useState<number | undefined>(undefined);
  const [payouts, setPayouts] = useState<PayoutEntry[]>(DEFAULT_PAYOUTS);
  
  // Success state
  const [, setCreatedLeagueId] = useState<string | null>(null);
  const [joinCode, setJoinCode] = useState<string | null>(null);
  const [joinLink, setJoinLink] = useState<string | null>(null);
  const [copied, setCopied] = useState(false);

  const totalPayout = payouts.reduce((sum, p) => sum + p.amount, 0);

  const handleAddPayout = () => {
    const nextRank = payouts.length + 1;
    setPayouts([...payouts, { rank: nextRank, amount: 0 }]);
  };

  const handleRemovePayout = (index: number) => {
    const newPayouts = payouts.filter((_, i) => i !== index);
    // Re-number ranks
    setPayouts(newPayouts.map((p, i) => ({ ...p, rank: i + 1 })));
  };

  const handlePayoutChange = (index: number, amount: number) => {
    const newPayouts = [...payouts];
    newPayouts[index] = { ...newPayouts[index], amount };
    setPayouts(newPayouts);
  };

  const handleCreate = async () => {
    if (!user) return;

    setLoading(true);
    setError(null);

    try {
      const data = await apiPost<{
        leagueId: string;
        joinCode: string;
        joinLink: string;
      }>("/createLeague", {
        name: name.trim(),
        entryFee,
        maxPlayers: maxPlayers || undefined,
        payoutStructure: payouts,
      }, user);

      setCreatedLeagueId(data.leagueId);
      setJoinCode(data.joinCode);
      setJoinLink(data.joinLink);
      setStep("success");

      // Refresh leagues and set as active
      await refreshLeagues();
      await setActiveLeague(data.leagueId);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setLoading(false);
    }
  };

  const handleCopyCode = async () => {
    if (joinCode) {
      await navigator.clipboard.writeText(joinCode);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handleCopyLink = async () => {
    if (joinLink) {
      await navigator.clipboard.writeText(joinLink);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const canProceed = () => {
    if (step === "name") return name.trim().length >= 2;
    if (step === "payouts") return payouts.length > 0;
    return true;
  };

  const renderStep = () => {
    switch (step) {
      case "name":
        return (
          <div className="space-y-6">
            <div>
              <label className="block text-body-sm font-medium text-text-primary mb-2">
                League Name
              </label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="e.g., The Gridiron Gang"
                className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                maxLength={50}
                autoFocus
              />
              <p className="mt-2 text-caption text-text-muted">{name.length}/50 characters</p>
            </div>
            
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-body-sm font-medium text-text-primary mb-2">
                  Entry Fee ($)
                </label>
                <input
                  type="number"
                  value={entryFee}
                  onChange={(e) => setEntryFee(Math.max(0, parseInt(e.target.value) || 0))}
                  className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                  min={0}
                />
              </div>
              <div>
                <label className="block text-body-sm font-medium text-text-primary mb-2">
                  Max Players (optional)
                </label>
                <input
                  type="number"
                  value={maxPlayers || ""}
                  onChange={(e) => setMaxPlayers(e.target.value ? parseInt(e.target.value) : undefined)}
                  placeholder="Unlimited"
                  className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary placeholder:text-text-muted focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                  min={2}
                  max={100}
                />
              </div>
            </div>
          </div>
        );

      case "payouts":
        return (
          <div className="space-y-6">
            <div className="flex items-center justify-between">
              <h3 className="text-body font-medium text-text-primary">Payout Structure</h3>
              <button
                onClick={handleAddPayout}
                className="text-body-sm text-primary hover:text-primary-hover font-medium"
              >
                + Add Place
              </button>
            </div>

            <div className="space-y-3">
              {payouts.map((payout, index) => (
                <div key={index} className="flex items-center gap-3">
                  <div className="w-16 flex items-center justify-center">
                    <span className="text-body-sm font-medium text-text-secondary">
                      {payout.rank === 1 ? "1st" : payout.rank === 2 ? "2nd" : payout.rank === 3 ? "3rd" : `${payout.rank}th`}
                    </span>
                  </div>
                  <div className="flex-1 relative">
                    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-text-muted">$</span>
                    <input
                      type="number"
                      value={payout.amount}
                      onChange={(e) => handlePayoutChange(index, Math.max(0, parseInt(e.target.value) || 0))}
                      className="w-full pl-8 pr-4 py-2 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                      min={0}
                    />
                  </div>
                  {payouts.length > 1 && (
                    <button
                      onClick={() => handleRemovePayout(index)}
                      className="p-2 text-text-muted hover:text-danger transition-colors"
                      aria-label="Remove payout"
                    >
                      ×
                    </button>
                  )}
                </div>
              ))}
            </div>

            <div className="flex items-center justify-between pt-4 border-t border-border">
              <span className="text-body font-medium text-text-primary">Total Pot</span>
              <span className="text-section-title font-bold text-primary">${totalPayout.toLocaleString()}</span>
            </div>
          </div>
        );

      case "review":
        return (
          <div className="space-y-6">
            <div className="bg-subtle rounded-card p-4 space-y-4">
              <div className="flex items-center gap-3">
                <LuUsers className="w-5 h-5 text-primary" />
                <div>
                  <p className="text-caption text-text-muted">League Name</p>
                  <p className="text-body font-medium text-text-primary">{name}</p>
                </div>
              </div>

              <div className="flex items-center gap-3">
                <LuDollarSign className="w-5 h-5 text-primary" />
                <div>
                  <p className="text-caption text-text-muted">Entry Fee</p>
                  <p className="text-body font-medium text-text-primary">${entryFee}</p>
                </div>
              </div>

              <div className="flex items-center gap-3">
                <LuTrophy className="w-5 h-5 text-primary" />
                <div>
                  <p className="text-caption text-text-muted">Total Pot</p>
                  <p className="text-body font-medium text-text-primary">${totalPayout.toLocaleString()}</p>
                </div>
              </div>

              {maxPlayers && (
                <div className="flex items-center gap-3">
                  <LuUsers className="w-5 h-5 text-primary" />
                  <div>
                    <p className="text-caption text-text-muted">Max Players</p>
                    <p className="text-body font-medium text-text-primary">{maxPlayers}</p>
                  </div>
                </div>
              )}
            </div>

            <div>
              <p className="text-body-sm font-medium text-text-primary mb-2">Payout Breakdown</p>
              <div className="bg-subtle rounded-card p-3 space-y-2">
                {payouts.map((p) => (
                  <div key={p.rank} className="flex justify-between text-body-sm">
                    <span className="text-text-secondary">
                      {p.rank === 1 ? "1st Place" : p.rank === 2 ? "2nd Place" : p.rank === 3 ? "3rd Place" : `${p.rank}th Place`}
                    </span>
                    <span className="font-medium text-text-primary">${p.amount.toLocaleString()}</span>
                  </div>
                ))}
              </div>
            </div>
          </div>
        );

      case "success":
        return (
          <div className="text-center space-y-6">
            <div className="inline-flex items-center justify-center w-16 h-16 bg-success/10 rounded-full">
              <LuCheck className="w-8 h-8 text-success" />
            </div>

            <div>
              <h2 className="text-section-title font-bold text-text-primary mb-2">League Created!</h2>
              <p className="text-body text-text-secondary">
                Share the join code with your friends to invite them.
              </p>
            </div>

            <div className="bg-subtle rounded-card p-4 space-y-4">
              <div>
                <p className="text-caption text-text-muted mb-2">Join Code</p>
                <div className="flex items-center gap-2">
                  <code className="flex-1 px-4 py-3 bg-surface border border-border rounded-button text-center text-page-title font-mono font-bold text-primary tracking-widest">
                    {joinCode}
                  </code>
                  <button
                    onClick={handleCopyCode}
                    className="p-3 bg-surface border border-border rounded-button hover:bg-border transition-colors"
                    aria-label="Copy code"
                  >
                    {copied ? <LuCheck className="w-5 h-5 text-success" /> : <LuCopy className="w-5 h-5 text-text-secondary" />}
                  </button>
                </div>
              </div>

              <div>
                <p className="text-caption text-text-muted mb-2">Or share this link</p>
                <div className="flex items-center gap-2">
                  <input
                    type="text"
                    value={joinLink || ""}
                    readOnly
                    className="flex-1 px-4 py-2 bg-surface border border-border rounded-button text-body-sm text-text-secondary truncate"
                  />
                  <button
                    onClick={handleCopyLink}
                    className="p-2 bg-surface border border-border rounded-button hover:bg-border transition-colors"
                    aria-label="Copy link"
                  >
                    <LuCopy className="w-4 h-4 text-text-secondary" />
                  </button>
                </div>
              </div>
            </div>

            <button
              onClick={() => navigate("/picks")}
              className="w-full px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors"
            >
              Go to Picks
            </button>
          </div>
        );
    }
  };

  const stepTitles: Record<Step, string> = {
    name: "Create Your League",
    payouts: "Set Up Payouts",
    review: "Review & Create",
    success: "Success!",
  };

  return (
    <div className="max-w-lg mx-auto">
      {/* Header */}
      {step !== "success" && (
        <div className="mb-8">
          <button
            onClick={() => step === "name" ? navigate(-1) : setStep(step === "payouts" ? "name" : "payouts")}
            className="flex items-center gap-2 text-body-sm text-text-secondary hover:text-text-primary mb-4"
          >
            <LuArrowLeft className="w-4 h-4" />
            Back
          </button>
          <h1 className="text-page-title font-bold text-text-primary">{stepTitles[step]}</h1>

          {/* Progress indicator */}
          <div className="flex items-center gap-2 mt-4">
            {["name", "payouts", "review"].map((s, i) => (
              <div
                key={s}
                className={`h-1 flex-1 rounded-full transition-colors ${
                  s === step ? "bg-primary" :
                  ["name", "payouts", "review"].indexOf(step) > i ? "bg-primary/50" : "bg-border"
                }`}
              />
            ))}
          </div>
        </div>
      )}

      {/* Error message */}
      {error && (
        <div className="mb-6 p-4 bg-danger/10 border border-danger/20 rounded-card text-danger text-body-sm">
          {error}
        </div>
      )}

      {/* Step content */}
      <div className="bg-surface rounded-card border border-border p-6">
        {renderStep()}
      </div>

      {/* Navigation buttons */}
      {step !== "success" && (
        <div className="flex gap-3 mt-6">
          {step !== "name" && (
            <button
              onClick={() => setStep(step === "payouts" ? "name" : "payouts")}
              className="flex-1 px-6 py-3 bg-subtle text-text-secondary rounded-button font-medium hover:bg-border transition-colors"
            >
              Back
            </button>
          )}
          <button
            onClick={() => {
              if (step === "name") setStep("payouts");
              else if (step === "payouts") setStep("review");
              else handleCreate();
            }}
            disabled={!canProceed() || loading}
            className="flex-1 flex items-center justify-center gap-2 px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {loading ? (
              <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin" />
            ) : step === "review" ? (
              <>
                <LuCheck className="w-5 h-5" />
                Create League
              </>
            ) : (
              <>
                Continue
                <LuArrowRight className="w-5 h-5" />
              </>
            )}
          </button>
        </div>
      )}
    </div>
  );
};



========================================
FILE: frontend/src/features/league/JoinLeaguePage.tsx
========================================

/**
 * Join League Page - Browse public leagues or enter a join code for private ones
 */

import React, { useState, useEffect, useCallback } from "react";
import { useNavigate, useSearchParams } from "react-router-dom";
import { useAuth } from "../../auth/AuthContext";
import { useLeague } from "../../league/LeagueContext";
import { apiPost, getErrorMessage, getAvailableLeagues } from "../../lib/api";
import { LuArrowLeft, LuCheck, LuUsers, LuLock, LuGlobe, LuLoader } from "react-icons/lu";
import type { PublicLeagueSummary } from "../../types";

export const JoinLeaguePage: React.FC = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const { user } = useAuth();
  const { refreshLeagues, setActiveLeague } = useLeague();

  const [joinCode, setJoinCode] = useState(searchParams.get("code") || "");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<{ leagueName: string; leagueId: string } | null>(null);

  // Available public leagues
  const [availableLeagues, setAvailableLeagues] = useState<PublicLeagueSummary[]>([]);
  const [loadingLeagues, setLoadingLeagues] = useState(true);

  // Passcode modal state
  const [selectedLeague, setSelectedLeague] = useState<PublicLeagueSummary | null>(null);
  const [passcode, setPasscode] = useState("");
  const [joiningLeagueId, setJoiningLeagueId] = useState<string | null>(null);

  // Load available leagues
  const loadAvailableLeaguesFn = useCallback(async () => {
    if (!user) return;
    setLoadingLeagues(true);
    try {
      const data = await getAvailableLeagues(user);
      setAvailableLeagues(data.leagues || []);
    } catch (err) {
      console.error("Failed to load available leagues:", err);
    } finally {
      setLoadingLeagues(false);
    }
  }, [user]);

  useEffect(() => {
    loadAvailableLeaguesFn();
  }, [loadAvailableLeaguesFn]);

  // Auto-submit if code is provided in URL
  useEffect(() => {
    const codeFromUrl = searchParams.get("code");
    if (codeFromUrl && codeFromUrl.length === 6) {
      setJoinCode(codeFromUrl.toUpperCase());
    }
  }, [searchParams]);

  // Join a public league directly
  const handleJoinPublicLeague = async (league: PublicLeagueSummary) => {
    if (!user) return;

    setJoiningLeagueId(league.id);
    setError(null);

    try {
      const data = await apiPost<{
        leagueName: string;
        leagueId: string;
      }>("/joinLeague", { leagueId: league.id }, user);

      setSuccess({ leagueName: data.leagueName, leagueId: data.leagueId });
      await refreshLeagues();
      await setActiveLeague(data.leagueId);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setJoiningLeagueId(null);
    }
  };

  // Join with a passcode (for private leagues via code)
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user || !joinCode.trim()) return;

    setLoading(true);
    setError(null);

    try {
      const data = await apiPost<{
        leagueName: string;
        leagueId: string;
      }>("/joinLeague", {
        joinCode: joinCode.trim().toUpperCase(),
        passcode: passcode || undefined,
      }, user);

      setSuccess({ leagueName: data.leagueName, leagueId: data.leagueId });
      await refreshLeagues();
      await setActiveLeague(data.leagueId);
    } catch (err) {
      const errorMessage = getErrorMessage(err);
      // If passcode is required, show passcode input
      if (errorMessage.toLowerCase().includes("passcode required")) {
        setSelectedLeague({
          id: "",
          name: "Private League",
          season: "",
          memberCount: 0,
          status: "active",
          entryFee: 0,
          isPublic: false
        });
      } else {
        setError(errorMessage);
      }
    } finally {
      setLoading(false);
    }
  };

  const handleCodeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Only allow alphanumeric, uppercase, max 8 chars
    const value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 8);
    setJoinCode(value);
    setError(null);
  };

  if (success) {
    return (
      <div className="max-w-md mx-auto text-center">
        <div className="bg-surface rounded-card border border-border p-8">
          <div className="inline-flex items-center justify-center w-16 h-16 bg-success/10 rounded-full mb-6">
            <LuCheck className="w-8 h-8 text-success" />
          </div>
          
          <h1 className="text-section-title font-bold text-text-primary mb-2">
            You're In!
          </h1>
          <p className="text-body text-text-secondary mb-6">
            You've successfully joined <span className="font-medium text-text-primary">{success.leagueName}</span>
          </p>
          
          <button
            onClick={() => navigate("/picks")}
            className="w-full px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors"
          >
            Start Making Picks
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-2xl mx-auto">
      {/* Header */}
      <div className="mb-8">
        <button
          onClick={() => navigate(-1)}
          className="flex items-center gap-2 text-body-sm text-text-secondary hover:text-text-primary mb-4"
        >
          <LuArrowLeft className="w-4 h-4" />
          Back
        </button>
        <h1 className="text-page-title font-bold text-text-primary">Join a League</h1>
        <p className="text-body text-text-secondary mt-2">
          Browse public leagues or enter a join code for private leagues.
        </p>
      </div>

      {/* Error message */}
      {error && (
        <div className="mb-6 p-4 bg-danger/10 border border-danger/20 rounded-card text-danger text-body-sm">
          {error}
        </div>
      )}

      {/* Available Public Leagues */}
      <div className="bg-surface rounded-card border border-border p-6 mb-6">
        <h2 className="text-section-title font-semibold text-text-primary mb-4 flex items-center gap-2">
          <LuGlobe className="w-5 h-5 text-primary" />
          Public Leagues
        </h2>

        {loadingLeagues ? (
          <div className="flex items-center justify-center py-8">
            <LuLoader className="w-6 h-6 text-text-muted animate-spin" />
          </div>
        ) : availableLeagues.length === 0 ? (
          <p className="text-body text-text-muted text-center py-8">
            No public leagues available to join right now.
          </p>
        ) : (
          <div className="space-y-3">
            {availableLeagues.map((league) => (
              <div
                key={league.id}
                className="flex items-center justify-between p-4 bg-background rounded-button border border-border hover:border-primary/30 transition-colors"
              >
                <div>
                  <h3 className="font-medium text-text-primary">{league.name}</h3>
                  <p className="text-body-sm text-text-secondary">
                    {league.season} • {league.memberCount}{league.maxPlayers ? `/${league.maxPlayers}` : ""} members
                    {league.entryFee > 0 && ` • $${league.entryFee} entry`}
                  </p>
                </div>
                <button
                  onClick={() => handleJoinPublicLeague(league)}
                  disabled={joiningLeagueId === league.id}
                  className="px-4 py-2 bg-primary text-white rounded-button text-body-sm font-medium hover:bg-primary-hover transition-colors disabled:opacity-50"
                >
                  {joiningLeagueId === league.id ? (
                    <LuLoader className="w-4 h-4 animate-spin" />
                  ) : (
                    "Join"
                  )}
                </button>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Join with Code (for private leagues) */}
      <div className="bg-surface rounded-card border border-border p-6">
        <h2 className="text-section-title font-semibold text-text-primary mb-4 flex items-center gap-2">
          <LuLock className="w-5 h-5 text-text-secondary" />
          Have a Join Code?
        </h2>
        <p className="text-body-sm text-text-secondary mb-4">
          Enter the code shared by your league commissioner to join a private league.
        </p>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-body-sm font-medium text-text-primary mb-2">
              Join Code
            </label>
            <input
              type="text"
              value={joinCode}
              onChange={handleCodeChange}
              placeholder="ABC123"
              className="w-full px-4 py-3 bg-surface border border-border rounded-button text-center text-lg font-mono font-bold text-text-primary tracking-widest placeholder:text-text-muted placeholder:font-normal placeholder:tracking-normal focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              maxLength={8}
              autoComplete="off"
              autoCapitalize="characters"
            />
          </div>

          {/* Passcode field - shown when joining private league */}
          {selectedLeague && (
            <div>
              <label className="block text-body-sm font-medium text-text-primary mb-2">
                Passcode
              </label>
              <input
                type="password"
                value={passcode}
                onChange={(e) => setPasscode(e.target.value)}
                placeholder="Enter passcode"
                className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                autoFocus
              />
              <p className="mt-2 text-caption text-text-muted">
                This league is private. Enter the passcode to join.
              </p>
            </div>
          )}

          <button
            type="submit"
            disabled={joinCode.length < 4 || loading}
            className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {loading ? (
              <LuLoader className="w-5 h-5 animate-spin" />
            ) : (
              <>
                <LuUsers className="w-5 h-5" />
                Join League
              </>
            )}
          </button>
        </form>
      </div>

      {/* Alternative */}
      <div className="mt-8 text-center">
        <p className="text-body-sm text-text-muted mb-3">Want to start your own?</p>
        <button
          onClick={() => navigate("/create-league")}
          className="text-body-sm text-primary hover:text-primary-hover font-medium"
        >
          Create your own league →
        </button>
      </div>
    </div>
  );
};



========================================
FILE: frontend/src/features/league/LeagueSettingsPage.tsx
========================================

/**
 * League Settings Page - Manage league settings (owner only)
 */

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../auth/AuthContext";
import { useLeague } from "../../league/LeagueContext";
import { apiPost, getErrorMessage } from "../../lib/api";
import { mapLeagueMember, mapDocs } from "../../lib/firestore";
import { LuArrowLeft, LuCopy, LuCheck, LuRefreshCw, LuUsers, LuSettings, LuDollarSign, LuLock, LuLockOpen, LuCalendar, LuChevronRight, LuGlobe, LuEye, LuEyeOff } from "react-icons/lu";
import type { LeagueMember } from "../../types";
import { collection, getDocs, query, where } from "firebase/firestore";
import { db } from "../../firebase";

export const LeagueSettingsPage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { activeLeague, activeLeagueId, userRole, refreshActiveLeague } = useLeague();
  
  const [members, setMembers] = useState<LeagueMember[]>([]);
  const [loadingMembers, setLoadingMembers] = useState(true);
  const [copied, setCopied] = useState(false);
  const [regenerating, setRegenerating] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  // Editable fields
  const [editingName, setEditingName] = useState(false);
  const [newName, setNewName] = useState("");
  const [membershipLocked, setMembershipLocked] = useState(false);
  const [isPublic, setIsPublic] = useState(true);
  const [passcode, setPasscode] = useState("");
  const [showPasscode, setShowPasscode] = useState(false);

  // Load members
  useEffect(() => {
    const loadMembers = async () => {
      if (!activeLeagueId) return;
      
      try {
        setLoadingMembers(true);
        const membersRef = collection(db, "leagues", activeLeagueId, "members");
        const q = query(membersRef, where("isActive", "==", true));
        const snap = await getDocs(q);
        
        const memberList = mapDocs(snap.docs, mapLeagueMember);

        setMembers(memberList.sort((a, b) => {
          // Owner first, then by name
          if (a.role === "owner") return -1;
          if (b.role === "owner") return 1;
          return a.displayName.localeCompare(b.displayName);
        }));
      } catch (err) {
        console.error("Error loading members:", err);
      } finally {
        setLoadingMembers(false);
      }
    };
    
    loadMembers();
  }, [activeLeagueId]);

  // Initialize editable fields
  useEffect(() => {
    if (activeLeague) {
      setNewName(activeLeague.name);
      setMembershipLocked(activeLeague.membershipLocked || false);
      setIsPublic(activeLeague.isPublic ?? true);
      setPasscode(activeLeague.passcode || "");
    }
  }, [activeLeague]);

  // Redirect if not owner
  if (userRole !== "owner") {
    return (
      <div className="max-w-lg mx-auto text-center py-12">
        <LuLock className="w-12 h-12 text-text-muted mx-auto mb-4" />
        <h1 className="text-section-title font-bold text-text-primary mb-2">Access Denied</h1>
        <p className="text-body text-text-secondary mb-6">
          Only the league owner can access settings.
        </p>
        <button
          onClick={() => navigate(-1)}
          className="px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors"
        >
          Go Back
        </button>
      </div>
    );
  }

  if (!activeLeague) {
    return (
      <div className="max-w-lg mx-auto text-center py-12">
        <div className="w-8 h-8 border-2 border-primary border-t-transparent rounded-full animate-spin mx-auto" />
      </div>
    );
  }

  const handleCopyCode = async () => {
    if (activeLeague.joinCode) {
      await navigator.clipboard.writeText(activeLeague.joinCode);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handleRegenerateCode = async () => {
    if (!user || !activeLeagueId) return;

    setRegenerating(true);
    setError(null);

    try {
      await apiPost("/regenerateJoinCode", { leagueId: activeLeagueId }, user);
      await refreshActiveLeague();
      setSuccessMessage("Join code regenerated!");
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setRegenerating(false);
    }
  };

  const handleSaveName = async () => {
    if (!user || !activeLeagueId || newName.trim() === activeLeague.name) {
      setEditingName(false);
      return;
    }

    setSaving(true);
    setError(null);

    try {
      await apiPost("/updateLeagueSettings", { leagueId: activeLeagueId, name: newName.trim() }, user);
      await refreshActiveLeague();
      setEditingName(false);
      setSuccessMessage("League name updated!");
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setSaving(false);
    }
  };

  const handleToggleMembershipLock = async () => {
    if (!user || !activeLeagueId) return;

    setSaving(true);
    setError(null);

    try {
      await apiPost("/updateLeagueSettings", { leagueId: activeLeagueId, membershipLocked: !membershipLocked }, user);
      setMembershipLocked(!membershipLocked);
      await refreshActiveLeague();
      setSuccessMessage(membershipLocked ? "League is now open for new members" : "League is now locked");
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setSaving(false);
    }
  };

  const handleTogglePublic = async () => {
    if (!user || !activeLeagueId) return;

    // If making private, require a passcode
    if (isPublic && !passcode) {
      setError("Please set a passcode before making the league private");
      return;
    }

    setSaving(true);
    setError(null);

    try {
      await apiPost("/updateLeagueSettings", {
        leagueId: activeLeagueId,
        isPublic: !isPublic,
        passcode: !isPublic ? undefined : passcode, // Include passcode when making private
      }, user);
      setIsPublic(!isPublic);
      await refreshActiveLeague();
      setSuccessMessage(isPublic ? "League is now private" : "League is now public");
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setSaving(false);
    }
  };

  const handleSavePasscode = async () => {
    if (!user || !activeLeagueId) return;

    if (passcode.length < 4) {
      setError("Passcode must be at least 4 characters");
      return;
    }

    setSaving(true);
    setError(null);

    try {
      await apiPost("/updateLeagueSettings", { leagueId: activeLeagueId, passcode }, user);
      await refreshActiveLeague();
      setSuccessMessage("Passcode updated!");
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (err) {
      setError(getErrorMessage(err));
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      {/* Header */}
      <div className="mb-8">
        <button
          onClick={() => navigate(-1)}
          className="flex items-center gap-2 text-body-sm text-text-secondary hover:text-text-primary mb-4"
        >
          <LuArrowLeft className="w-4 h-4" />
          Back
        </button>
        <h1 className="text-page-title font-bold text-text-primary">League Settings</h1>
        <p className="text-body text-text-secondary mt-1">{activeLeague.name}</p>
      </div>

      {/* Messages */}
      {error && (
        <div className="mb-6 p-4 bg-danger/10 border border-danger/20 rounded-card text-danger text-body-sm">
          {error}
        </div>
      )}
      {successMessage && (
        <div className="mb-6 p-4 bg-success/10 border border-success/20 rounded-card text-success text-body-sm">
          {successMessage}
        </div>
      )}

      <div className="space-y-6">
        {/* League Name */}
        <div className="bg-surface rounded-card border border-border p-6">
          <div className="flex items-center gap-2 mb-4">
            <LuSettings className="w-5 h-5 text-primary" />
            <h2 className="text-body font-semibold text-text-primary">General</h2>
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-body-sm font-medium text-text-primary mb-2">
                League Name
              </label>
              {editingName ? (
                <div className="flex gap-2">
                  <input
                    type="text"
                    value={newName}
                    onChange={(e) => setNewName(e.target.value)}
                    className="flex-1 px-4 py-2 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
                    maxLength={50}
                    autoFocus
                  />
                  <button
                    onClick={handleSaveName}
                    disabled={saving || newName.trim().length < 2}
                    className="px-4 py-2 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50"
                  >
                    {saving ? "..." : "Save"}
                  </button>
                  <button
                    onClick={() => { setEditingName(false); setNewName(activeLeague.name); }}
                    className="px-4 py-2 bg-subtle text-text-secondary rounded-button font-medium hover:bg-border transition-colors"
                  >
                    Cancel
                  </button>
                </div>
              ) : (
                <div className="flex items-center justify-between">
                  <span className="text-body text-text-primary">{activeLeague.name}</span>
                  <button
                    onClick={() => setEditingName(true)}
                    className="text-body-sm text-primary hover:text-primary-hover font-medium"
                  >
                    Edit
                  </button>
                </div>
              )}
            </div>

            <div className="flex items-center justify-between pt-4 border-t border-border">
              <div>
                <p className="text-body-sm font-medium text-text-primary">Lock Membership</p>
                <p className="text-caption text-text-muted">Prevent new members from joining</p>
              </div>
              <button
                onClick={handleToggleMembershipLock}
                disabled={saving}
                className={`flex items-center gap-2 px-4 py-2 rounded-button font-medium transition-colors ${
                  membershipLocked
                    ? "bg-warning/10 text-warning hover:bg-warning/20"
                    : "bg-subtle text-text-secondary hover:bg-border"
                }`}
              >
                {membershipLocked ? <LuLock className="w-4 h-4" /> : <LuLockOpen className="w-4 h-4" />}
                {membershipLocked ? "Locked" : "Open"}
              </button>
            </div>
          </div>
        </div>

        {/* Public/Private Toggle */}
        <div className="bg-surface rounded-card border border-border p-6">
          <div className="flex items-center gap-2 mb-4">
            <LuGlobe className="w-5 h-5 text-primary" />
            <h2 className="text-body font-semibold text-text-primary">League Visibility</h2>
          </div>

          <div className="space-y-4">
            {/* Public/Private Toggle */}
            <div className="flex items-center justify-between">
              <div>
                <p className="text-body font-medium text-text-primary">
                  {isPublic ? "Public League" : "Private League"}
                </p>
                <p className="text-body-sm text-text-secondary">
                  {isPublic
                    ? "Anyone can find and join this league"
                    : "Only people with the passcode can join"}
                </p>
              </div>
              <button
                onClick={handleTogglePublic}
                disabled={saving || (!isPublic && !passcode)}
                className={`flex items-center gap-2 px-4 py-2 rounded-button font-medium transition-colors ${
                  isPublic
                    ? "bg-success/10 text-success hover:bg-success/20"
                    : "bg-warning/10 text-warning hover:bg-warning/20"
                }`}
              >
                {isPublic ? <LuGlobe className="w-4 h-4" /> : <LuLock className="w-4 h-4" />}
                {isPublic ? "Public" : "Private"}
              </button>
            </div>

            {/* Passcode (for private leagues) */}
            {!isPublic && (
              <div>
                <label className="block text-body-sm font-medium text-text-primary mb-2">
                  Passcode
                </label>
                <div className="flex items-center gap-2">
                  <div className="relative flex-1">
                    <input
                      type={showPasscode ? "text" : "password"}
                      value={passcode}
                      onChange={(e) => setPasscode(e.target.value)}
                      placeholder="Enter passcode"
                      className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent pr-10"
                      maxLength={20}
                    />
                    <button
                      type="button"
                      onClick={() => setShowPasscode(!showPasscode)}
                      className="absolute right-3 top-1/2 -translate-y-1/2 text-text-muted hover:text-text-secondary"
                    >
                      {showPasscode ? <LuEyeOff className="w-4 h-4" /> : <LuEye className="w-4 h-4" />}
                    </button>
                  </div>
                  <button
                    onClick={handleSavePasscode}
                    disabled={saving || passcode.length < 4}
                    className="px-4 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50"
                  >
                    {saving ? "..." : "Save"}
                  </button>
                </div>
                <p className="mt-2 text-caption text-text-muted">
                  Share this passcode with people you want to invite.
                </p>
              </div>
            )}
          </div>
        </div>

        {/* Join Code */}
        <div className="bg-surface rounded-card border border-border p-6">
          <div className="flex items-center gap-2 mb-4">
            <LuUsers className="w-5 h-5 text-primary" />
            <h2 className="text-body font-semibold text-text-primary">Invite Members</h2>
          </div>

          <div className="space-y-4">
            <div>
              <label className="block text-body-sm font-medium text-text-primary mb-2">
                Join Code
              </label>
              <div className="flex items-center gap-2">
                <code className="flex-1 px-4 py-3 bg-subtle border border-border rounded-button text-center text-section-title font-mono font-bold text-primary tracking-widest">
                  {activeLeague.joinCode}
                </code>
                <button
                  onClick={handleCopyCode}
                  className="p-3 bg-subtle border border-border rounded-button hover:bg-border transition-colors"
                  aria-label="Copy code"
                >
                  {copied ? <LuCheck className="w-5 h-5 text-success" /> : <LuCopy className="w-5 h-5 text-text-secondary" />}
                </button>
                <button
                  onClick={handleRegenerateCode}
                  disabled={regenerating}
                  className="p-3 bg-subtle border border-border rounded-button hover:bg-border transition-colors disabled:opacity-50"
                  aria-label="Regenerate code"
                >
                  <LuRefreshCw className={`w-5 h-5 text-text-secondary ${regenerating ? "animate-spin" : ""}`} />
                </button>
              </div>
              <p className="mt-2 text-caption text-text-muted">
                Share this code with friends to invite them to your league.
              </p>
            </div>
          </div>
        </div>

        {/* Members */}
        <div className="bg-surface rounded-card border border-border p-6">
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-2">
              <LuUsers className="w-5 h-5 text-primary" />
              <h2 className="text-body font-semibold text-text-primary">Members</h2>
            </div>
            <span className="text-body-sm text-text-muted">{members.length} members</span>
          </div>

          {loadingMembers ? (
            <div className="flex justify-center py-8">
              <div className="w-6 h-6 border-2 border-primary border-t-transparent rounded-full animate-spin" />
            </div>
          ) : (
            <div className="space-y-2">
              {members.map((member) => (
                <div
                  key={member.userId}
                  className="flex items-center gap-3 p-3 bg-subtle rounded-button"
                >
                  <div className="w-8 h-8 rounded-full bg-primary-soft text-primary flex items-center justify-center text-caption font-semibold">
                    {member.displayName?.split(" ").map((n) => n[0]).join("").toUpperCase().slice(0, 2) || "?"}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-body-sm font-medium text-text-primary truncate">
                      {member.displayName}
                    </p>
                    <p className="text-caption text-text-muted truncate">{member.email}</p>
                  </div>
                  <span className={`text-caption font-medium px-2 py-1 rounded ${
                    member.role === "owner"
                      ? "bg-primary-soft text-primary"
                      : "bg-subtle text-text-muted"
                  }`}>
                    {member.role === "owner" ? "Owner" : "Member"}
                  </span>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* League Info */}
        <div className="bg-surface rounded-card border border-border p-6">
          <div className="flex items-center gap-2 mb-4">
            <LuDollarSign className="w-5 h-5 text-primary" />
            <h2 className="text-body font-semibold text-text-primary">League Info</h2>
          </div>

          <div className="grid grid-cols-2 gap-4 text-body-sm">
            <div>
              <p className="text-text-muted">Season</p>
              <p className="font-medium text-text-primary">{activeLeague.season}</p>
            </div>
            <div>
              <p className="text-text-muted">Entry Fee</p>
              <p className="font-medium text-text-primary">${activeLeague.entryFee}</p>
            </div>
            <div>
              <p className="text-text-muted">Total Pot</p>
              <p className="font-medium text-text-primary">${activeLeague.payoutTotal?.toLocaleString() || 0}</p>
            </div>
            <div>
              <p className="text-text-muted">Status</p>
              <p className="font-medium text-text-primary capitalize">{activeLeague.status}</p>
            </div>
          </div>
        </div>

        {/* Mid-Season Setup */}
        <div className="bg-surface rounded-card border border-border p-6">
          <div className="flex items-center gap-2 mb-4">
            <LuCalendar className="w-5 h-5 text-primary" />
            <h2 className="text-body font-semibold text-text-primary">Mid-Season Setup</h2>
          </div>

          <p className="text-body-sm text-text-secondary mb-4">
            Import historical picks and scores from a spreadsheet to continue an existing league mid-season.
          </p>

          <button
            onClick={() => navigate("/admin/backfill")}
            className="w-full flex items-center justify-between p-4 bg-subtle rounded-button hover:bg-border transition-colors"
          >
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-primary-soft text-primary flex items-center justify-center">
                <LuCalendar className="w-5 h-5" />
              </div>
              <div className="text-left">
                <p className="text-body font-medium text-text-primary">Backfill Wizard</p>
                <p className="text-caption text-text-muted">Enter historical picks and compute scores</p>
              </div>
            </div>
            <LuChevronRight className="w-5 h-5 text-text-muted" />
          </button>
        </div>
      </div>
    </div>
  );
};



========================================
FILE: frontend/src/features/picks/WeeklyPicksPage.tsx
========================================

import React, { useEffect, useState, useMemo, useCallback } from "react";
import { auth, db } from "../../firebase";
import { onAuthStateChanged, type User } from "firebase/auth";
import { collection, query, where, getDocs, doc, getDoc, Timestamp } from "firebase/firestore";
import type { Game, PlayerUsage, PlayerOption } from "../../types";
import { Button, Badge, Card, Alert, Input, Select, PlayerListSkeleton } from "../../components";
import { useLeague } from "../../league/LeagueContext";
import { submitPicks as submitPicksApi, getErrorMessage } from "../../lib/api";
import { SEASON, SEASON_START } from "../../lib/config";
import { mapGame, mapPlayer, mapPlayerUsage, mapUserPicks, toDate } from "../../lib/firestore";

type PositionKey = "qb" | "rb" | "wr";

interface PicksState {
  qbPlayerId?: string;
  qbGameId?: string;
  qbLocked?: boolean;
  rbPlayerId?: string;
  rbGameId?: string;
  rbLocked?: boolean;
  wrPlayerId?: string;
  wrGameId?: string;
  wrLocked?: boolean;
}

type SortOption = "fantasyPoints" | "kickoff" | "name";

// Helper to parse kickoffTime robustly - handles Timestamp, Timestamp-like object, or string
function parseKickoffTime(kickoffTime: unknown): Date {
  if (kickoffTime instanceof Timestamp) {
    return kickoffTime.toDate();
  }
  if (kickoffTime && typeof kickoffTime === "object" && "seconds" in kickoffTime) {
    // Handle Timestamp-like object with seconds/nanoseconds (from Firestore)
    const ts = kickoffTime as { seconds: number; nanoseconds?: number };
    return new Date(ts.seconds * 1000);
  }
  if (typeof kickoffTime === "string") {
    return new Date(kickoffTime);
  }
  // Fallback - shouldn't happen but treat as far future (unlocked)
  return new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);
}

// Position display configuration
const positionConfig = {
  qb: { label: "Quarterback", shortLabel: "QB", color: "text-red-600", bgColor: "bg-red-50" },
  rb: { label: "Running Back", shortLabel: "RB", color: "text-blue-600", bgColor: "bg-blue-50" },
  wr: { label: "Wide Receiver", shortLabel: "WR", color: "text-amber-600", bgColor: "bg-amber-50" },
};

export const WeeklyPicksPage: React.FC = () => {
  const { activeLeagueId, loading: leagueLoading } = useLeague();
  const [players, setPlayers] = useState<PlayerOption[]>([]);
  const [picks, setPicks] = useState<PicksState>({});
  const [savedPicks, setSavedPicks] = useState<PicksState>({});
  const [usedPlayerIds, setUsedPlayerIds] = useState<Set<string>>(new Set());
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(true);
  const [weekId, setWeekId] = useState<string>("");
  const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null);
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>("");
  const [sortBy, setSortBy] = useState<SortOption>("fantasyPoints");
  const [hideUnavailable, setHideUnavailable] = useState<boolean>(false);
  const [availableWeeks, setAvailableWeeks] = useState<number[]>([]);

  // Use activeLeagueId from context
  const leagueId = activeLeagueId;

  // Count unavailable players for display
  const unavailableCount = useMemo(() => {
    return players.filter(p => p.isLocked || p.isUsed).length;
  }, [players]);

  // Listen for auth state changes
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setCurrentUser(user);
    });
    return () => unsubscribe();
  }, []);

  // Load available weeks (filter out completed weeks)
  useEffect(() => {
    async function loadAvailableWeeks() {
      try {
        // Load all games to determine which weeks are still active
        const gamesRef = collection(db, "games");
        const gamesSnap = await getDocs(gamesRef);

        const now = Date.now();
        const weekGames = new Map<number, { allPast: boolean; hasGames: boolean }>();

        // Initialize all 18 weeks
        for (let w = 1; w <= 18; w++) {
          weekGames.set(w, { allPast: true, hasGames: false });
        }

        gamesSnap.forEach((doc) => {
          const game = doc.data();
          const weekNum = game.weekNumber;
          if (!weekNum || weekNum < 1 || weekNum > 18) return;

          const kickoffTime = parseKickoffTime(game.kickoffTime);

          // Skip games that are before the season start (e.g., playoff games from previous season)
          if (kickoffTime < SEASON_START) return;

          const weekData = weekGames.get(weekNum)!;
          weekData.hasGames = true;

          // If any game in this week hasn't finished yet (kickoff + 4 hours buffer for game completion)
          const gameEndEstimate = kickoffTime.getTime() + (4 * 60 * 60 * 1000);
          if (gameEndEstimate > now) {
            weekData.allPast = false;
          }
        });

        // Filter to weeks that either have no games yet or have games not all in the past
        const available = Array.from(weekGames.entries())
          .filter(([, data]) => !data.hasGames || !data.allPast)
          .map(([weekNum]) => weekNum)
          .sort((a, b) => a - b);

        setAvailableWeeks(available.length > 0 ? available : [1]);
      } catch {
        // Fallback to all weeks if there's an error
        setAvailableWeeks(Array.from({ length: 18 }, (_, i) => i + 1));
      }
    }
    loadAvailableWeeks();
  }, []);

  // Determine current week from Firestore config (synced from ESPN)
  useEffect(() => {
    async function loadCurrentWeek() {
      try {
        const configRef = doc(db, "config", "season");
        const configSnap = await getDoc(configRef);
        if (configSnap.exists()) {
          const data = configSnap.data();
          const currentWeek = data.currentWeek || 1;
          setWeekId(`week-${currentWeek}`);
        } else {
          setWeekId("week-1");
        }
      } catch {
        // Fallback to week 1 if config not available
        setWeekId("week-1");
      }
    }
    loadCurrentWeek();
  }, []);

  // Load players, games, and user's existing picks
  useEffect(() => {
    // Don't run until we have weekId set (not empty string)
    if (!weekId) {
      return;
    }

    // If missing user or league, show not loading
    if (!currentUser || !leagueId) {
      setLoading(false);
      return;
    }

    let cancelled = false;

    // Capture values for use in async function (TypeScript narrowing)
    const userId = currentUser.uid;
    const currentLeagueId = leagueId;
    const currentWeekId = weekId;

    async function loadData() {
      // Reset state at the start of load to prevent stale data
      setPlayers([]);
      setUsedPlayerIds(new Set());
      setPicks({});
      setSavedPicks({});
      setLoading(true);

      try {
        const weekNumber = parseInt(currentWeekId.replace("week-", ""));

        // Load games for this week
        const gamesRef = collection(db, "games");
        const gamesQuery = query(gamesRef, where("weekNumber", "==", weekNumber));
        const gamesSnap = await getDocs(gamesQuery);

        const gamesMap = new Map<string, Game>();
        gamesSnap.forEach((gameDoc) => {
          const game = mapGame(gameDoc);
          if (!game) return;

          // Filter out games that are before the season start (e.g., playoff games from previous season)
          const kickoff = toDate(game.kickoffTime) || new Date();
          if (kickoff >= SEASON_START) {
            gamesMap.set(gameDoc.id, game);
          }
        });

        // Load all players
        const playersRef = collection(db, "players");
        const playersSnap = await getDocs(playersRef);

        // Load user's player usage for this season AND league
        const usageRef = collection(db, "users", userId, "playerUsage");
        const usageQuery = query(
          usageRef,
          where("season", "==", SEASON),
          where("leagueId", "==", currentLeagueId)
        );
        const usageSnap = await getDocs(usageQuery);

        const usedIds = new Set<string>();
        const usageByPlayer = new Map<string, PlayerUsage>();
        usageSnap.forEach((usageDoc) => {
          const usage = mapPlayerUsage(usageDoc);
          if (!usage) return;
          usedIds.add(usage.playerId);
          usageByPlayer.set(usage.playerId, usage);
        });
        setUsedPlayerIds(usedIds);

        // Load existing picks for this week
        const pickDocRef = doc(db, "leagues", currentLeagueId, "weeks", currentWeekId, "picks", userId);
        const pickSnap = await getDoc(pickDocRef);
        const existingPicks = mapUserPicks(pickSnap);
        if (existingPicks) {
          const picksState: PicksState = {
            qbPlayerId: existingPicks.qbPlayerId,
            qbGameId: existingPicks.qbGameId,
            qbLocked: existingPicks.qbLocked,
            rbPlayerId: existingPicks.rbPlayerId,
            rbGameId: existingPicks.rbGameId,
            rbLocked: existingPicks.rbLocked,
            wrPlayerId: existingPicks.wrPlayerId,
            wrGameId: existingPicks.wrGameId,
            wrLocked: existingPicks.wrLocked,
          };
          setPicks(picksState);
          setSavedPicks(picksState);
        } else {
          setPicks({});
          setSavedPicks({});
        }

        // Build player options with game info
        const now = Date.now();
        const oneHour = 60 * 60 * 1000;
        const playerOptions: PlayerOption[] = [];

        playersSnap.forEach((pDoc) => {
          const player = mapPlayer(pDoc);
          if (!player) return;

          // Find games for this player's team this week
          gamesMap.forEach((game) => {
            const isHome = game.homeTeamId === player.teamId;
            const isAway = game.awayTeamId === player.teamId;
            if (!isHome && !isAway) return;

            const kickoffTime = toDate(game.kickoffTime) || new Date();
            const isLocked = now > kickoffTime.getTime() - oneHour;
            const opponent = isHome ? `vs ${game.awayTeamName}` : `@ ${game.homeTeamName}`;

            // Check if player was used in a different week
            const usage = usageByPlayer.get(pDoc.id);
            const isUsedInDifferentWeek = usage && usage.firstUsedWeek !== weekId;

            playerOptions.push({
              id: pDoc.id,
              name: player.name,
              team: player.teamName || player.teamId,
              position: player.position,
              gameId: game.id || game.gameId,
              gameLabel: `${game.awayTeamName} @ ${game.homeTeamName}`,
              kickoff: kickoffTime,
              kickoffFormatted: kickoffTime.toLocaleString("en-US", {
                weekday: "short",
                month: "short",
                day: "numeric",
                hour: "numeric",
                minute: "2-digit",
              }),
              isLocked,
              isUsed: isUsedInDifferentWeek || false,
              opponent,
              seasonStats: player.seasonStats,
            });
          });
        });

        // Sort by kickoff time
        playerOptions.sort((a, b) => a.kickoff.getTime() - b.kickoff.getTime());

        // Only update state if the effect hasn't been cancelled
        if (!cancelled) {
          setPlayers(playerOptions);
        }
      } catch {
        if (!cancelled) {
          setMessage({ type: "error", text: "Failed to load players and games" });
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    loadData();

    // Cleanup function to prevent state updates if component unmounts or deps change
    return () => {
      cancelled = true;
    };
  }, [weekId, leagueId, currentUser]);

  const handlePick = useCallback((pos: PositionKey, option: PlayerOption) => {
    if (option.isLocked || option.isUsed) return;

    setPicks((prev) => {
      if (prev[`${pos}Locked` as keyof PicksState]) return prev;
      return {
        ...prev,
        [`${pos}PlayerId`]: option.id,
        [`${pos}GameId`]: option.gameId,
      };
    });
  }, []);

  // Filter players by search query (name or team) and availability
  const filteredPlayers = useMemo(() => {
    let result = players;

    // Apply search filter
    if (searchQuery.trim()) {
      const q = searchQuery.toLowerCase();
      result = result.filter(
        (p) =>
          p.name.toLowerCase().includes(q) ||
          p.team.toLowerCase().includes(q)
      );
    }

    // Apply availability filter
    if (hideUnavailable) {
      result = result.filter((p) => !p.isLocked && !p.isUsed);
    }

    // Apply sorting
    result = [...result].sort((a, b) => {
      switch (sortBy) {
        case "fantasyPoints":
          // Sort by fantasy points descending (higher is better)
          return (b.seasonStats?.fantasyPoints || 0) - (a.seasonStats?.fantasyPoints || 0);
        case "kickoff":
          // Sort by kickoff time ascending (earlier first)
          return a.kickoff.getTime() - b.kickoff.getTime();
        case "name":
          // Sort alphabetically
          return a.name.localeCompare(b.name);
        default:
          return 0;
      }
    });

    return result;
  }, [players, searchQuery, sortBy, hideUnavailable]);

  const groupedByPos = useMemo(() => ({
    qb: filteredPlayers.filter((p) => p.position === "QB"),
    rb: filteredPlayers.filter((p) => p.position === "RB"),
    wr: filteredPlayers.filter((p) => p.position === "WR"),
  }), [filteredPlayers]);

  const savePicks = useCallback(async () => {
    if (!currentUser || !leagueId) return;

    setSaving(true);
    setMessage(null);

    try {
      const data = await submitPicksApi(currentUser, {
        leagueId,
        weekId,
        picks: {
          qbPlayerId: picks.qbPlayerId,
          qbGameId: picks.qbGameId,
          rbPlayerId: picks.rbPlayerId,
          rbGameId: picks.rbGameId,
          wrPlayerId: picks.wrPlayerId,
          wrGameId: picks.wrGameId,
        },
      });

      if (data.ok) {
        setSavedPicks(picks);
        const accepted = data.accepted?.join(", ") || "none";
        const skipped = data.skipped?.length > 0 ? ` (skipped: ${data.skipped.join("; ")})` : "";
        setMessage({ type: "success", text: `Picks saved! Accepted: ${accepted}${skipped}` });
      } else {
        setMessage({ type: "error", text: data.error || "Failed to save picks" });
      }
    } catch (error) {
      setMessage({ type: "error", text: getErrorMessage(error) });
    } finally {
      setSaving(false);
    }
  }, [currentUser, leagueId, weekId, picks]);

  const getTimeUntilLock = useCallback((kickoff: Date): string => {
    const now = Date.now();
    const lockTime = kickoff.getTime() - 60 * 60 * 1000;
    const diff = lockTime - now;

    if (diff <= 0) return "LOCKED";

    const hours = Math.floor(diff / (60 * 60 * 1000));
    const mins = Math.floor((diff % (60 * 60 * 1000)) / (60 * 1000));

    if (hours > 24) {
      const days = Math.floor(hours / 24);
      return `${days}d ${hours % 24}h`;
    }
    return `${hours}h ${mins}m`;
  }, []);

  const renderColumn = (pos: PositionKey) => {
    const posPlayers = groupedByPos[pos];
    const selectedId = picks[`${pos}PlayerId` as keyof PicksState];
    const isLocked = picks[`${pos}Locked` as keyof PicksState];
    const selectedPlayer = posPlayers.find(p => p.id === selectedId);
    const config = positionConfig[pos];

    return (
      <Card padding="none" className="flex flex-col overflow-hidden">
        {/* Position header */}
        <div className={`px-4 py-3 border-b border-border ${config.bgColor}`}>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <span className={`text-card-title font-semibold ${config.color}`}>
                {config.label}
              </span>
              <Badge variant="neutral" size="sm">{config.shortLabel}</Badge>
            </div>
            {isLocked && <Badge variant="error">LOCKED</Badge>}
          </div>
        </div>

        {/* Current selection */}
        <div className="p-3 bg-subtle/50 border-b border-border">
          {selectedPlayer ? (
            <div className="flex items-start gap-3">
              <div className={`w-10 h-10 rounded-lg flex items-center justify-center text-body font-bold ${config.bgColor} ${config.color}`}>
                {config.shortLabel}
              </div>
              <div className="flex-1 min-w-0">
                <p className="text-body-sm font-semibold text-text-primary truncate">
                  {selectedPlayer.name}
                </p>
                <p className="text-caption text-text-secondary">
                  {selectedPlayer.team} {selectedPlayer.opponent}
                </p>
                <p className="text-tiny text-text-muted">
                  {selectedPlayer.kickoffFormatted}
                </p>
              </div>
              {!isLocked && (
                <button
                  onClick={() => setPicks(prev => ({
                    ...prev,
                    [`${pos}PlayerId`]: undefined,
                    [`${pos}GameId`]: undefined,
                  }))}
                  className="text-text-muted hover:text-text-primary p-1"
                  aria-label="Clear selection"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              )}
            </div>
          ) : (
            <div className="flex items-center gap-3 py-1">
              <div className="w-10 h-10 rounded-lg border-2 border-dashed border-border flex items-center justify-center text-text-muted">
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
              </div>
              <p className="text-body-sm text-text-muted">Select a {config.label.toLowerCase()}</p>
            </div>
          )}
        </div>

        {/* Player list */}
        <div className="flex-1 overflow-y-auto max-h-80 divide-y divide-border">
          {loading ? (
            <div className="p-3">
              <PlayerListSkeleton count={4} />
            </div>
          ) : posPlayers.length === 0 ? (
            <div className="p-6 text-center">
              <p className="text-body-sm text-text-muted">
                {searchQuery ? "No players match your search" : "No players available"}
              </p>
            </div>
          ) : (
            posPlayers.map((p) => {
              const selected = selectedId === p.id;
              const isDisabled = p.isLocked || p.isUsed || Boolean(isLocked);
              const timeUntilLock = getTimeUntilLock(p.kickoff);
              const fantasyPts = p.seasonStats?.fantasyPoints;

              return (
                <button
                  key={`${p.id}-${p.gameId}`}
                  onClick={() => handlePick(pos, p)}
                  disabled={isDisabled}
                  className={`w-full text-left px-4 py-3 transition-all duration-150 focus:outline-none focus:bg-subtle ${
                    selected
                      ? "bg-primary-soft border-l-4 border-l-primary"
                      : isDisabled
                      ? "opacity-50 cursor-not-allowed bg-surface"
                      : "hover:bg-subtle bg-surface"
                  }`}
                >
                  <div className="flex items-start gap-3">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 flex-wrap">
                        <span className="text-body-sm font-medium text-text-primary truncate">
                          {p.name}
                        </span>
                        {fantasyPts !== undefined && fantasyPts > 0 && (
                          <Badge variant="info" size="sm">
                            {fantasyPts.toFixed(1)} pts
                          </Badge>
                        )}
                        {p.isUsed && (
                          <Badge variant="warning" size="sm">USED</Badge>
                        )}
                        {p.isLocked && (
                          <Badge variant="error" size="sm">LOCKED</Badge>
                        )}
                      </div>
                      <p className="text-caption text-text-secondary mt-0.5">
                        {p.team} {p.opponent}
                      </p>
                    </div>
                    <div className="text-right shrink-0">
                      <p className={`text-caption font-medium ${
                        p.isLocked ? "text-error" : "text-text-muted"
                      }`}>
                        {timeUntilLock === "LOCKED" ? "Locked" : timeUntilLock}
                      </p>
                      <p className="text-tiny text-text-subtle">
                        {p.kickoff.toLocaleTimeString("en-US", { hour: "numeric", minute: "2-digit" })}
                      </p>
                    </div>
                  </div>
                </button>
              );
            })
          )}
        </div>
      </Card>
    );
  };

  const hasChanges = useMemo(() => {
    return JSON.stringify(picks) !== JSON.stringify(savedPicks);
  }, [picks, savedPicks]);

  // Generate week options from available weeks only
  const weekOptions = availableWeeks.map((weekNum) => ({
    value: `week-${weekNum}`,
    label: `Week ${weekNum}`,
  }));

  const sortOptions = [
    { value: "fantasyPoints", label: "Season Pts" },
    { value: "kickoff", label: "Kickoff Time" },
    { value: "name", label: "Player Name" },
  ];

  // Show message if no league selected
  if (!leagueLoading && !leagueId) {
    return (
      <div className="text-center py-12">
        <div className="inline-flex items-center justify-center w-16 h-16 bg-primary-soft rounded-full mb-4">
          <svg className="w-8 h-8 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
          </svg>
        </div>
        <h2 className="text-section-title font-bold text-text-primary mb-2">No League Selected</h2>
        <p className="text-body text-text-secondary mb-6">
          Join or create a league to start making picks.
        </p>
        <div className="flex justify-center gap-3">
          <Button variant="primary" onClick={() => window.location.href = "/create-league"}>
            Create League
          </Button>
          <Button variant="secondary" onClick={() => window.location.href = "/join"}>
            Join League
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page header */}
      <div className="flex flex-col lg:flex-row lg:items-end justify-between gap-4">
        <div>
          <h1 className="text-page-title text-text-primary">Weekly Picks</h1>
          <p className="text-body text-text-secondary mt-1">
            Select one player from each position. Picks lock 1 hour before kickoff.
          </p>
          <div className="flex flex-wrap gap-2 mt-3">
            <Badge variant="neutral" size="md">1 QB</Badge>
            <Badge variant="neutral" size="md">1 RB</Badge>
            <Badge variant="neutral" size="md">1 WR</Badge>
            <Badge variant="warning" size="md">One-and-done rule</Badge>
          </div>
        </div>

        {/* Week selector */}
        <div className="shrink-0">
          <Select
            value={weekId}
            onChange={(e) => setWeekId(e.target.value)}
            options={weekOptions}
            className="w-40"
          />
        </div>
      </div>

      {/* Alert messages */}
      {message && (
        <Alert
          type={message.type}
          message={message.text}
          onClose={() => setMessage(null)}
        />
      )}

      {/* Search, Filter, and Sort controls */}
      <div className="flex flex-col gap-3">
        <div className="flex flex-col sm:flex-row gap-3">
          <div className="flex-1">
            <Input
              type="text"
              placeholder="Search by player name or team..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              leftIcon={
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              }
              rightIcon={
                searchQuery ? (
                  <button
                    onClick={() => setSearchQuery("")}
                    className="hover:text-text-primary transition-colors"
                  >
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                ) : undefined
              }
            />
          </div>
          <div className="flex items-center gap-4 shrink-0">
            <label className="flex items-center gap-2 cursor-pointer">
              <input
                type="checkbox"
                checked={hideUnavailable}
                onChange={(e) => setHideUnavailable(e.target.checked)}
                className="w-4 h-4 rounded border-border text-primary focus:ring-primary"
              />
              <span className="text-body-sm text-text-secondary">
                Hide locked/used ({unavailableCount})
              </span>
            </label>
            <div className="flex items-center gap-2">
              <span className="text-caption text-text-muted">Sort:</span>
              <Select
                value={sortBy}
                onChange={(e) => setSortBy(e.target.value as SortOption)}
                options={sortOptions}
                className="w-32"
              />
            </div>
          </div>
        </div>

        {/* Used players summary */}
        {usedPlayerIds.size > 0 && (
          <div className="flex items-center gap-2 text-caption text-text-muted">
            <svg className="w-4 h-4 text-warning" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <span>You've used {usedPlayerIds.size} player{usedPlayerIds.size !== 1 ? 's' : ''} this season (one-and-done rule)</span>
          </div>
        )}
      </div>

      {/* Position columns */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {renderColumn("qb")}
        {renderColumn("rb")}
        {renderColumn("wr")}
      </div>

      {/* Save bar */}
      <Card className="sticky bottom-4 flex items-center justify-between gap-4">
        <div className="flex items-center gap-3">
          {hasChanges ? (
            <>
              <div className="w-2 h-2 rounded-full bg-warning animate-pulse" />
              <span className="text-body-sm text-warning-text font-medium">
                You have unsaved changes
              </span>
            </>
          ) : (
            <>
              <div className="w-2 h-2 rounded-full bg-success" />
              <span className="text-body-sm text-text-muted">
                All changes saved
              </span>
            </>
          )}
        </div>
        <Button
          onClick={savePicks}
          disabled={saving || !hasChanges}
          loading={saving}
          size="md"
        >
          {saving ? "Saving..." : "Save Picks"}
        </Button>
      </Card>
    </div>
  );
};



========================================
FILE: frontend/src/features/profile/ProfilePage.tsx
========================================

/**
 * Profile Page - Update user display name and view account info
 */

import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../auth/AuthContext";
import { updateProfile } from "firebase/auth";
import { doc, setDoc } from "firebase/firestore";
import { db } from "../../firebase";
import { Card } from "../../components";
import { LuArrowLeft, LuUser, LuMail, LuCheck, LuLoader } from "react-icons/lu";

export const ProfilePage: React.FC = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  
  const [displayName, setDisplayName] = useState(user?.displayName || "");
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null);

  useEffect(() => {
    if (user?.displayName) {
      setDisplayName(user.displayName);
    }
  }, [user?.displayName]);

  const handleSave = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user || !displayName.trim()) return;

    setSaving(true);
    setMessage(null);

    try {
      // Update Firebase Auth profile
      await updateProfile(user, { displayName: displayName.trim() });
      
      // Sync to Firestore
      await setDoc(doc(db, "users", user.uid), {
        displayName: displayName.trim(),
        email: user.email || "",
        photoURL: user.photoURL || "",
        lastUpdated: new Date(),
      }, { merge: true });

      setMessage({ type: "success", text: "Profile updated successfully!" });
    } catch (err) {
      console.error("Failed to update profile:", err);
      setMessage({ type: "error", text: "Failed to update profile. Please try again." });
    } finally {
      setSaving(false);
    }
  };

  if (!user) return null;

  return (
    <div className="max-w-md mx-auto">
      {/* Header */}
      <div className="mb-6">
        <button
          onClick={() => navigate(-1)}
          className="flex items-center gap-2 text-body-sm text-text-secondary hover:text-text-primary mb-4"
        >
          <LuArrowLeft className="w-4 h-4" />
          Back
        </button>
        <h1 className="text-page-title font-bold text-text-primary">Your Profile</h1>
      </div>

      {/* Success/Error message */}
      {message && (
        <div className={`mb-6 p-4 rounded-card text-body-sm ${
          message.type === "success" 
            ? "bg-success/10 border border-success/20 text-success" 
            : "bg-danger/10 border border-danger/20 text-danger"
        }`}>
          {message.text}
        </div>
      )}

      {/* Profile Form */}
      <Card>
        <form onSubmit={handleSave} className="space-y-4">
          <div>
            <label className="flex items-center gap-2 text-body-sm font-medium text-text-primary mb-2">
              <LuUser className="w-4 h-4" />
              Display Name
            </label>
            <input
              type="text"
              value={displayName}
              onChange={(e) => setDisplayName(e.target.value)}
              placeholder="Your name"
              className="w-full px-4 py-3 bg-surface border border-border rounded-button text-text-primary focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent"
              required
            />
          </div>

          <div>
            <label className="flex items-center gap-2 text-body-sm font-medium text-text-primary mb-2">
              <LuMail className="w-4 h-4" />
              Email
            </label>
            <input
              type="email"
              value={user.email || ""}
              disabled
              className="w-full px-4 py-3 bg-subtle border border-border rounded-button text-text-muted cursor-not-allowed"
            />
            <p className="mt-1 text-caption text-text-muted">Email cannot be changed</p>
          </div>

          <button
            type="submit"
            disabled={saving || !displayName.trim() || displayName === user.displayName}
            className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-primary text-white rounded-button font-medium hover:bg-primary-hover transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {saving ? (
              <LuLoader className="w-5 h-5 animate-spin" />
            ) : (
              <>
                <LuCheck className="w-5 h-5" />
                Save Changes
              </>
            )}
          </button>
        </form>
      </Card>
    </div>
  );
};



========================================
FILE: frontend/src/features/rules/RulesPage.tsx
========================================

import React, { useMemo } from "react";
import { Card } from "../../components";
import { PAYOUT_STRUCTURE, TOTAL_POT, ENTRY_FEE } from "../../types";
import { LuMedal } from "react-icons/lu";
import { useLeague } from "../../league/LeagueContext";

export const RulesPage: React.FC = () => {
  const { activeLeague } = useLeague();

  // Use league-specific values if available, otherwise defaults
  const entryFee = activeLeague?.entryFee ?? ENTRY_FEE;
  const totalPot = activeLeague?.payoutTotal ?? TOTAL_POT;

  // Build payout structure from league data or use defaults
  const leaguePayoutStructure = activeLeague?.payoutStructure;
  const payoutStructure = useMemo(() => {
    if (leaguePayoutStructure && leaguePayoutStructure.length > 0) {
      const structure: Record<number, number> = {};
      leaguePayoutStructure.forEach(p => {
        structure[p.rank] = p.amount;
      });
      return structure;
    }
    return PAYOUT_STRUCTURE;
  }, [leaguePayoutStructure]);

  const payingPlaces = Object.keys(payoutStructure).length;

  return (
    <div className="space-y-6 max-w-2xl mx-auto">
      {/* Header */}
      <div className="text-center">
        <h1 className="text-page-title text-text-primary">How It Works</h1>
      </div>

      {/* The Game - Core Concept */}
      <Card className="bg-gradient-to-br from-primary-soft to-emerald-50 border-primary/20">
        <h2 className="text-lg font-bold text-text-primary mb-4 text-center">🏈 The Game</h2>
        <div className="space-y-3">
          <div className="flex items-center gap-3 p-3 bg-white/50 rounded-lg">
            <span className="text-2xl">1️⃣</span>
            <p className="text-body text-text-primary"><strong>Pick 3 players</strong> each week: 1 QB, 1 RB, 1 WR</p>
          </div>
          <div className="flex items-center gap-3 p-3 bg-white/50 rounded-lg">
            <span className="text-2xl">2️⃣</span>
            <p className="text-body text-text-primary"><strong>One-and-done:</strong> Each player can only be used <strong>once per season</strong></p>
          </div>
          <div className="flex items-center gap-3 p-3 bg-white/50 rounded-lg">
            <span className="text-2xl">3️⃣</span>
            <p className="text-body text-text-primary"><strong>Picks lock</strong> 1 hour before each game's kickoff</p>
          </div>
        </div>
      </Card>

      {/* Quick Stats */}
      <div className="grid grid-cols-3 gap-3">
        <Card className="text-center py-4">
          <div className="text-caption text-text-muted uppercase">Entry</div>
          <div className="text-xl font-bold text-text-primary">${entryFee}</div>
        </Card>
        <Card className="text-center py-4">
          <div className="text-caption text-text-muted uppercase">Prize Pool</div>
          <div className="text-xl font-bold text-primary">${totalPot.toLocaleString()}</div>
        </Card>
        <Card className="text-center py-4">
          <div className="text-caption text-text-muted uppercase">Weeks</div>
          <div className="text-xl font-bold text-text-primary">18</div>
        </Card>
      </div>

      {/* Scoring - Simplified */}
      <Card>
        <h2 className="text-lg font-bold text-text-primary mb-3">📊 Scoring</h2>
        <p className="text-body text-text-secondary mb-3">DraftKings PPR format. Key points:</p>
        <div className="grid grid-cols-2 gap-2 text-body-sm">
          <div className="flex justify-between p-2 bg-subtle rounded">
            <span className="text-text-secondary">Passing TD</span>
            <span className="font-medium text-text-primary">4 pts</span>
          </div>
          <div className="flex justify-between p-2 bg-subtle rounded">
            <span className="text-text-secondary">Rush/Rec TD</span>
            <span className="font-medium text-text-primary">6 pts</span>
          </div>
          <div className="flex justify-between p-2 bg-subtle rounded">
            <span className="text-text-secondary">Reception</span>
            <span className="font-medium text-text-primary">1 pt</span>
          </div>
          <div className="flex justify-between p-2 bg-subtle rounded">
            <span className="text-text-secondary">100+ yds bonus</span>
            <span className="font-medium text-text-primary">3 pts</span>
          </div>
        </div>
      </Card>

      {/* Payouts */}
      <Card>
        <h2 className="text-lg font-bold text-text-primary mb-3">💰 Prizes</h2>
        <p className="text-body-sm text-text-secondary mb-3">Top {payingPlaces} finishers win:</p>
        <div className="grid grid-cols-3 sm:grid-cols-4 gap-2">
          {Object.entries(payoutStructure).slice(0, 7).map(([rank, amount]) => {
            const rankNum = parseInt(rank);
            const isTop3 = rankNum <= 3;
            const medalColors = ["text-yellow-500", "text-gray-400", "text-amber-600"];
            return (
              <div
                key={rank}
                className={`rounded-lg p-3 text-center border ${
                  isTop3
                    ? "bg-gradient-to-br from-primary-soft to-emerald-50 border-primary/20"
                    : "bg-subtle border-border"
                }`}
              >
                {isTop3 && <LuMedal className={`w-4 h-4 mx-auto mb-1 ${medalColors[rankNum - 1]}`} />}
                <div className="text-caption text-text-muted">#{rank}</div>
                <div className={`font-bold ${isTop3 ? "text-primary" : "text-text-primary"}`}>
                  ${amount.toLocaleString()}
                </div>
              </div>
            );
          })}
        </div>
      </Card>
    </div>
  );
};


========================================
FILE: frontend/src/features/standings/StandingsPage.tsx
========================================

import React, { useEffect, useState, useMemo, useCallback } from "react";
import { db } from "../../firebase";
import { collection, query, orderBy, getDocs, doc, getDoc } from "firebase/firestore";
import { PAYOUT_STRUCTURE, TOTAL_POT, ENTRY_FEE } from "../../types";
import { Card, CardHeader, Badge, Tabs, Select, TableSkeleton, Button } from "../../components";
import { useLeague } from "../../league/LeagueContext";

interface WeeklyScore {
  userId: string;
  displayName?: string;
  totalPoints: number;
  qbPoints: number;
  rbPoints: number;
  wrPoints: number;
  doublePickPositions?: string[];
}

interface SeasonStanding {
  userId: string;
  displayName: string;
  seasonTotalPoints: number;
  weeksPlayed: number;
  bestWeekPoints: number;
  bestWeek: string;
}

type ViewMode = "weekly" | "season";

// Medal icons for top 3
const MedalIcon: React.FC<{ rank: number }> = ({ rank }) => {
  const colors = {
    1: "from-yellow-400 to-yellow-600",
    2: "from-gray-300 to-gray-500",
    3: "from-amber-500 to-amber-700",
  };
  const color = colors[rank as keyof typeof colors];
  if (!color) return null;

  return (
    <div className={`w-7 h-7 rounded-full bg-gradient-to-br ${color} flex items-center justify-center text-white font-bold text-caption shadow-sm`}>
      {rank}
    </div>
  );
};

export const StandingsPage: React.FC = () => {
  const { activeLeagueId, activeLeague, loading: leagueLoading } = useLeague();
  const [weeklyScores, setWeeklyScores] = useState<WeeklyScore[]>([]);
  const [seasonStandings, setSeasonStandings] = useState<SeasonStanding[]>([]);
  const [weekId, setWeekId] = useState("");
  const [viewMode, setViewMode] = useState<ViewMode>("weekly");
  const [loading, setLoading] = useState(true);

  // Use activeLeagueId from context
  const leagueId = activeLeagueId;

  // Determine current week from Firestore config (synced from ESPN)
  useEffect(() => {
    async function loadCurrentWeek() {
      try {
        const configRef = doc(db, "config", "season");
        const configSnap = await getDoc(configRef);
        if (configSnap.exists()) {
          const data = configSnap.data();
          const currentWeek = data.currentWeek || 1;
          setWeekId(`week-${currentWeek}`);
        } else {
          // No config document - fallback to week 1
          setWeekId("week-1");
        }
      } catch {
        // Fallback to week 1 if config not available
        setWeekId("week-1");
      }
    }
    loadCurrentWeek();
  }, []);

  // Load weekly scores
  useEffect(() => {
    if (viewMode !== "weekly" || !weekId) return;

    async function loadWeekly() {
      if (!leagueId) return;
      setLoading(true);

      try {
        // First, fetch league members to get display names
        const membersRef = collection(db, "leagues", leagueId, "members");
        const membersSnap = await getDocs(membersRef);
        const memberNames: Record<string, string> = {};
        membersSnap.forEach((memberDoc) => {
          const data = memberDoc.data();
          memberNames[memberDoc.id] = data.displayName || memberDoc.id.slice(0, 8);
        });

        // Then fetch scores
        const scoresRef = collection(db, "leagues", leagueId, "weeks", weekId, "scores");
        const snap = await getDocs(query(scoresRef, orderBy("totalPoints", "desc")));

        const rows: WeeklyScore[] = [];

        snap.forEach((scoreDoc) => {
          const d = scoreDoc.data();
          rows.push({
            userId: scoreDoc.id,
            displayName: memberNames[scoreDoc.id] || scoreDoc.id.slice(0, 8),
            totalPoints: d.totalPoints ?? 0,
            qbPoints: d.qbPoints ?? 0,
            rbPoints: d.rbPoints ?? 0,
            wrPoints: d.wrPoints ?? 0,
            doublePickPositions: d.doublePickPositions ?? [],
          });
        });

        setWeeklyScores(rows);
      } catch {
        // Error loading weekly scores - silently fail
      } finally {
        setLoading(false);
      }
    }
    loadWeekly();
  }, [weekId, viewMode, leagueId]);

  // Load season standings
  useEffect(() => {
    if (viewMode !== "season") return;

    async function loadSeason() {
      if (!leagueId) return;
      setLoading(true);

      try {
        const standingsRef = collection(db, "leagues", leagueId, "seasonStandings");
        const snap = await getDocs(query(standingsRef, orderBy("seasonTotalPoints", "desc")));

        const rows: SeasonStanding[] = [];
        snap.forEach((doc) => {
          const d = doc.data();
          rows.push({
            userId: doc.id,
            displayName: d.displayName || doc.id.slice(0, 8),
            seasonTotalPoints: d.seasonTotalPoints ?? 0,
            weeksPlayed: d.weeksPlayed ?? 0,
            bestWeekPoints: d.bestWeekPoints ?? 0,
            bestWeek: d.bestWeek ?? "",
          });
        });

        setSeasonStandings(rows);
      } catch {
        // Error loading season standings - silently fail
      } finally {
        setLoading(false);
      }
    }
    loadSeason();
  }, [viewMode, leagueId]);

  const getPayout = useCallback((rank: number): number => {
    // Use league-specific payout structure if available, otherwise fall back to default
    if (activeLeague?.payoutStructure && activeLeague.payoutStructure.length > 0) {
      const entry = activeLeague.payoutStructure.find(p => p.rank === rank);
      return entry?.amount || 0;
    }
    return PAYOUT_STRUCTURE[rank] || 0;
  }, [activeLeague?.payoutStructure]);

  // Calculate points behind leader for season standings
  const leaderPoints = useMemo(() => {
    if (seasonStandings.length === 0) return 0;
    return seasonStandings[0].seasonTotalPoints;
  }, [seasonStandings]);

  const getPointsBehind = useCallback((points: number): string => {
    const diff = leaderPoints - points;
    if (diff === 0) return "—";
    return `-${diff.toFixed(1)}`;
  }, [leaderPoints]);

  // Week options for select - memoized since it's static
  const weekOptions = useMemo(() => Array.from({ length: 18 }, (_, i) => ({
    value: `week-${i + 1}`,
    label: `Week ${i + 1}`,
  })), []);

  // Tabs configuration - memoized since it's static
  const tabs = useMemo(() => [
    { id: "weekly", label: "Weekly Results" },
    { id: "season", label: "Season Standings" },
  ], []);

  // Show message if no league selected
  if (!leagueLoading && !leagueId) {
    return (
      <div className="text-center py-12">
        <div className="inline-flex items-center justify-center w-16 h-16 bg-primary-soft rounded-full mb-4">
          <svg className="w-8 h-8 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
          </svg>
        </div>
        <h2 className="text-section-title font-bold text-text-primary mb-2">No League Selected</h2>
        <p className="text-body text-text-secondary mb-6">
          Join or create a league to view standings.
        </p>
        <div className="flex justify-center gap-3">
          <Button variant="primary" onClick={() => window.location.href = "/create-league"}>
            Create League
          </Button>
          <Button variant="secondary" onClick={() => window.location.href = "/join"}>
            Join League
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Page header */}
      <div className="flex flex-col sm:flex-row sm:items-end justify-between gap-4">
        <div>
          <h1 className="text-page-title text-text-primary">Standings</h1>
          <p className="text-body text-text-secondary mt-1">
            Track weekly results and season-long performance
          </p>
        </div>

        {/* Controls */}
        <div className="flex items-center gap-3">
          <Tabs
            tabs={tabs}
            activeTab={viewMode}
            onChange={(id) => setViewMode(id as ViewMode)}
            variant="segmented"
            size="sm"
          />
          {viewMode === "weekly" && (
            <Select
              value={weekId}
              onChange={(e) => setWeekId(e.target.value)}
              options={weekOptions}
              className="w-32"
            />
          )}
        </div>
      </div>

      {/* Weekly Standings Table */}
      {viewMode === "weekly" && (
        <Card padding="none" className="overflow-hidden">
          {loading ? (
            <div className="p-4">
              <TableSkeleton rows={8} columns={6} />
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="bg-subtle border-b border-border">
                    <th className="px-4 py-3 text-left text-caption font-semibold text-text-muted uppercase tracking-wide w-16">Rank</th>
                    <th className="px-4 py-3 text-left text-caption font-semibold text-text-muted uppercase tracking-wide">Player</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">QB</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">RB</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">WR</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">Total</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-border">
                  {weeklyScores.map((s, idx) => (
                    <tr
                      key={s.userId}
                      className={`transition-colors hover:bg-subtle/50 ${idx < 3 ? "bg-primary-soft/30" : ""}`}
                    >
                      <td className="px-4 py-3">
                        {idx < 3 ? (
                          <MedalIcon rank={idx + 1} />
                        ) : (
                          <span className="text-body-sm text-text-muted font-medium">{idx + 1}</span>
                        )}
                      </td>
                      <td className="px-4 py-3">
                        <span className="text-body-sm font-medium text-text-primary">
                          {s.displayName}
                        </span>
                        {s.doublePickPositions && s.doublePickPositions.length > 0 && (
                          <Badge variant="error" size="sm" className="ml-2">
                            ⚠ {s.doublePickPositions.join(", ")}
                          </Badge>
                        )}
                      </td>
                      <td className="px-4 py-3 text-right text-body-sm text-text-secondary tabular-nums">
                        {s.qbPoints.toFixed(2)}
                      </td>
                      <td className="px-4 py-3 text-right text-body-sm text-text-secondary tabular-nums">
                        {s.rbPoints.toFixed(2)}
                      </td>
                      <td className="px-4 py-3 text-right text-body-sm text-text-secondary tabular-nums">
                        {s.wrPoints.toFixed(2)}
                      </td>
                      <td className="px-4 py-3 text-right">
                        <span className="text-body-sm font-semibold text-text-primary tabular-nums">
                          {s.totalPoints.toFixed(2)}
                        </span>
                      </td>
                    </tr>
                  ))}
                  {weeklyScores.length === 0 && (
                    <tr>
                      <td colSpan={6} className="px-4 py-12 text-center">
                        <div className="text-text-muted">
                          <svg className="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                          </svg>
                          <p className="text-body-sm">No scores yet for {weekId.replace("-", " ")}</p>
                        </div>
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          )}
        </Card>
      )}

      {/* Season Standings Table */}
      {viewMode === "season" && (
        <Card padding="none" className="overflow-hidden">
          {loading ? (
            <div className="p-4">
              <TableSkeleton rows={8} columns={7} />
            </div>
          ) : (
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="bg-subtle border-b border-border">
                    <th className="px-4 py-3 text-left text-caption font-semibold text-text-muted uppercase tracking-wide w-16">Rank</th>
                    <th className="px-4 py-3 text-left text-caption font-semibold text-text-muted uppercase tracking-wide">Player</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">Weeks</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">Best Week</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">Total Pts</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">Behind</th>
                    <th className="px-4 py-3 text-right text-caption font-semibold text-text-muted uppercase tracking-wide">Payout</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-border">
                  {seasonStandings.map((s, idx) => {
                    const payout = getPayout(idx + 1);
                    const pointsBehind = getPointsBehind(s.seasonTotalPoints);
                    return (
                      <tr
                        key={s.userId}
                        className={`transition-colors hover:bg-subtle/50 ${idx < 3 ? "bg-primary-soft/30" : ""}`}
                      >
                        <td className="px-4 py-3">
                          {idx < 3 ? (
                            <MedalIcon rank={idx + 1} />
                          ) : (
                            <span className="text-body-sm text-text-muted font-medium">{idx + 1}</span>
                          )}
                        </td>
                        <td className="px-4 py-3">
                          <span className="text-body-sm font-medium text-text-primary">
                            {s.displayName}
                          </span>
                        </td>
                        <td className="px-4 py-3 text-right text-body-sm text-text-secondary tabular-nums">
                          {s.weeksPlayed}
                        </td>
                        <td className="px-4 py-3 text-right">
                          <span className="text-body-sm text-text-primary font-medium tabular-nums">
                            {s.bestWeekPoints.toFixed(2)}
                          </span>
                          <span className="text-caption text-text-muted ml-1">
                            ({s.bestWeek.replace("week-", "W")})
                          </span>
                        </td>
                        <td className="px-4 py-3 text-right">
                          <span className="text-body-sm font-semibold text-text-primary tabular-nums">
                            {s.seasonTotalPoints.toFixed(2)}
                          </span>
                        </td>
                        <td className="px-4 py-3 text-right">
                          <span className={`text-body-sm tabular-nums ${idx === 0 ? "text-text-subtle" : "text-error"}`}>
                            {pointsBehind}
                          </span>
                        </td>
                        <td className="px-4 py-3 text-right">
                          {payout > 0 ? (
                            <Badge variant="success" size="md">${payout}</Badge>
                          ) : (
                            <span className="text-text-subtle">—</span>
                          )}
                        </td>
                      </tr>
                    );
                  })}
                  {seasonStandings.length === 0 && (
                    <tr>
                      <td colSpan={7} className="px-4 py-12 text-center">
                        <div className="text-text-muted">
                          <svg className="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                          </svg>
                          <p className="text-body-sm">No season standings yet</p>
                        </div>
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          )}
        </Card>
      )}

      {/* Payout Structure Card */}
      <Card>
        <CardHeader
          title="Prize Pool Distribution"
          subtitle={`$${TOTAL_POT.toLocaleString()} total pot • $${ENTRY_FEE} entry fee`}
        />
        <div className="mt-4 grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-7 gap-3">
          {Object.entries(PAYOUT_STRUCTURE).map(([rank, amount]) => {
            const rankNum = parseInt(rank);
            const ordinal = ["1st", "2nd", "3rd", "4th", "5th", "6th", "7th"][rankNum - 1];
            return (
              <div
                key={rank}
                className={`rounded-card p-3 text-center border ${
                  rankNum <= 3
                    ? "bg-primary-soft/50 border-primary/20"
                    : "bg-subtle border-border"
                }`}
              >
                <div className="text-caption text-text-muted font-medium">{ordinal}</div>
                <div className="text-section-title font-bold text-primary mt-1">
                  ${amount.toLocaleString()}
                </div>
              </div>
            );
          })}
        </div>
      </Card>
    </div>
  );
};



========================================
FILE: frontend/src/firebase.ts
========================================

import { initializeApp } from "firebase/app";
import {
  getAuth,
  GoogleAuthProvider,
  signInWithPopup,
  signOut,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  updateProfile,
} from "firebase/auth";
import {
  getFirestore,
} from "firebase/firestore";

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const provider = new GoogleAuthProvider();
export const db = getFirestore(app);

export const signInWithGoogle = () => signInWithPopup(auth, provider);
export const logout = () => signOut(auth);

export const signUpWithEmail = async (email: string, password: string, displayName: string) => {
  const credential = await createUserWithEmailAndPassword(auth, email, password);
  await updateProfile(credential.user, { displayName });
  return credential;
};

export const signInWithEmail = (email: string, password: string) =>
  signInWithEmailAndPassword(auth, email, password);



========================================
FILE: frontend/src/league/LeagueContext.tsx
========================================

/**
 * League Context - Manages active league state across the app
 *
 * Note: This file exports both a context and a provider component, which is a standard
 * React pattern. The eslint-disable is needed because React Compiler's fast refresh
 * rule prefers files to only export components, but context providers are an exception.
 */

/* eslint-disable react-refresh/only-export-components */
import React, { createContext, useContext, useState, useEffect, useCallback } from "react";
import { doc, getDoc, setDoc } from "firebase/firestore";
import { db } from "../firebase";
import { useAuth } from "../auth/AuthContext";
import { apiGet } from "../lib/api";
import { mapLeague, mapLeagueMember } from "../lib/firestore";
import type { League, LeagueSummary, MemberRole } from "../types";

export interface LeagueContextType {
  // Current active league
  activeLeague: League | null;
  activeLeagueId: string | null;
  userRole: MemberRole | null;
  
  // All user's leagues
  userLeagues: LeagueSummary[];
  
  // Loading states
  loading: boolean;
  loadingLeagues: boolean;
  
  // Actions
  setActiveLeague: (leagueId: string) => Promise<void>;
  refreshLeagues: () => Promise<void>;
  refreshActiveLeague: () => Promise<void>;
}

export const LeagueContext = createContext<LeagueContextType>({
  activeLeague: null,
  activeLeagueId: null,
  userRole: null,
  userLeagues: [],
  loading: true,
  loadingLeagues: true,
  setActiveLeague: async () => {},
  refreshLeagues: async () => {},
  refreshActiveLeague: async () => {},
});

export const useLeague = () => useContext(LeagueContext);

export const LeagueProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user } = useAuth();
  const [activeLeague, setActiveLeagueState] = useState<League | null>(null);
  const [activeLeagueId, setActiveLeagueId] = useState<string | null>(null);
  const [userRole, setUserRole] = useState<MemberRole | null>(null);
  const [userLeagues, setUserLeagues] = useState<LeagueSummary[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingLeagues, setLoadingLeagues] = useState(true);

  // Fetch user's leagues from backend
  const refreshLeagues = useCallback(async () => {
    if (!user) {
      setUserLeagues([]);
      setLoadingLeagues(false);
      return;
    }

    try {
      setLoadingLeagues(true);
      const data = await apiGet<{ leagues: LeagueSummary[] }>("/getUserLeagues", user);
      setUserLeagues(data.leagues || []);
    } catch (err) {
      console.error("Error fetching leagues:", err);
      setUserLeagues([]);
    } finally {
      setLoadingLeagues(false);
    }
  }, [user]);

  // Fetch active league details
  const refreshActiveLeague = useCallback(async () => {
    if (!user || !activeLeagueId) {
      setActiveLeagueState(null);
      setUserRole(null);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      
      // Fetch league document
      const leagueDoc = await getDoc(doc(db, "leagues", activeLeagueId));
      if (!leagueDoc.exists()) {
        console.error("Active league not found");
        setActiveLeagueState(null);
        setActiveLeagueId(null);
        setLoading(false);
        return;
      }

      const leagueData = mapLeague(leagueDoc);
      if (!leagueData) {
        console.error("Failed to parse league data");
        setActiveLeagueState(null);
        setActiveLeagueId(null);
        setLoading(false);
        return;
      }
      setActiveLeagueState(leagueData);

      // Fetch user's role in this league
      const memberDoc = await getDoc(doc(db, "leagues", activeLeagueId, "members", user.uid));
      const memberData = mapLeagueMember(memberDoc);
      if (memberData) {
        setUserRole(memberData.role);
      } else {
        setUserRole(null);
      }
    } catch (err) {
      console.error("Error fetching active league:", err);
      setActiveLeagueState(null);
    } finally {
      setLoading(false);
    }
  }, [user, activeLeagueId]);

  // Set active league and persist to user profile
  const setActiveLeague = useCallback(async (leagueId: string) => {
    if (!user) return;

    try {
      // Update local state immediately
      setActiveLeagueId(leagueId);
      
      // Persist to Firestore
      await setDoc(doc(db, "users", user.uid), {
        activeLeagueId: leagueId,
        updatedAt: new Date(),
      }, { merge: true });
    } catch (err) {
      console.error("Error setting active league:", err);
    }
  }, [user]);

  // Load user's active league from profile on mount
  useEffect(() => {
    const loadActiveLeague = async () => {
      if (!user) {
        setActiveLeagueId(null);
        setLoading(false);
        return;
      }

      try {
        const userDoc = await getDoc(doc(db, "users", user.uid));
        if (userDoc.exists() && userDoc.data().activeLeagueId) {
          setActiveLeagueId(userDoc.data().activeLeagueId);
        } else {
          setLoading(false);
        }
      } catch (err) {
        console.error("Error loading active league:", err);
        setLoading(false);
      }
    };

    loadActiveLeague();
  }, [user]);

  // Refresh leagues when user changes
  useEffect(() => {
    refreshLeagues();
  }, [refreshLeagues]);

  // Refresh active league when activeLeagueId changes
  useEffect(() => {
    refreshActiveLeague();
  }, [refreshActiveLeague]);

  // Auto-select first league if user has leagues but no active one
  useEffect(() => {
    if (!loading && !loadingLeagues && !activeLeagueId && userLeagues.length > 0) {
      setActiveLeague(userLeagues[0].id);
    }
  }, [loading, loadingLeagues, activeLeagueId, userLeagues, setActiveLeague]);

  return (
    <LeagueContext.Provider
      value={{
        activeLeague,
        activeLeagueId,
        userRole,
        userLeagues,
        loading,
        loadingLeagues,
        setActiveLeague,
        refreshLeagues,
        refreshActiveLeague,
      }}
    >
      {children}
    </LeagueContext.Provider>
  );
};



========================================
FILE: frontend/src/league/LeagueSwitcher.tsx
========================================

/**
 * League Switcher - Dropdown to switch between leagues
 */

import React, { useState, useRef, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import { useLeague } from "./LeagueContext";
import { LuChevronDown, LuPlus, LuUsers, LuCheck, LuSettings } from "react-icons/lu";

export const LeagueSwitcher: React.FC = () => {
  const navigate = useNavigate();
  const { activeLeague, userLeagues, loading, loadingLeagues, setActiveLeague, userRole } = useLeague();
  const [open, setOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  // Close on click outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  if (loading || loadingLeagues) {
    return (
      <div className="flex items-center gap-2 px-3 py-2 bg-subtle rounded-button animate-pulse">
        <div className="w-4 h-4 bg-border rounded" />
        <div className="w-24 h-4 bg-border rounded" />
      </div>
    );
  }

  // No leagues - show create/join prompt
  if (userLeagues.length === 0) {
    return (
      <div className="flex items-center gap-2">
        <button
          onClick={() => navigate("/create-league")}
          className="flex items-center gap-2 px-3 py-2 bg-primary text-white rounded-button text-body-sm font-medium hover:bg-primary-hover transition-colors"
        >
          <LuPlus className="w-4 h-4" />
          Create League
        </button>
        <button
          onClick={() => navigate("/join")}
          className="flex items-center gap-2 px-3 py-2 bg-subtle text-text-secondary rounded-button text-body-sm font-medium hover:bg-border transition-colors"
        >
          <LuUsers className="w-4 h-4" />
          Join
        </button>
      </div>
    );
  }

  return (
    <div ref={menuRef} className="relative">
      <button
        onClick={() => setOpen(!open)}
        className="flex items-center gap-2 px-3 py-2 bg-subtle hover:bg-border rounded-button transition-colors focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2"
        aria-label="Switch league"
        aria-expanded={open}
      >
        <LuUsers className="w-4 h-4 text-primary" />
        <span className="text-body-sm font-medium text-text-primary max-w-[150px] truncate">
          {activeLeague?.name || "Select League"}
        </span>
        <LuChevronDown className={`w-4 h-4 text-text-muted transition-transform ${open ? "rotate-180" : ""}`} />
      </button>

      {open && (
        <div className="absolute left-0 top-full mt-2 w-72 bg-surface rounded-card shadow-dropdown border border-border animate-fade-in z-50">
          {/* League list */}
          <div className="max-h-64 overflow-y-auto">
            {userLeagues.map((league) => (
              <button
                key={league.id}
                onClick={() => {
                  setActiveLeague(league.id);
                  setOpen(false);
                }}
                className={`w-full flex items-center gap-3 px-4 py-3 hover:bg-subtle transition-colors text-left ${
                  league.id === activeLeague?.id ? "bg-primary-soft" : ""
                }`}
              >
                <div className="flex-1 min-w-0">
                  <p className="text-body-sm font-medium text-text-primary truncate">
                    {league.name}
                  </p>
                  <p className="text-caption text-text-muted">
                    {league.memberCount} members • {league.season}
                  </p>
                </div>
                {league.id === activeLeague?.id && (
                  <LuCheck className="w-4 h-4 text-primary flex-shrink-0" />
                )}
              </button>
            ))}
          </div>

          {/* Actions */}
          <div className="border-t border-border p-2">
            {userRole === "owner" && activeLeague && (
              <button
                onClick={() => {
                  navigate("/league-settings");
                  setOpen(false);
                }}
                className="w-full flex items-center gap-2 px-3 py-2 text-body-sm text-text-secondary hover:text-text-primary hover:bg-subtle rounded-button transition-colors"
              >
                <LuSettings className="w-4 h-4" />
                League Settings
              </button>
            )}
            <button
              onClick={() => {
                navigate("/create-league");
                setOpen(false);
              }}
              className="w-full flex items-center gap-2 px-3 py-2 text-body-sm text-text-secondary hover:text-text-primary hover:bg-subtle rounded-button transition-colors"
            >
              <LuPlus className="w-4 h-4" />
              Create New League
            </button>
            <button
              onClick={() => {
                navigate("/join");
                setOpen(false);
              }}
              className="w-full flex items-center gap-2 px-3 py-2 text-body-sm text-text-secondary hover:text-text-primary hover:bg-subtle rounded-button transition-colors"
            >
              <LuUsers className="w-4 h-4" />
              Join a League
            </button>
          </div>
        </div>
      )}
    </div>
  );
};



========================================
FILE: frontend/src/lib/api.ts
========================================

/**
 * API Utilities
 *
 * Centralized API configuration and typed helper functions for making
 * authenticated requests to Cloud Functions.
 *
 * This module provides:
 * - Generic typed API request functions
 * - Specific typed API functions for each Cloud Function endpoint
 * - Error handling and standardized error messages
 */

import type { User } from "firebase/auth";
import type {
  CreateLeagueRequest,
  CreateLeagueResponse,
  JoinLeagueRequest,
  JoinLeagueResponse,
  LeagueSummary,
  SubmitPicksRequest,
  BackfillWeekRequest,
  BackfillWeekResponse,
  BackfillStatusResponse,
  BackfillMemberResult,
  PayoutEntry,
  League,
  LeagueMember,
  PublicLeagueSummary,
} from "../types";

// ===== Configuration =====

/**
 * Base URL for Cloud Functions API
 * Uses Firebase Functions v2 URL pattern: https://{function}-{project-hash}.a.run.app
 * We use environment variable if set, otherwise construct from project ID
 */
const PROJECT_HASH = "hvgfn7iouq"; // Firebase assigns this hash to the project

// For v2 functions, each function has its own URL
function getFunctionUrl(functionName: string): string {
  if (import.meta.env.VITE_FUNCTIONS_URL) {
    // If explicitly set, use as base (for local emulator)
    return `${import.meta.env.VITE_FUNCTIONS_URL}/${functionName}`;
  }
  // Firebase Functions v2 URL pattern
  return `https://${functionName.toLowerCase()}-${PROJECT_HASH}-uc.a.run.app`;
}

// Legacy API_BASE for backwards compatibility (not used with v2 functions)
export const API_BASE = import.meta.env.VITE_FUNCTIONS_URL || "";

// ===== Error Handling =====

/**
 * Standard API error class with status code
 */
export class ApiError extends Error {
  status: number;
  code?: string;

  constructor(message: string, status: number, code?: string) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.code = code;
  }
}

/**
 * Extract user-friendly error message from various error types
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof ApiError) {
    return error.message;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return "An unexpected error occurred";
}

// ===== Generic Request Functions =====

/**
 * Options for API requests
 */
interface ApiRequestOptions {
  method?: "GET" | "POST" | "PUT" | "DELETE";
  body?: unknown;
  user?: User | null;
}

/**
 * Make an authenticated API request
 *
 * @param endpoint - The API endpoint (e.g., "/createLeague" or "createLeague")
 * @param options - Request options including method, body, and user for auth
 * @returns The parsed JSON response
 * @throws ApiError if the request fails
 */
export async function apiRequest<T>(
  endpoint: string,
  options: ApiRequestOptions = {}
): Promise<T> {
  const { method = "GET", body, user } = options;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
  };

  // Add auth token if user is provided
  if (user) {
    const token = await user.getIdToken();
    headers.Authorization = `Bearer ${token}`;
  }

  // Extract function name from endpoint (remove leading slash if present)
  const functionName = endpoint.startsWith("/") ? endpoint.slice(1).split("?")[0] : endpoint.split("?")[0];
  const queryString = endpoint.includes("?") ? endpoint.slice(endpoint.indexOf("?")) : "";
  const url = getFunctionUrl(functionName) + queryString;

  const response = await fetch(url, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });

  // Parse response body
  let data: unknown;
  const contentType = response.headers.get("content-type");
  if (contentType?.includes("application/json")) {
    data = await response.json();
  } else {
    data = await response.text();
  }

  // Handle error responses
  if (!response.ok) {
    const errorMessage =
      typeof data === "object" && data !== null && "error" in data
        ? String((data as { error: unknown }).error)
        : typeof data === "string"
          ? data
          : `Request failed with status ${response.status}`;

    throw new ApiError(errorMessage, response.status);
  }

  return data as T;
}

/**
 * Helper for GET requests
 */
export async function apiGet<T>(endpoint: string, user?: User | null): Promise<T> {
  return apiRequest<T>(endpoint, { method: "GET", user });
}

/**
 * Helper for POST requests
 */
export async function apiPost<T>(
  endpoint: string,
  body: unknown,
  user?: User | null
): Promise<T> {
  return apiRequest<T>(endpoint, { method: "POST", body, user });
}


// ===== Typed API Functions =====

// ----- League Management -----

/**
 * Create a new league
 */
export async function createLeague(
  user: User,
  data: CreateLeagueRequest
): Promise<CreateLeagueResponse> {
  return apiPost<CreateLeagueResponse>("createLeague", data, user);
}

/**
 * Join a league using a join code
 */
export async function joinLeague(
  user: User,
  data: JoinLeagueRequest
): Promise<JoinLeagueResponse> {
  return apiPost<JoinLeagueResponse>("joinLeague", data, user);
}

/**
 * Get all leagues the user is a member of
 */
export interface GetUserLeaguesResponse {
  ok: boolean;
  leagues: LeagueSummary[];
}

export async function getUserLeagues(user: User): Promise<GetUserLeaguesResponse> {
  return apiGet<GetUserLeaguesResponse>("getUserLeagues", user);
}

/**
 * Get details for a specific league
 */
export interface GetLeagueDetailsResponse {
  ok: boolean;
  league: League & { id: string };
  members: LeagueMember[];
  isOwner: boolean;
}

export async function getLeagueDetails(
  user: User,
  leagueId: string
): Promise<GetLeagueDetailsResponse> {
  return apiGet<GetLeagueDetailsResponse>(`getLeagueDetails?leagueId=${leagueId}`, user);
}

/**
 * Update league settings
 */
export interface UpdateLeagueSettingsRequest {
  leagueId: string;
  name?: string;
  entryFee?: number;
  payoutStructure?: PayoutEntry[];
  maxPlayers?: number;
  membershipLocked?: boolean;
}

export interface UpdateLeagueSettingsResponse {
  ok: boolean;
  error?: string;
}

export async function updateLeagueSettings(
  user: User,
  data: UpdateLeagueSettingsRequest
): Promise<UpdateLeagueSettingsResponse> {
  return apiPost<UpdateLeagueSettingsResponse>("updateLeagueSettings", data, user);
}

/**
 * Regenerate the league join code
 */
export interface RegenerateJoinCodeResponse {
  ok: boolean;
  joinCode: string;
  joinLink: string;
  error?: string;
}

export async function regenerateJoinCode(
  user: User,
  leagueId: string
): Promise<RegenerateJoinCodeResponse> {
  return apiPost<RegenerateJoinCodeResponse>("regenerateJoinCode", { leagueId }, user);
}

/**
 * Leave a league or remove a member (owner only for others)
 */
export interface LeaveOrRemoveMemberRequest {
  leagueId: string;
  targetUserId: string;
}

export interface LeaveOrRemoveMemberResponse {
  ok: boolean;
  error?: string;
}

export async function leaveOrRemoveMember(
  user: User,
  data: LeaveOrRemoveMemberRequest
): Promise<LeaveOrRemoveMemberResponse> {
  return apiPost<LeaveOrRemoveMemberResponse>("leaveOrRemoveMember", data, user);
}

/**
 * Set the user's active league
 */
export interface SetActiveLeagueResponse {
  ok: boolean;
  error?: string;
}

export async function setActiveLeague(
  user: User,
  leagueId: string
): Promise<SetActiveLeagueResponse> {
  return apiPost<SetActiveLeagueResponse>("setActiveLeague", { leagueId }, user);
}

// ----- Picks -----

/**
 * Submit picks for a week
 */
export interface SubmitPicksResponse {
  ok: boolean;
  accepted: string[];
  skipped: string[];
  error?: string;
}

export async function submitPicks(
  user: User,
  data: Omit<SubmitPicksRequest, "userId"> & { userId?: string }
): Promise<SubmitPicksResponse> {
  // Add userId from auth
  const requestData = {
    ...data,
    userId: user.uid,
  };
  return apiPost<SubmitPicksResponse>("submitPicks", requestData, user);
}

// ----- Available Leagues -----

/**
 * Get available public leagues that the user can join
 */
export interface GetAvailableLeaguesResponse {
  leagues: PublicLeagueSummary[];
}

export async function getAvailableLeagues(
  user: User
): Promise<GetAvailableLeaguesResponse> {
  return apiPost<GetAvailableLeaguesResponse>("getAvailableLeagues", {}, user);
}

// ----- Backfill -----

/**
 * Enable backfill mode for a league
 */
export interface EnableBackfillRequest {
  leagueId: string;
  fromWeek: number;
  toWeek: number;
}

export interface EnableBackfillResponse {
  ok: boolean;
  error?: string;
}

export async function enableBackfill(
  user: User,
  data: EnableBackfillRequest
): Promise<EnableBackfillResponse> {
  return apiPost<EnableBackfillResponse>("enableBackfill", data, user);
}

/**
 * Get backfill status for a league
 */
export async function getBackfillStatus(
  user: User,
  leagueId: string
): Promise<BackfillStatusResponse> {
  return apiGet<BackfillStatusResponse>(`getBackfillStatus?leagueId=${leagueId}`, user);
}

/**
 * Backfill a single week for a league
 */
export async function backfillWeekForLeague(
  user: User,
  data: BackfillWeekRequest
): Promise<BackfillWeekResponse> {
  return apiPost<BackfillWeekResponse>("backfillWeekForLeague", data, user);
}

/**
 * Get scores for a backfilled week
 */
export interface GetBackfillWeekScoresResponse {
  ok: boolean;
  weekNumber: number;
  weekId: string;
  scores: BackfillMemberResult[];
  error?: string;
}

export async function getBackfillWeekScores(
  user: User,
  leagueId: string,
  weekNumber: number
): Promise<GetBackfillWeekScoresResponse> {
  return apiGet<GetBackfillWeekScoresResponse>(
    `getBackfillWeekScores?leagueId=${leagueId}&weekNumber=${weekNumber}`,
    user
  );
}

/**
 * Complete backfill and mark league as ready
 */
export interface CompleteBackfillResponse {
  ok: boolean;
  error?: string;
}

export async function completeBackfill(
  user: User,
  leagueId: string
): Promise<CompleteBackfillResponse> {
  return apiPost<CompleteBackfillResponse>("completeBackfill", { leagueId }, user);
}

// ----- Scoring -----

/**
 * Score a week's picks for a league
 */
export interface ScoreWeekResponse {
  ok: boolean;
  scored: number;
  error?: string;
}

export async function scoreWeek(
  user: User,
  leagueId: string,
  weekId: string
): Promise<ScoreWeekResponse> {
  return apiPost<ScoreWeekResponse>("scoreWeek", { leagueId, weekId }, user);
}

/**
 * Compute season standings for a league
 */
export interface ComputeSeasonStandingsResponse {
  ok: boolean;
  users: number;
  error?: string;
}

export async function computeSeasonStandings(
  user: User,
  leagueId: string
): Promise<ComputeSeasonStandingsResponse> {
  return apiPost<ComputeSeasonStandingsResponse>("computeSeasonStandings", { leagueId }, user);
}

/**
 * Initialize a league with weeks
 */
export interface InitializeLeagueResponse {
  ok: boolean;
  leagueId: string;
  error?: string;
}

export async function initializeLeague(
  user: User,
  leagueId: string
): Promise<InitializeLeagueResponse> {
  return apiPost<InitializeLeagueResponse>("initializeLeague", { leagueId }, user);
}

// ----- Sync Operations -----

/**
 * Sync NFL schedule into Firestore (admin operation)
 */
export interface SyncScheduleResponse {
  ok: boolean;
  count: number;
  currentWeek: number;
  error?: string;
}

export async function syncSchedule(user: User): Promise<SyncScheduleResponse> {
  return apiGet<SyncScheduleResponse>("syncSchedule", user);
}

/**
 * Sync NFL players into Firestore (admin operation)
 */
export interface SyncPlayersResponse {
  ok: boolean;
  count: number;
  error?: string;
}

export async function syncPlayers(user: User): Promise<SyncPlayersResponse> {
  return apiGet<SyncPlayersResponse>("syncPlayers", user);
}

/**
 * Sync player stats (admin operation)
 */
export interface SyncPlayerStatsResponse {
  ok: boolean;
  updated: number;
  failed: number;
  total: number;
  error?: string;
}

export async function syncPlayerStats(user: User): Promise<SyncPlayerStatsResponse> {
  return apiGet<SyncPlayerStatsResponse>("syncPlayerStats", user);
}


========================================
FILE: frontend/src/lib/config.ts
========================================

/**
 * Application Configuration
 *
 * Centralized configuration values for the application.
 * These can be overridden via environment variables or Firestore config.
 *
 * NOTE: Season configuration should match functions/src/config.ts
 */

// ============================================================================
// Season Configuration (must match backend)
// ============================================================================

/** Current NFL season year */
export const SEASON = import.meta.env.VITE_SEASON || "2025";

/** @deprecated Use SEASON instead */
export const CURRENT_SEASON = SEASON;

/** Season start date - games before this are preseason */
export const SEASON_START = new Date(
  import.meta.env.VITE_SEASON_START || "2025-09-01T00:00:00Z"
);

/** Number of weeks in the NFL regular season */
export const REGULAR_SEASON_WEEKS = 18;

/** Positions allowed for picks */
export const PICK_POSITIONS = ["QB", "RB", "WR"] as const;
export type PickPosition = (typeof PICK_POSITIONS)[number];

/**
 * Default entry fee for leagues
 */
export const DEFAULT_ENTRY_FEE = 100;

/**
 * Default payout structure for leagues
 */
export const DEFAULT_PAYOUT_STRUCTURE = [
  { place: 1, amount: 1000 },
  { place: 2, amount: 500 },
  { place: 3, amount: 300 },
];

/**
 * Maximum number of players in a league
 */
export const DEFAULT_MAX_PLAYERS = 20;

/**
 * Firebase project configuration
 */
export const FIREBASE_PROJECT_ID = "three-man-league";

/**
 * Check if we're in development mode
 */
export const IS_DEV = import.meta.env.DEV;

/**
 * Check if we're using Firebase emulators
 */
export const USE_EMULATORS = import.meta.env.VITE_USE_EMULATORS === "true";



========================================
FILE: frontend/src/lib/firestore.ts
========================================

/**
 * Firestore Utilities
 *
 * Type-safe helpers for converting Firestore documents to typed objects.
 * Handles Timestamp conversion and provides consistent data mapping.
 */

import { Timestamp, type DocumentData, type DocumentSnapshot, type QueryDocumentSnapshot } from "firebase/firestore";
import type { Player, Game, League, LeagueMember, UserPicks, UserScore, SeasonStanding, PlayerUsage } from "../types";

// ===== Timestamp Conversion =====

/**
 * Convert a Firestore Timestamp or Timestamp-like object to a Date
 */
export function toDate(value: unknown): Date | undefined {
  if (!value) return undefined;
  
  if (value instanceof Timestamp) {
    return value.toDate();
  }
  
  if (value instanceof Date) {
    return value;
  }
  
  // Handle Timestamp-like object with seconds/nanoseconds
  if (typeof value === "object" && value !== null && "seconds" in value) {
    const ts = value as { seconds: number; nanoseconds?: number };
    return new Date(ts.seconds * 1000);
  }
  
  // Handle ISO string
  if (typeof value === "string") {
    const date = new Date(value);
    return isNaN(date.getTime()) ? undefined : date;
  }
  
  return undefined;
}

/**
 * Convert a Date to a Firestore Timestamp
 */
export function toTimestamp(date: Date): Timestamp {
  return Timestamp.fromDate(date);
}

// ===== Document Mappers =====

/**
 * Map a Firestore document to a Player object
 */
export function mapPlayer(doc: DocumentSnapshot | QueryDocumentSnapshot): Player | null {
  const data = doc.data();
  if (!data) return null;
  
  return {
    id: doc.id,
    name: data.name,
    position: data.position,
    teamId: data.teamId,
    teamName: data.teamName,
    externalId: data.externalId,
    eligiblePositions: data.eligiblePositions || [],
    seasonStats: data.seasonStats,
    statsUpdatedAt: toDate(data.statsUpdatedAt),
  };
}

/**
 * Map a Firestore document to a Game object
 */
export function mapGame(doc: DocumentSnapshot | QueryDocumentSnapshot): Game | null {
  const data = doc.data();
  if (!data) return null;
  
  return {
    id: doc.id,
    gameId: data.gameId,
    externalEventId: data.externalEventId,
    homeTeamId: data.homeTeamId,
    awayTeamId: data.awayTeamId,
    homeTeamName: data.homeTeamName,
    awayTeamName: data.awayTeamName,
    weekNumber: data.weekNumber,
    kickoffTime: toDate(data.kickoffTime) || new Date(),
    status: data.status,
  };
}

/**
 * Map a Firestore document to a League object
 */
export function mapLeague(doc: DocumentSnapshot | QueryDocumentSnapshot): League | null {
  const data = doc.data();
  if (!data) return null;

  return {
    id: doc.id,
    name: data.name,
    ownerId: data.ownerId,
    season: data.season,
    entryFee: data.entryFee,
    payouts: data.payouts || {},
    payoutStructure: data.payoutStructure,
    payoutTotal: data.payoutTotal,
    maxPlayers: data.maxPlayers,
    joinCode: data.joinCode,
    joinLink: data.joinLink,
    joinCodeExpiresAt: toDate(data.joinCodeExpiresAt),
    status: data.status,
    membershipLocked: data.membershipLocked,
    isPublic: data.isPublic ?? true, // Default to true for backwards compatibility
    passcode: data.passcode,
    createdAt: toDate(data.createdAt) || new Date(),
    updatedAt: toDate(data.updatedAt),
  };
}

/**
 * Map a Firestore document to a LeagueMember object
 */
export function mapLeagueMember(doc: DocumentSnapshot | QueryDocumentSnapshot): LeagueMember | null {
  const data = doc.data();
  if (!data) return null;
  
  return {
    userId: doc.id,
    displayName: data.displayName,
    email: data.email,
    role: data.role,
    joinedAt: toDate(data.joinedAt) || new Date(),
    invitedBy: data.invitedBy,
    isActive: data.isActive ?? true,
  };
}

/**
 * Map a Firestore document to a UserPicks object
 */
export function mapUserPicks(doc: DocumentSnapshot | QueryDocumentSnapshot): UserPicks | null {
  const data = doc.data();
  if (!data) return null;
  
  return {
    qbPlayerId: data.qbPlayerId,
    qbGameId: data.qbGameId,
    qbLocked: data.qbLocked ?? false,
    rbPlayerId: data.rbPlayerId,
    rbGameId: data.rbGameId,
    rbLocked: data.rbLocked ?? false,
    wrPlayerId: data.wrPlayerId,
    wrGameId: data.wrGameId,
    wrLocked: data.wrLocked ?? false,
    createdAt: toDate(data.createdAt) || new Date(),
    updatedAt: toDate(data.updatedAt) || new Date(),
  };
}

/**
 * Map a Firestore document to a UserScore object
 */
export function mapUserScore(data: DocumentData): UserScore {
  return {
    qbPoints: data.qbPoints ?? 0,
    rbPoints: data.rbPoints ?? 0,
    wrPoints: data.wrPoints ?? 0,
    totalPoints: data.totalPoints ?? 0,
    doublePickPositions: data.doublePickPositions ?? [],
    updatedAt: toDate(data.updatedAt) || new Date(),
  };
}

/**
 * Map a Firestore document to a SeasonStanding object
 */
export function mapSeasonStanding(doc: DocumentSnapshot | QueryDocumentSnapshot): SeasonStanding | null {
  const data = doc.data();
  if (!data) return null;

  return {
    userId: doc.id,
    displayName: data.displayName || doc.id.slice(0, 8),
    seasonTotalPoints: data.seasonTotalPoints ?? 0,
    weeksPlayed: data.weeksPlayed ?? 0,
    bestWeekPoints: data.bestWeekPoints ?? 0,
    bestWeek: data.bestWeek ?? "",
    updatedAt: toDate(data.updatedAt) || new Date(),
  };
}

/**
 * Map a Firestore document to a PlayerUsage object
 */
export function mapPlayerUsage(doc: DocumentSnapshot | QueryDocumentSnapshot): PlayerUsage | null {
  const data = doc.data();
  if (!data) return null;

  return {
    season: data.season,
    playerId: data.playerId,
    firstUsedWeek: data.firstUsedWeek,
    leagueId: data.leagueId,
  };
}

// ===== Collection Helpers =====

/**
 * Map all documents in a query snapshot to typed objects
 */
export function mapDocs<T>(
  docs: QueryDocumentSnapshot[],
  mapper: (doc: QueryDocumentSnapshot) => T | null
): T[] {
  return docs.map(mapper).filter((item): item is T => item !== null);
}



========================================
FILE: frontend/src/main.tsx
========================================

import React, { Suspense, lazy } from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import { AppShell } from "./ui/AppShell";
import { AuthGate } from "./auth/AuthGate";
import { LeagueProvider } from "./league/LeagueContext";
import { PageLoader, ErrorBoundary } from "./components";

// Lazy load route components for code splitting
const WeeklyPicksPage = lazy(() => import("./features/picks/WeeklyPicksPage").then(m => ({ default: m.WeeklyPicksPage })));
const StandingsPage = lazy(() => import("./features/standings/StandingsPage").then(m => ({ default: m.StandingsPage })));
const RulesPage = lazy(() => import("./features/rules/RulesPage").then(m => ({ default: m.RulesPage })));
const CreateLeaguePage = lazy(() => import("./features/league/CreateLeaguePage").then(m => ({ default: m.CreateLeaguePage })));
const LeaguesPage = lazy(() => import("./features/league/JoinLeaguePage").then(m => ({ default: m.JoinLeaguePage })));
const LeagueSettingsPage = lazy(() => import("./features/league/LeagueSettingsPage").then(m => ({ default: m.LeagueSettingsPage })));
const ProfilePage = lazy(() => import("./features/profile/ProfilePage").then(m => ({ default: m.ProfilePage })));
const BackfillPage = lazy(() => import("./features/admin/BackfillPage").then(m => ({ default: m.BackfillPage })));

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <ErrorBoundary>
      <BrowserRouter>
        <AuthGate>
          <LeagueProvider>
            <AppShell>
              <Suspense fallback={<PageLoader />}>
                <Routes>
                  <Route path="/" element={<Navigate to="/picks" replace />} />
                  <Route path="/picks" element={<WeeklyPicksPage />} />
                  <Route path="/standings" element={<StandingsPage />} />
                  <Route path="/rules" element={<RulesPage />} />
                  <Route path="/create-league" element={<CreateLeaguePage />} />
                  <Route path="/leagues" element={<LeaguesPage />} />
                  <Route path="/join" element={<Navigate to="/leagues" replace />} />
                  <Route path="/league-settings" element={<LeagueSettingsPage />} />
                  <Route path="/profile" element={<ProfilePage />} />
                  <Route path="/admin/backfill" element={<BackfillPage />} />
                </Routes>
              </Suspense>
            </AppShell>
          </LeagueProvider>
        </AuthGate>
      </BrowserRouter>
    </ErrorBoundary>
  </React.StrictMode>
);


========================================
FILE: frontend/src/test/setup.ts
========================================

import '@testing-library/jest-dom'



========================================
FILE: frontend/src/types.ts
========================================

/**
 * Firestore schema types for three-man-league frontend
 *
 * DATA MODEL OVERVIEW:
 *
 * /users/{userId}                    - User profile (displayName, email, photoURL, activeLeagueId)
 * /users/{userId}/playerUsage/{id}   - Player usage tracking (season, playerId, firstUsedWeek, leagueId)
 *
 * /leagues/{leagueId}                - League configuration and settings
 * /leagues/{leagueId}/members/{uid}  - League membership (role, joinedAt, invitedBy)
 * /leagues/{leagueId}/weeks/{weekId} - Week status
 * /leagues/{leagueId}/weeks/{weekId}/picks/{userId}  - User picks for week
 * /leagues/{leagueId}/weeks/{weekId}/scores/{userId} - User scores for week
 * /leagues/{leagueId}/seasonStandings/{userId}       - Season standings
 *
 * /players/{playerId}                - NFL player data
 * /games/{gameId}                    - NFL game schedule
 * /config/season                     - Global season config
 */

import type { Timestamp } from "firebase/firestore";

// ===== Users =====
export interface User {
  displayName: string;
  email: string;
  photoURL?: string;
  activeLeagueId?: string; // Currently selected league
  createdAt?: Date | Timestamp;
  updatedAt?: Date | Timestamp;
}

export interface PlayerUsage {
  season: string;
  playerId: string;
  firstUsedWeek: string;
  leagueId: string; // Player usage is now scoped per league
}

// ===== Leagues =====
export type LeagueStatus = "preseason" | "active" | "completed" | "archived";
export type MemberRole = "owner" | "coOwner" | "member";

export interface PayoutEntry {
  rank: number;
  amount: number;
}

export interface League {
  id?: string; // Added client-side from doc.id
  name: string;
  ownerId: string;
  season: string;
  entryFee: number;
  payouts: Record<string, number>; // Legacy format: rank -> amount e.g. {"1": 1200}
  payoutStructure?: PayoutEntry[]; // New format: ordered array [{rank: 1, amount: 1200}, ...]
  payoutTotal?: number; // Computed total of all payouts
  maxPlayers?: number; // Optional limit on league size
  joinCode: string; // Short unique code for joining (e.g., "ABC123")
  joinLink?: string; // Full URL with join code
  joinCodeExpiresAt?: Date | Timestamp; // Optional expiration
  status: LeagueStatus;
  membershipLocked?: boolean; // Prevent new members after season starts
  isPublic: boolean; // Public leagues are visible to all users, private require passcode
  passcode?: string; // Required passcode for joining private leagues
  createdAt: Date | Timestamp;
  updatedAt?: Date | Timestamp;
}

export interface LeagueMember {
  userId: string;
  displayName: string;
  email: string;
  role: MemberRole;
  joinedAt: Date | Timestamp;
  invitedBy?: string; // userId who invited this member
  isActive: boolean; // For soft-delete / leaving league
}

// ===== League API Types =====
export interface CreateLeagueRequest {
  name: string;
  entryFee?: number;
  maxPlayers?: number;
  payoutStructure?: PayoutEntry[];
  season?: string;
}

export interface CreateLeagueResponse {
  ok: boolean;
  leagueId: string;
  joinCode: string;
  joinLink: string;
  error?: string;
}

export interface JoinLeagueRequest {
  joinCode?: string; // Required for private leagues or direct join
  leagueId?: string; // Optional for explicit join by ID
  passcode?: string; // Required for private leagues
}

export interface JoinLeagueResponse {
  ok: boolean;
  leagueId: string;
  leagueName: string;
  error?: string;
}

export interface LeagueSummary {
  id: string;
  name: string;
  season: string;
  memberCount: number;
  role: MemberRole;
  status: LeagueStatus;
  entryFee: number;
  isPublic: boolean;
}

// For listing available public leagues (user not a member)
export interface PublicLeagueSummary {
  id: string;
  name: string;
  season: string;
  memberCount: number;
  maxPlayers?: number;
  status: LeagueStatus;
  entryFee: number;
  isPublic: boolean;
}

// ===== Weeks =====
export type WeekStatus = "pending" | "scoring" | "final";

export interface Week {
  weekNumber: number;
  startDate: Date | Timestamp;
  endDate: Date | Timestamp;
  status: WeekStatus;
}

// ===== Picks =====
export interface UserPicks {
  qbPlayerId?: string;
  qbGameId?: string;
  qbLocked: boolean;
  rbPlayerId?: string;
  rbGameId?: string;
  rbLocked: boolean;
  wrPlayerId?: string;
  wrGameId?: string;
  wrLocked: boolean;
  createdAt: Date | Timestamp;
  updatedAt: Date | Timestamp;
}

// ===== Scores =====
export interface UserScore {
  qbPoints: number;
  rbPoints: number;
  wrPoints: number;
  totalPoints: number;
  doublePickPositions: string[];
  updatedAt: Date | Timestamp;
}

// ===== Season Standings =====
export interface SeasonStanding {
  userId: string;
  displayName: string;
  seasonTotalPoints: number;
  weeksPlayed: number;
  bestWeekPoints: number;
  bestWeek: string;
  updatedAt: Date | Timestamp;
}

// ===== Players =====
export type Position = "QB" | "RB" | "WR" | "TE";
export type EligiblePosition = "QB" | "RB" | "WR";

export interface SeasonStats {
  passingYards: number;
  passingTD: number;
  interceptions: number;
  rushingYards: number;
  rushingTD: number;
  receivingYards: number;
  receivingTD: number;
  receptions: number;
  fumblesLost: number;
  gamesPlayed: number;
  fantasyPoints: number; // Calculated DraftKings PPR points
}

export interface Player {
  id?: string; // Firestore doc id (added client-side from doc.id)
  name: string;
  position: Position;
  teamId: string;
  teamName?: string;
  externalId: string;
  eligiblePositions: EligiblePosition[];
  seasonStats?: SeasonStats;
  statsUpdatedAt?: Date | Timestamp;
}

// ===== Games =====
export interface Game {
  id?: string; // Firestore doc id (added client-side from doc.id)
  gameId: string;
  externalEventId: string;
  homeTeamId: string;
  awayTeamId: string;
  homeTeamName?: string;
  awayTeamName?: string;
  weekNumber: number;
  kickoffTime: Date | Timestamp;
  status?: "scheduled" | "in_progress" | "final";
}

// ===== Scoring =====
export interface PlayerGameStats {
  passingYards: number;
  passingTD: number;
  interceptions: number;
  rushingYards: number;
  rushingTD: number;
  receivingYards: number;
  receivingTD: number;
  receptions: number;
  fumblesLost: number;
  twoPtConversions: number;
  offensiveFumbleRecoveryTD: number;
}

// ===== API Request/Response Types =====
export interface SubmitPicksRequest {
  leagueId: string;
  weekId: string;
  picks: {
    qbPlayerId?: string;
    qbGameId?: string;
    rbPlayerId?: string;
    rbGameId?: string;
    wrPlayerId?: string;
    wrGameId?: string;
  };
}

// ===== Player with game info for picks UI =====
export interface PlayerOption {
  id: string;
  name: string;
  team: string;
  position: Position;
  gameId: string;
  gameLabel: string;
  kickoff: Date;
  kickoffFormatted: string;
  isLocked: boolean;
  isUsed: boolean;
  opponent: string;
  seasonStats?: SeasonStats;
}

// ===== Payout Structure =====
export const PAYOUT_STRUCTURE: Record<number, number> = {
  1: 1200,
  2: 750,
  3: 500,
  4: 415,
  5: 270,
  6: 195,
  7: 120,
};

export const TOTAL_POT = 3450;
export const ENTRY_FEE = 50;

// ===== Backfill Types =====
export type BackfillStatus = "not_started" | "in_progress" | "completed" | "error";

/**
 * Extended League interface with backfill fields
 */
export interface LeagueBackfillConfig {
  backfillEnabled?: boolean;
  backfillFromWeek?: number;
  backfillToWeek?: number;
  backfillStatus?: BackfillStatus;
  backfillCompletedAt?: Date | Timestamp;
  backfillCompletedBy?: string;
}

/**
 * Extended Week interface with backfill tracking
 */
export interface WeekBackfillInfo {
  backfillStatus?: "not_backfilled" | "backfilled" | "error";
  backfilledAt?: Date | Timestamp;
  backfilledBy?: string;
  isBackfilled?: boolean;
}

/**
 * Member pick for backfill - one member's picks for a week
 */
export interface BackfillMemberPick {
  userId: string;
  qbPlayerId?: string;
  rbPlayerId?: string;
  wrPlayerId?: string;
  qbPointsOverride?: number;
  rbPointsOverride?: number;
  wrPointsOverride?: number;
}

/**
 * Request payload for backfilling a single week
 */
export interface BackfillWeekRequest {
  leagueId: string;
  weekNumber: number;
  memberPicks: BackfillMemberPick[];
}

/**
 * Response from backfill operation
 */
export interface BackfillWeekResponse {
  ok: boolean;
  weekNumber: number;
  results: BackfillMemberResult[];
  error?: string;
}

export interface BackfillMemberResult {
  userId: string;
  displayName?: string;
  qbPlayerId?: string;
  rbPlayerId?: string;
  wrPlayerId?: string;
  qbPoints: number;
  rbPoints: number;
  wrPoints: number;
  totalPoints: number;
  qbPlayerName?: string;
  rbPlayerName?: string;
  wrPlayerName?: string;
  errors?: string[];
  warnings?: string[];
  isBackfilled?: boolean;
}

/**
 * Status response for getting backfill progress
 */
export interface BackfillStatusResponse {
  ok: boolean;
  leagueId: string;
  backfillEnabled: boolean;
  backfillFromWeek?: number;
  backfillToWeek?: number;
  overallStatus: BackfillStatus;
  weeks: BackfillWeekStatus[];
}

export interface BackfillWeekStatus {
  weekNumber: number;
  weekId: string;
  status: "not_backfilled" | "backfilled" | "error";
  memberCount: number;
  scores?: BackfillMemberResult[];
  backfilledAt?: string;
  backfilledBy?: string;
}


========================================
FILE: frontend/src/ui/AppShell.tsx
========================================

import React, { useState } from "react";
import { NavLink, useLocation } from "react-router-dom";
import { useAuth } from "../auth/AuthContext";
import { UserMenu } from "../auth/AuthGate";
import { LeagueSwitcher } from "../league/LeagueSwitcher";
import { LuUsers, LuSettings, LuClipboardCheck, LuTrophy, LuInfo } from "react-icons/lu";

const navItems = [
  { to: "/picks", label: "Picks", icon: <LuClipboardCheck className="w-5 h-5" /> },
  { to: "/standings", label: "Standings", icon: <LuTrophy className="w-5 h-5" /> },
  { to: "/leagues", label: "Leagues", icon: <LuUsers className="w-5 h-5" /> },
  { to: "/league-settings", label: "Settings", icon: <LuSettings className="w-5 h-5" /> },
  { to: "/rules", label: "Rules", icon: <LuInfo className="w-5 h-5" /> },
];

const MenuIcon = () => (
  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
  </svg>
);

const CloseIcon = () => (
  <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
  </svg>
);

export const AppShell: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const location = useLocation();
  const { user } = useAuth();

  // Close mobile menu on route change
  React.useEffect(() => {
    setMobileMenuOpen(false);
  }, [location.pathname]);

  return (
    <div className="min-h-screen flex flex-col bg-page">
      {/* Header */}
      <header className="sticky top-0 z-40 bg-surface/95 backdrop-blur-sm border-b border-border">
        <div className="max-w-container mx-auto px-4 sm:px-6">
          <div className="flex items-center justify-between h-16">
            {/* Logo and League Switcher */}
            <div className="flex items-center gap-4">
              <NavLink to="/" className="flex items-center gap-2 group">
                <div className="w-8 h-8 bg-primary rounded-lg flex items-center justify-center">
                  <span className="text-white font-bold text-sm">3</span>
                </div>
                <span className="hidden sm:inline text-lg font-semibold text-text-primary tracking-tight">
                  three<span className="text-primary">man</span>league
                </span>
              </NavLink>
              <div className="hidden sm:block h-6 w-px bg-border" />
              <LeagueSwitcher />
            </div>

            {/* Desktop Navigation */}
            <nav className="hidden md:flex items-center gap-1">
              {navItems.map((item) => (
                <NavLink
                  key={item.to}
                  to={item.to}
                  className={({ isActive }) =>
                    `flex items-center gap-2 px-4 py-2 rounded-button text-body-sm font-medium transition-all duration-150 ${
                      isActive
                        ? "bg-primary-soft text-primary"
                        : "text-text-secondary hover:text-text-primary hover:bg-subtle"
                    }`
                  }
                >
                  {item.icon}
                  <span>{item.label}</span>
                </NavLink>
              ))}
            </nav>

            {/* User menu (desktop) */}
            <div className="hidden md:block">
              {user && <UserMenu user={user} />}
            </div>

            {/* Mobile menu button */}
            <button
              onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
              className="md:hidden p-2 rounded-button text-text-secondary hover:text-text-primary hover:bg-subtle transition-colors"
              aria-label={mobileMenuOpen ? "Close menu" : "Open menu"}
            >
              {mobileMenuOpen ? <CloseIcon /> : <MenuIcon />}
            </button>
          </div>
        </div>

        {/* Mobile Navigation */}
        {mobileMenuOpen && (
          <div className="md:hidden border-t border-border bg-surface animate-fade-in">
            <nav className="max-w-container mx-auto px-4 py-3 space-y-1">
              {navItems.map((item) => (
                <NavLink
                  key={item.to}
                  to={item.to}
                  className={({ isActive }) =>
                    `flex items-center gap-3 px-4 py-3 rounded-button text-body font-medium transition-all ${
                      isActive
                        ? "bg-primary-soft text-primary"
                        : "text-text-secondary hover:text-text-primary hover:bg-subtle"
                    }`
                  }
                >
                  {item.icon}
                  <span>{item.label}</span>
                </NavLink>
              ))}
              {/* Mobile user info */}
              {user && (
                <div className="mt-3 pt-3 border-t border-border">
                  <div className="flex items-center gap-3 px-4 py-2">
                    {user.photoURL ? (
                      <img
                        src={user.photoURL}
                        alt={user.displayName || "User"}
                        className="w-8 h-8 rounded-full object-cover border border-border"
                      />
                    ) : (
                      <div className="w-8 h-8 rounded-full bg-primary-soft text-primary flex items-center justify-center text-caption font-semibold">
                        {user.displayName?.split(" ").map((n) => n[0]).join("").toUpperCase().slice(0, 2) || "U"}
                      </div>
                    )}
                    <div className="flex-1 min-w-0">
                      <p className="text-body-sm font-medium text-text-primary truncate">
                        {user.displayName || "Player"}
                      </p>
                      <p className="text-caption text-text-muted truncate">{user.email}</p>
                    </div>
                  </div>
                </div>
              )}
            </nav>
          </div>
        )}
      </header>

      {/* Main content */}
      <main className="flex-1">
        <div className="max-w-container mx-auto px-4 sm:px-6 py-6 sm:py-8">
          {children}
        </div>
      </main>

      {/* Footer */}
      <footer className="border-t border-border bg-subtle/50">
        <div className="max-w-container mx-auto px-4 sm:px-6 py-4">
          <div className="flex flex-col sm:flex-row items-center justify-between gap-2 text-caption text-text-muted">
            <span>© 2025 Three-Man League. Fantasy Football Pick 'Em.</span>
            <span>Powered by DraftKings Scoring</span>
          </div>
        </div>
      </footer>
    </div>
  );
};



========================================
FILE: frontend/src/index.css
========================================

/* Import Inter font from Google Fonts */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

/* CSS Custom Properties for design tokens */
:root {
  /* Backgrounds */
  --color-page: #F8FAFC;
  --color-surface: #FFFFFF;
  --color-subtle: #F1F5F9;
  --color-elevated: #FFFFFF;

  /* Primary accent */
  --color-primary: #059669;
  --color-primary-soft: #D1FAE5;
  --color-primary-hover: #047857;
  --color-primary-active: #065F46;

  /* Text */
  --color-text-primary: #1E293B;
  --color-text-secondary: #475569;
  --color-text-muted: #64748B;
  --color-text-subtle: #94A3B8;

  /* Borders */
  --color-border: #E2E8F0;
  --color-border-subtle: #F1F5F9;
  --color-border-strong: #CBD5E1;

  /* Shadows */
  --shadow-card: 0 1px 3px 0 rgb(0 0 0 / 0.06), 0 1px 2px -1px rgb(0 0 0 / 0.06);
  --shadow-card-hover: 0 4px 6px -1px rgb(0 0 0 / 0.08), 0 2px 4px -2px rgb(0 0 0 / 0.06);
  --shadow-dropdown: 0 10px 15px -3px rgb(0 0 0 / 0.08), 0 4px 6px -4px rgb(0 0 0 / 0.06);

  /* Transitions */
  --transition-fast: 150ms ease;
  --transition-normal: 200ms ease;
}

/* Base layer resets */
@layer base {
  html {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  body {
    background-color: #F8FAFC;
    color: #1E293B;
    font-feature-settings: "cv02", "cv03", "cv04", "cv11";
  }

  /* Better focus styles */
  *:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px #FFFFFF, 0 0 0 4px #059669;
  }

  /* Custom scrollbar for webkit browsers */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  ::-webkit-scrollbar-track {
    background-color: #F1F5F9;
    border-radius: 9999px;
  }

  ::-webkit-scrollbar-thumb {
    background-color: #CBD5E1;
    border-radius: 9999px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background-color: #94A3B8;
  }
}

/* Component layer utilities */
@layer components {
  /* Card base styles */
  .card {
    @apply bg-surface rounded-card shadow-card border border-border;
  }

  .card-elevated {
    @apply bg-surface rounded-card shadow-card-hover border border-border;
  }

  /* Button base styles */
  .btn {
    @apply inline-flex items-center justify-center font-medium rounded-button transition-all duration-150;
    @apply focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary;
  }

  .btn-primary {
    @apply btn px-4 py-2.5 bg-primary text-white hover:bg-primary-hover active:bg-primary-active;
  }

  .btn-secondary {
    @apply btn px-4 py-2.5 bg-subtle text-text-primary hover:bg-border border border-border;
  }

  .btn-ghost {
    @apply btn px-4 py-2.5 text-text-secondary hover:bg-subtle hover:text-text-primary;
  }

  /* Input base styles */
  .input {
    @apply w-full px-3.5 py-2.5 bg-surface border border-border rounded-input text-body-sm text-text-primary;
    @apply placeholder:text-text-subtle;
    @apply focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary;
    @apply transition-all duration-150;
  }

  .select {
    @apply input appearance-none bg-no-repeat bg-right pr-10 cursor-pointer;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%2364748B'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
    background-size: 1.25rem;
    background-position: right 0.75rem center;
  }

  /* Badge base styles */
  .badge {
    @apply inline-flex items-center px-2 py-0.5 text-tiny font-medium rounded-badge;
  }

  .badge-primary {
    @apply badge bg-primary-soft text-primary;
  }

  .badge-warning {
    @apply badge bg-warning-soft text-warning-text;
  }

  .badge-error {
    @apply badge bg-error-soft text-error-text;
  }

  .badge-success {
    @apply badge bg-success-soft text-success-text;
  }

  .badge-info {
    @apply badge bg-info-soft text-info-text;
  }

  .badge-neutral {
    @apply badge bg-subtle text-text-secondary;
  }
}


--- BACKEND CONFIGURATION ---

========================================
FILE: functions/package.json
========================================

{
  "name": "functions",
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "serve": "npm run build && firebase emulators:start --only functions",
    "shell": "npm run build && firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log",
    "test": "jest",
    "lint": "tsc --noEmit",
    "typecheck": "tsc --noEmit"
  },
  "engines": {
    "node": "20"
  },
  "main": "lib/index.js",
  "dependencies": {
    "firebase-admin": "^12.0.0",
    "firebase-functions": "^5.0.0",
    "node-fetch": "^3.3.0",
    "openai": "^4.0.0"
  },
  "devDependencies": {
    "@types/express": "^5.0.5",
    "@types/jest": "^30.0.0",
    "@types/node": "^20.0.0",
    "jest": "^30.2.0",
    "ts-jest": "^29.4.5",
    "typescript": "^5.0.0"
  },
  "private": true
}


========================================
FILE: functions/tsconfig.json
========================================

{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "outDir": "lib",
    "sourceMap": true,
    "strict": true,
    "target": "ES2022",
    "skipLibCheck": true
  },
  "compileOnSave": true,
  "include": [
    "src"
  ]
}



--- BACKEND SOURCE CODE ---

========================================
FILE: functions/src/backfill.ts
========================================

/**
 * Backfill Cloud Functions
 *
 * Handles mid-season league setup by allowing admins to backfill
 * historical weeks with picks and scores from spreadsheet data.
 */

import { onRequest } from "firebase-functions/v2/https";
import { db, SEASON } from "./config.js";
import { fetchEventStats, fetchWeekSchedule } from "./sportsApi.js";
import { calculateDraftKingsPoints, mapSportsDbToStats } from "./scoring.js";
import { setCors, verifyAuth, handlePreflight, sendError, sendSuccess } from "./utils/http.js";
import type {
  BackfillWeekRequest,
  BackfillWeekResponse,
  BackfillStatusResponse,
  BackfillMemberPick,
  MemberRole,
} from "./types.js";

// Check if user is league owner or co-owner
async function isLeagueAdmin(leagueId: string, userId: string): Promise<boolean> {
  try {
    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) return false;
    
    const leagueData = leagueDoc.data()!;
    if (leagueData.ownerId === userId) return true;

    // Check for co-owner role
    const memberDoc = await db.collection("leagues").doc(leagueId)
      .collection("members").doc(userId).get();
    
    if (memberDoc.exists) {
      const role = memberDoc.data()?.role as MemberRole;
      return role === "owner" || role === "coOwner";
    }
    
    return false;
  } catch {
    return false;
  }
}

/**
 * Enable backfill mode for a league
 */
export const enableBackfill = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId, fromWeek, toWeek } = req.body as {
    leagueId: string;
    fromWeek: number;
    toWeek: number;
  };

  if (!leagueId || !fromWeek || !toWeek) {
    sendError(res, 400, "leagueId, fromWeek, and toWeek required");
    return;
  }

  if (fromWeek < 1 || toWeek > 18 || fromWeek > toWeek) {
    sendError(res, 400, "Invalid week range. Must be 1-18 and fromWeek <= toWeek");
    return;
  }

  const isAdmin = await isLeagueAdmin(leagueId, userId);
  if (!isAdmin) {
    sendError(res, 403, "Only league owner or co-owner can enable backfill");
    return;
  }

  try {
    const batch = db.batch();

    // Update league with backfill settings
    batch.update(db.collection("leagues").doc(leagueId), {
      backfillEnabled: true,
      backfillFromWeek: fromWeek,
      backfillToWeek: toWeek,
      backfillStatus: "in_progress",
      updatedAt: new Date(),
    });

    // Create week documents for each week in range if they don't exist
    for (let week = fromWeek; week <= toWeek; week++) {
      const weekId = `week-${week}`;
      const weekRef = db.collection("leagues").doc(leagueId).collection("weeks").doc(weekId);

      // Use set with merge to create if not exists
      batch.set(weekRef, {
        weekNumber: week,
        weekId,
        status: "pending_backfill",
        isBackfilled: false,
        createdAt: new Date(),
      }, { merge: true });
    }

    await batch.commit();

    sendSuccess(res, { ok: true });
  } catch (err: unknown) {
    console.error("Enable backfill error:", err);
    sendError(res, 500, err instanceof Error ? err.message : "Unknown error");
  }
});

/**
 * Get backfill status for a league
 */
export const getBackfillStatus = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const leagueId = (req.query.leagueId || req.body?.leagueId) as string;
  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  const isAdmin = await isLeagueAdmin(leagueId, userId);
  if (!isAdmin) {
    sendError(res, 403, "Only league admin can view backfill status");
    return;
  }

  try {
    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) {
      sendError(res, 404, "League not found");
      return;
    }

    const leagueData = leagueDoc.data()!;
    const fromWeek = leagueData.backfillFromWeek || 1;
    const toWeek = leagueData.backfillToWeek || 1;

    // Get week statuses
    const weeksSnap = await db.collection("leagues").doc(leagueId)
      .collection("weeks").get();

    const weeks: BackfillStatusResponse["weeks"] = [];

    for (const weekDoc of weeksSnap.docs) {
      const weekData = weekDoc.data();
      const weekNumber = weekData.weekNumber;

      if (weekNumber >= fromWeek && weekNumber <= toWeek) {
        // Get scores for this week if backfilled
        const scoresSnap = await db.collection("leagues").doc(leagueId)
          .collection("weeks").doc(weekDoc.id)
          .collection("scores").get();

        weeks.push({
          weekNumber,
          weekId: weekDoc.id,
          status: weekData.isBackfilled ? "backfilled" : "not_backfilled",
          memberCount: scoresSnap.size,
          backfilledAt: weekData.backfilledAt?.toDate?.()?.toISOString?.(),
          backfilledBy: weekData.backfilledBy,
        });
      }
    }

    weeks.sort((a, b) => a.weekNumber - b.weekNumber);

    const response: BackfillStatusResponse = {
      ok: true,
      leagueId,
      backfillEnabled: leagueData.backfillEnabled || false,
      backfillFromWeek: fromWeek,
      backfillToWeek: toWeek,
      overallStatus: leagueData.backfillStatus || "not_started",
      weeks,
    };

    sendSuccess(res, response);
  } catch (err: unknown) {
    console.error("Get backfill status error:", err);
    sendError(res, 500, err instanceof Error ? err.message : "Unknown error");
  }
});

/**
 * Backfill a single week for a league
 * This is the main function that processes picks and computes scores
 */
export const backfillWeekForLeague = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId, weekNumber, memberPicks } = req.body as BackfillWeekRequest;

  if (!leagueId || !weekNumber || !memberPicks || !Array.isArray(memberPicks)) {
    sendError(res, 400, "leagueId, weekNumber, and memberPicks array required");
    return;
  }

  if (weekNumber < 1 || weekNumber > 18) {
    sendError(res, 400, "weekNumber must be between 1 and 18");
    return;
  }

  const isAdmin = await isLeagueAdmin(leagueId, userId);
  if (!isAdmin) {
    sendError(res, 403, "Only league admin can backfill weeks");
    return;
  }

  try {
    // Verify league exists and backfill is enabled
    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) {
      sendError(res, 404, "League not found");
      return;
    }

    const leagueData = leagueDoc.data()!;
    if (!leagueData.backfillEnabled) {
      sendError(res, 400, "Backfill not enabled for this league");
      return;
    }

    const weekId = `week-${weekNumber}`;

    // Build gameId lookup: fetch games for this week to find player games
    const scheduleEvents = await fetchWeekSchedule(weekNumber);
    const gameIdByTeam = new Map<string, string>();

    for (const ev of scheduleEvents) {
      gameIdByTeam.set(ev.idHomeTeam, ev.idEvent);
      gameIdByTeam.set(ev.idAwayTeam, ev.idEvent);
    }

    // Process each member's picks
    const results: BackfillWeekResponse["results"] = [];
    const batch = db.batch();

    for (const memberPick of memberPicks) {
      const result = await processBackfillMember(
        leagueId,
        weekId,
        weekNumber,
        memberPick,
        gameIdByTeam,
        userId,
        batch
      );
      results.push(result);
    }

    // Mark week as backfilled
    const weekRef = db.collection("leagues").doc(leagueId).collection("weeks").doc(weekId);
    batch.update(weekRef, {
      status: "final",
      isBackfilled: true,
      backfilledAt: new Date(),
      backfilledBy: userId,
    });

    // Commit all changes
    await batch.commit();

    // Update season standings after backfill
    await updateSeasonStandings(leagueId);

    const response: BackfillWeekResponse = {
      ok: true,
      weekNumber,
      results,
    };

    sendSuccess(res, response);
  } catch (err: unknown) {
    console.error("Backfill week error:", err);
    sendError(res, 500, err instanceof Error ? err.message : "Unknown error");
  }
});

/**
 * Process a single member's backfill picks
 */
async function processBackfillMember(
  leagueId: string,
  weekId: string,
  weekNumber: number,
  memberPick: BackfillMemberPick,
  gameIdByTeam: Map<string, string>,
  backfilledBy: string,
  batch: FirebaseFirestore.WriteBatch
): Promise<BackfillWeekResponse["results"][0]> {
  const { userId, qbPlayerId, rbPlayerId, wrPlayerId } = memberPick;
  const errors: string[] = [];
  const warnings: string[] = [];

  // Get member display name
  const memberDoc = await db.collection("leagues").doc(leagueId)
    .collection("members").doc(userId).get();
  const displayName = memberDoc.data()?.displayName || userId;

  const positions = ["qb", "rb", "wr"] as const;
  const playerIds = { qb: qbPlayerId, rb: rbPlayerId, wr: wrPlayerId };
  const points: Record<string, number> = { qb: 0, rb: 0, wr: 0 };
  const playerNames: Record<string, string> = { qb: "", rb: "", wr: "" };
  const gameIds: Record<string, string | undefined> = { qb: undefined, rb: undefined, wr: undefined };

  for (const pos of positions) {
    const playerId = playerIds[pos];
    if (!playerId) continue;

    try {
      // Get player info
      const playerDoc = await db.collection("players").doc(playerId).get();
      if (!playerDoc.exists) {
        errors.push(`${pos.toUpperCase()}: Player ${playerId} not found`);
        continue;
      }

      const playerData = playerDoc.data()!;
      playerNames[pos] = playerData.name;
      const teamId = playerData.teamId;

      // Find game for this player's team
      const gameId = gameIdByTeam.get(teamId);
      if (!gameId) {
        warnings.push(`${pos.toUpperCase()}: No game found for ${playerData.name} (${playerData.teamName}) in week ${weekNumber}`);
        // Check for override
        const override = memberPick[`${pos}PointsOverride` as keyof BackfillMemberPick] as number | undefined;
        if (override !== undefined) {
          points[pos] = override;
        }
        continue;
      }

      gameIds[pos] = gameId;

      // Check for override first
      const override = memberPick[`${pos}PointsOverride` as keyof BackfillMemberPick] as number | undefined;
      if (override !== undefined) {
        points[pos] = override;
        continue;
      }

      // Fetch game stats
      const statsArray = await fetchEventStats(gameId);
      const playerStat = statsArray.find(s => s.idPlayer === playerId);

      if (!playerStat) {
        warnings.push(`${pos.toUpperCase()}: No stats for ${playerData.name} in game ${gameId}`);
        continue;
      }

      // Calculate points using same logic as live scoring
      const dkStats = mapSportsDbToStats(playerStat);
      points[pos] = calculateDraftKingsPoints(dkStats);

    } catch (err) {
      errors.push(`${pos.toUpperCase()}: Error processing - ${err instanceof Error ? err.message : "Unknown"}`);
    }
  }

  const totalPoints = points.qb + points.rb + points.wr;

  // Write picks document
  const picksRef = db.collection("leagues").doc(leagueId)
    .collection("weeks").doc(weekId)
    .collection("picks").doc(userId);

  batch.set(picksRef, {
    qbPlayerId: playerIds.qb || null,
    qbGameId: gameIds.qb || null,
    qbLocked: true,
    rbPlayerId: playerIds.rb || null,
    rbGameId: gameIds.rb || null,
    rbLocked: true,
    wrPlayerId: playerIds.wr || null,
    wrGameId: gameIds.wr || null,
    wrLocked: true,
    createdAt: new Date(),
    updatedAt: new Date(),
    isBackfilled: true,
    backfilledBy,
  }, { merge: true });

  // Write scores document
  const scoresRef = db.collection("leagues").doc(leagueId)
    .collection("weeks").doc(weekId)
    .collection("scores").doc(userId);

  batch.set(scoresRef, {
    qbPoints: points.qb,
    rbPoints: points.rb,
    wrPoints: points.wr,
    totalPoints,
    doublePickPositions: [],
    updatedAt: new Date(),
    isBackfilled: true,
    backfilledBy,
  }, { merge: true });

  // Write player usage for each position
  for (const pos of positions) {
    const playerId = playerIds[pos];
    if (!playerId) continue;

    const usageRef = db.collection("users").doc(userId)
      .collection("playerUsage").doc(`${SEASON}_${playerId}_${leagueId}`);

    // Check if already used in a different week
    const existingUsage = await usageRef.get();
    if (!existingUsage.exists) {
      batch.set(usageRef, {
        season: SEASON,
        playerId,
        firstUsedWeek: weekId,
        leagueId,
        isBackfilled: true,
      });
    } else if (existingUsage.data()?.firstUsedWeek !== weekId) {
      // Already used in different week - note this but don't fail
      warnings.push(`${pos.toUpperCase()}: ${playerNames[pos]} already used in ${existingUsage.data()?.firstUsedWeek}`);
    }
  }

  return {
    userId,
    displayName,
    qbPoints: points.qb,
    rbPoints: points.rb,
    wrPoints: points.wr,
    totalPoints,
    qbPlayerName: playerNames.qb,
    rbPlayerName: playerNames.rb,
    wrPlayerName: playerNames.wr,
    errors: errors.length > 0 ? errors : undefined,
    warnings: warnings.length > 0 ? warnings : undefined,
  };
}

/**
 * Update season standings after backfill
 */
async function updateSeasonStandings(leagueId: string): Promise<void> {
  const weeksSnap = await db.collection("leagues").doc(leagueId)
    .collection("weeks").get();

  const userTotals: Record<string, {
    total: number;
    weeks: number;
    bestWeekPoints: number;
    bestWeek: string;
  }> = {};

  for (const weekDoc of weeksSnap.docs) {
    const weekId = weekDoc.id;
    const scoresSnap = await db.collection("leagues").doc(leagueId)
      .collection("weeks").doc(weekId)
      .collection("scores").get();

    for (const scoreDoc of scoresSnap.docs) {
      const scoreUserId = scoreDoc.id;
      const score = scoreDoc.data();
      const totalPoints = score.totalPoints || 0;

      if (!userTotals[scoreUserId]) {
        userTotals[scoreUserId] = { total: 0, weeks: 0, bestWeekPoints: 0, bestWeek: "" };
      }

      userTotals[scoreUserId].total += totalPoints;
      userTotals[scoreUserId].weeks += 1;

      if (totalPoints > userTotals[scoreUserId].bestWeekPoints) {
        userTotals[scoreUserId].bestWeekPoints = totalPoints;
        userTotals[scoreUserId].bestWeek = weekId;
      }
    }
  }

  // Get member display names
  const membersSnap = await db.collection("leagues").doc(leagueId)
    .collection("members").where("isActive", "==", true).get();

  const displayNames: Record<string, string> = {};
  for (const memberDoc of membersSnap.docs) {
    displayNames[memberDoc.id] = memberDoc.data().displayName || memberDoc.id;
  }

  // Write standings
  const batch = db.batch();
  for (const [standingUserId, data] of Object.entries(userTotals)) {
    const standingRef = db.collection("leagues").doc(leagueId)
      .collection("seasonStandings").doc(standingUserId);

    batch.set(standingRef, {
      userId: standingUserId,
      displayName: displayNames[standingUserId] || standingUserId,
      seasonTotalPoints: Math.round(data.total * 100) / 100,
      weeksPlayed: data.weeks,
      bestWeekPoints: Math.round(data.bestWeekPoints * 100) / 100,
      bestWeek: data.bestWeek,
      updatedAt: new Date(),
    });
  }

  await batch.commit();
}

/**
 * Complete backfill and mark league as ready
 */
export const completeBackfill = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId } = req.body as { leagueId: string };
  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  const isAdmin = await isLeagueAdmin(leagueId, userId);
  if (!isAdmin) {
    sendError(res, 403, "Only league admin can complete backfill");
    return;
  }

  try {
    await db.collection("leagues").doc(leagueId).update({
      backfillStatus: "completed",
      backfillCompletedAt: new Date(),
      backfillCompletedBy: userId,
      status: "active", // Transition league to active
      updatedAt: new Date(),
    });

    // Final standings update
    await updateSeasonStandings(leagueId);

    sendSuccess(res, { ok: true });
  } catch (err: unknown) {
    console.error("Complete backfill error:", err);
    sendError(res, 500, err instanceof Error ? err.message : "Unknown error");
  }
});

/**
 * Get detailed week scores for review
 */
export const getBackfillWeekScores = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const leagueId = (req.query.leagueId || req.body?.leagueId) as string;
  const weekNumber = parseInt((req.query.weekNumber || req.body?.weekNumber) as string);

  if (!leagueId || !weekNumber) {
    sendError(res, 400, "leagueId and weekNumber required");
    return;
  }

  const isAdmin = await isLeagueAdmin(leagueId, userId);
  if (!isAdmin) {
    sendError(res, 403, "Only league admin can view backfill scores");
    return;
  }

  try {
    const weekId = `week-${weekNumber}`;

    // Get all picks for this week
    const picksSnap = await db.collection("leagues").doc(leagueId)
      .collection("weeks").doc(weekId)
      .collection("picks").get();

    // Get all scores for this week
    const scoresSnap = await db.collection("leagues").doc(leagueId)
      .collection("weeks").doc(weekId)
      .collection("scores").get();

    const scoresMap = new Map<string, FirebaseFirestore.DocumentData>();
    for (const scoreDoc of scoresSnap.docs) {
      scoresMap.set(scoreDoc.id, scoreDoc.data());
    }

    // Get member info
    const membersSnap = await db.collection("leagues").doc(leagueId)
      .collection("members").where("isActive", "==", true).get();

    const memberNames = new Map<string, string>();
    for (const memberDoc of membersSnap.docs) {
      memberNames.set(memberDoc.id, memberDoc.data().displayName || memberDoc.id);
    }

    const results = [];
    for (const pickDoc of picksSnap.docs) {
      const pickUserId = pickDoc.id;
      const pickData = pickDoc.data();
      const scoreData = scoresMap.get(pickUserId) || {};

      // Get player names
      const playerNames: Record<string, string> = { qb: "", rb: "", wr: "" };
      for (const pos of ["qb", "rb", "wr"]) {
        const playerId = pickData[`${pos}PlayerId`];
        if (playerId) {
          const playerDoc = await db.collection("players").doc(playerId).get();
          playerNames[pos] = playerDoc.data()?.name || playerId;
        }
      }

      results.push({
        userId: pickUserId,
        displayName: memberNames.get(pickUserId) || pickUserId,
        qbPlayerId: pickData.qbPlayerId,
        qbPlayerName: playerNames.qb,
        qbPoints: scoreData.qbPoints || 0,
        rbPlayerId: pickData.rbPlayerId,
        rbPlayerName: playerNames.rb,
        rbPoints: scoreData.rbPoints || 0,
        wrPlayerId: pickData.wrPlayerId,
        wrPlayerName: playerNames.wr,
        wrPoints: scoreData.wrPoints || 0,
        totalPoints: scoreData.totalPoints || 0,
        isBackfilled: pickData.isBackfilled || false,
      });
    }

    results.sort((a, b) => b.totalPoints - a.totalPoints);

    sendSuccess(res, {
      ok: true,
      weekNumber,
      weekId,
      scores: results,
    });
  } catch (err: unknown) {
    console.error("Get backfill week scores error:", err);
    sendError(res, 500, err instanceof Error ? err.message : "Unknown error");
  }
});



========================================
FILE: functions/src/config.ts
========================================

import * as admin from "firebase-admin";

if (!admin.apps.length) {
  admin.initializeApp();
}

export const db = admin.firestore();

// ============================================================================
// Season Configuration
// ============================================================================

/** Current NFL season year */
export const SEASON = "2025";

/** Season start date - games before this are preseason */
export const SEASON_START = new Date("2025-09-01T00:00:00Z");

/** Number of weeks in the NFL regular season */
export const REGULAR_SEASON_WEEKS = 18;

/** Positions allowed for picks */
export const PICK_POSITIONS = ["QB", "RB", "WR"] as const;
export type PickPosition = (typeof PICK_POSITIONS)[number];

// ============================================================================
// External API Configuration
// ============================================================================

/** ESPN API endpoints (no API key required - free and public) */
export const ESPN_SITE_API = "https://site.api.espn.com/apis/site/v2/sports/football/nfl";
export const ESPN_CORE_API = "https://sports.core.api.espn.com/v2/sports/football/leagues/nfl";



========================================
FILE: functions/src/index.ts
========================================

import { onRequest } from "firebase-functions/v2/https";
import { onSchedule } from "firebase-functions/v2/scheduler";
import { db, SEASON } from "./config.js";
import {
  fetchSeasonSchedule,
  fetchEventStats,
  fetchAllNflPlayers,
  fetchLeagueTeams,
  fetchPlayerSeasonStats,
  calculateFantasyPoints,
  getCurrentWeek,
  type SportsPlayer
} from "./sportsApi.js";
import { calculateDraftKingsPoints, mapSportsDbToStats } from "./scoring.js";
import { setCors, handlePreflight, sendError, sendSuccess, verifyAdminKey } from "./utils/http.js";
import * as admin from "firebase-admin";
import type { EligiblePosition, Position, SeasonStats } from "./types.js";

// Re-export league management functions
export {
  createLeague,
  joinLeague,
  getUserLeagues,
  getAvailableLeagues,
  getLeagueDetails,
  updateLeagueSettings,
  regenerateJoinCode,
  leaveOrRemoveMember,
  setActiveLeague,
} from "./leagueManagement.js";

// Re-export backfill functions for mid-season setup
export {
  enableBackfill,
  getBackfillStatus,
  backfillWeekForLeague,
  completeBackfill,
  getBackfillWeekScores,
} from "./backfill.js";

// ===== Helper: Map position string to our Position type =====
function normalizePosition(pos: string): Position | null {
  const p = pos?.toUpperCase().trim();
  if (p === "QUARTERBACK" || p === "QB") return "QB";
  if (p === "RUNNING BACK" || p === "RB") return "RB";
  if (p === "WIDE RECEIVER" || p === "WR") return "WR";
  if (p === "TIGHT END" || p === "TE") return "TE";
  return null;
}

function getEligiblePositions(pos: Position): EligiblePosition[] {
  if (pos === "QB") return ["QB"];
  if (pos === "RB") return ["RB"];
  if (pos === "WR") return ["WR"];
  // TEs are NOT eligible for WR slot per rules
  return [];
}



/**
 * Sync NFL schedule into Firestore.
 * Protected by admin API key.
 */
export const syncSchedule = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  // Verify admin key
  if (!verifyAdminKey(req.headers["x-admin-key"] as string)) {
    sendError(res, 403, "Admin access required");
    return;
  }

  try {
    // First fetch teams to get team names
    const teams = await fetchLeagueTeams();
    const teamMap = new Map(teams.map(t => [t.idTeam, t.strTeam]));

    const events = await fetchSeasonSchedule();

    // Batch writes in chunks of 400 (Firestore limit is 500)
    const BATCH_SIZE = 400;
    let count = 0;

    for (let i = 0; i < events.length; i += BATCH_SIZE) {
      const chunk = events.slice(i, i + BATCH_SIZE);
      const batch = db.batch();

      for (const ev of chunk) {
        const gameId = ev.idEvent;
        // Handle time parsing
        const timeStr = ev.strTime || "00:00:00";
        const kickoff = new Date(`${ev.dateEvent}T${timeStr}Z`);

        const docRef = db.collection("games").doc(gameId);
        batch.set(docRef, {
          gameId,
          externalEventId: ev.idEvent,
          homeTeamId: ev.idHomeTeam,
          awayTeamId: ev.idAwayTeam,
          homeTeamName: ev.strHomeTeam || teamMap.get(ev.idHomeTeam) || "Unknown",
          awayTeamName: ev.strAwayTeam || teamMap.get(ev.idAwayTeam) || "Unknown",
          kickoffTime: kickoff,
          weekNumber: ev.intRound ? Number(ev.intRound) : null,
          status: ev.strStatus === "STATUS_FINAL" ? "final" : "scheduled",
        }, { merge: true });
        count++;
      }

      await batch.commit();
    }

    // Update current week in config document
    const currentWeek = await getCurrentWeek();
    await db.collection("config").doc("season").set({
      season: SEASON,
      currentWeek,
      lastUpdated: new Date(),
    }, { merge: true });

    sendSuccess(res, { ok: true, count, currentWeek });
  } catch (err: unknown) {
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Sync NFL players into Firestore.
 * Protected by admin API key.
 */
export const syncPlayers = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  // Verify admin key
  if (!verifyAdminKey(req.headers["x-admin-key"] as string)) {
    sendError(res, 403, "Admin access required");
    return;
  }

  try {
    const players = await fetchAllNflPlayers();
    let count = 0;

    // Batch writes in chunks of 500 (Firestore limit)
    const chunks: SportsPlayer[][] = [];
    for (let i = 0; i < players.length; i += 400) {
      chunks.push(players.slice(i, i + 400));
    }

    for (const chunk of chunks) {
      const batch = db.batch();
      for (const p of chunk) {
        const pos = normalizePosition(p.strPosition);
        if (!pos) continue; // Skip non-skill positions

        const eligiblePositions = getEligiblePositions(pos);
        if (eligiblePositions.length === 0) continue; // Skip TEs and others

        const docRef = db.collection("players").doc(p.idPlayer);
        batch.set(docRef, {
          name: p.strPlayer,
          position: pos,
          teamId: p.idTeam,
          teamName: p.strTeam || "Unknown",
          externalId: p.idPlayer,
          eligiblePositions,
        }, { merge: true });
        count++;
      }
      await batch.commit();
    }

    sendSuccess(res, { ok: true, count });
  } catch (err: unknown) {
    console.error(err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

// Weekly schedule refresh - runs Tuesday at 6am UTC
export const syncScheduleWeekly = onSchedule("0 6 * * 2", async () => {
  const teams = await fetchLeagueTeams();
  const teamMap = new Map(teams.map(t => [t.idTeam, t.strTeam]));

  const events = await fetchSeasonSchedule();
  const BATCH_SIZE = 400;
  let count = 0;

  for (let i = 0; i < events.length; i += BATCH_SIZE) {
    const chunk = events.slice(i, i + BATCH_SIZE);
    const batch = db.batch();

    for (const ev of chunk) {
      const gameId = ev.idEvent;
      const timeStr = ev.strTime || "00:00:00";
      const kickoff = new Date(`${ev.dateEvent}T${timeStr}Z`);

      const docRef = db.collection("games").doc(gameId);
      batch.set(docRef, {
        gameId,
        externalEventId: ev.idEvent,
        homeTeamId: ev.idHomeTeam,
        awayTeamId: ev.idAwayTeam,
        homeTeamName: ev.strHomeTeam || teamMap.get(ev.idHomeTeam) || "Unknown",
        awayTeamName: ev.strAwayTeam || teamMap.get(ev.idAwayTeam) || "Unknown",
        kickoffTime: kickoff,
        weekNumber: ev.intRound ? Number(ev.intRound) : null,
        status: ev.strStatus === "STATUS_FINAL" ? "final" : "scheduled",
      }, { merge: true });
      count++;
    }

    await batch.commit();
  }

  console.log(`Synced ${count} games`);
});

/**
 * Sync player season statistics from ESPN.
 * Updates each player with their YTD stats and calculated fantasy points.
 * Rate-limited to avoid overwhelming the ESPN API.
 * Protected by admin API key.
 */
export const syncPlayerStats = onRequest(
  { timeoutSeconds: 540 }, // 9 minutes
  async (req, res) => {
    setCors(res);
    if (handlePreflight(req.method, res)) return;

    // Verify admin key
    if (!verifyAdminKey(req.headers["x-admin-key"] as string)) {
      sendError(res, 403, "Admin access required");
      return;
    }

    try {
      // Get all players from Firestore
      const playersSnap = await db.collection("players").get();
      console.log(`Syncing stats for ${playersSnap.size} players...`);

      let updated = 0;
      let failed = 0;
      const batchSize = 20; // Process 20 players at a time to avoid rate limits
      const players = playersSnap.docs;

      for (let i = 0; i < players.length; i += batchSize) {
        const chunk = players.slice(i, i + batchSize);

        // Fetch stats in parallel for this chunk
        const statsPromises = chunk.map(async (doc) => {
          const playerId = doc.id;
          try {
            const espnStats = await fetchPlayerSeasonStats(playerId);
            if (espnStats) {
              const fantasyPoints = calculateFantasyPoints(espnStats);
              const seasonStats: SeasonStats = {
                passingYards: espnStats.passingYards,
                passingTD: espnStats.passingTouchdowns,
                interceptions: espnStats.interceptions,
                rushingYards: espnStats.rushingYards,
                rushingTD: espnStats.rushingTouchdowns,
                receivingYards: espnStats.receivingYards,
                receivingTD: espnStats.receivingTouchdowns,
                receptions: espnStats.receptions,
                fumblesLost: espnStats.fumblesLost,
                gamesPlayed: espnStats.gamesPlayed,
                fantasyPoints,
              };
              return { playerId, seasonStats, success: true };
            }
            return { playerId, success: false };
          } catch {
            return { playerId, success: false };
          }
        });

        const results = await Promise.all(statsPromises);

        // Batch write successful updates
        const batch = db.batch();
        for (const result of results) {
          if (result.success && result.seasonStats) {
            const docRef = db.collection("players").doc(result.playerId);
            batch.update(docRef, {
              seasonStats: result.seasonStats,
              statsUpdatedAt: admin.firestore.FieldValue.serverTimestamp(),
            });
            updated++;
          } else {
            failed++;
          }
        }
        await batch.commit();

        console.log(`Processed ${i + chunk.length}/${players.length} players (${updated} updated, ${failed} failed)`);

        // Small delay between chunks to avoid rate limiting
        if (i + batchSize < players.length) {
          await new Promise((r) => setTimeout(r, 500));
        }
      }

      sendSuccess(res, { ok: true, updated, failed, total: players.length });
    } catch (err: unknown) {
      console.error(err);
      const errorMessage = err instanceof Error ? err.message : "Unknown error";
      sendError(res, 500, errorMessage);
    }
  }
);

// Schedule player stats sync - runs daily at 5am UTC
export const syncPlayerStatsDaily = onSchedule("0 5 * * *", async () => {
  const playersSnap = await db.collection("players").get();
  console.log(`Daily stats sync for ${playersSnap.size} players...`);

  let updated = 0;
  const batchSize = 20;
  const players = playersSnap.docs;

  for (let i = 0; i < players.length; i += batchSize) {
    const chunk = players.slice(i, i + batchSize);

    const statsPromises = chunk.map(async (doc) => {
      const playerId = doc.id;
      try {
        const espnStats = await fetchPlayerSeasonStats(playerId);
        if (espnStats) {
          const fantasyPoints = calculateFantasyPoints(espnStats);
          const seasonStats: SeasonStats = {
            passingYards: espnStats.passingYards,
            passingTD: espnStats.passingTouchdowns,
            interceptions: espnStats.interceptions,
            rushingYards: espnStats.rushingYards,
            rushingTD: espnStats.rushingTouchdowns,
            receivingYards: espnStats.receivingYards,
            receivingTD: espnStats.receivingTouchdowns,
            receptions: espnStats.receptions,
            fumblesLost: espnStats.fumblesLost,
            gamesPlayed: espnStats.gamesPlayed,
            fantasyPoints,
          };
          return { playerId, seasonStats, success: true };
        }
        return { playerId, success: false };
      } catch {
        return { playerId, success: false };
      }
    });

    const results = await Promise.all(statsPromises);

    const batch = db.batch();
    for (const result of results) {
      if (result.success && result.seasonStats) {
        const docRef = db.collection("players").doc(result.playerId);
        batch.update(docRef, {
          seasonStats: result.seasonStats,
          statsUpdatedAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        updated++;
      }
    }
    await batch.commit();

    if (i + batchSize < players.length) {
      await new Promise((r) => setTimeout(r, 500));
    }
  }

  console.log(`Daily sync complete: ${updated} players updated`);
});

/**
 * Score a week's picks for a league
 * Protected by admin API key.
 */
export const scoreWeek = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  // Verify admin key
  if (!verifyAdminKey(req.headers["x-admin-key"] as string)) {
    sendError(res, 403, "Admin access required");
    return;
  }

  const leagueId = (req.query.leagueId || req.body?.leagueId) as string;
  const weekId = (req.query.weekId || req.body?.weekId) as string;
  if (!leagueId || !weekId) {
    sendError(res, 400, "leagueId and weekId required");
    return;
  }

  try {
    // Mark week as scoring
    const weekRef = db.collection("leagues").doc(leagueId).collection("weeks").doc(weekId);
    await weekRef.set({ status: "scoring" }, { merge: true });

    const picksSnap = await db
      .collection("leagues")
      .doc(leagueId)
      .collection("weeks")
      .doc(weekId)
      .collection("picks")
      .get();

    for (const pickDoc of picksSnap.docs) {
      const userId = pickDoc.id;
      const pick = pickDoc.data();
      const batch = db.batch();

      const positions: ("qb" | "rb" | "wr")[] = ["qb", "rb", "wr"];
      const points: Record<string, number> = {};
      const doublePickPositions: string[] = [];

      for (const pos of positions) {
        const playerId = pick[`${pos}PlayerId`];
        const gameId = pick[`${pos}GameId`];
        if (!playerId || !gameId) {
          points[pos] = 0;
          continue;
        }

        // Check for double pick (one-and-done rule)
        const usageRef = db
          .collection("users")
          .doc(userId)
          .collection("playerUsage")
          .doc(`${SEASON}_${playerId}`);

        const usageSnap = await usageRef.get();
        const usageData = usageSnap.data();
        const isDoublePick = usageSnap.exists && usageData?.firstUsedWeek !== weekId;

        if (isDoublePick) {
          points[pos] = 0;
          doublePickPositions.push(pos.toUpperCase());
          continue;
        }

        // Fetch stats for this player's game
        const statsArray = await fetchEventStats(gameId);
        // Find this player's stats in the array
        const playerStat = statsArray.find(s => s.idPlayer === playerId);

        if (!playerStat) {
          // Game might not be finished yet or no stats
          points[pos] = 0;
          continue;
        }

        const dkStats = mapSportsDbToStats(playerStat);
        points[pos] = calculateDraftKingsPoints(dkStats);

        // Write usage if first time using this player
        if (!usageSnap.exists) {
          batch.set(usageRef, {
            season: SEASON,
            playerId,
            firstUsedWeek: weekId,
          });
        }
      }

      const totalPoints = (points.qb ?? 0) + (points.rb ?? 0) + (points.wr ?? 0);

      const scoreRef = db
        .collection("leagues")
        .doc(leagueId)
        .collection("weeks")
        .doc(weekId)
        .collection("scores")
        .doc(userId);

      batch.set(scoreRef, {
        qbPoints: points.qb ?? 0,
        rbPoints: points.rb ?? 0,
        wrPoints: points.wr ?? 0,
        totalPoints,
        doublePickPositions,
        updatedAt: new Date(),
      });

      await batch.commit();
    }

    // Mark week as final
    await weekRef.set({ status: "final" }, { merge: true });

    sendSuccess(res, { ok: true, scored: picksSnap.size });
  } catch (err: unknown) {
    console.error(err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Submit picks for a user (with auth verification and position validation)
 */
export const submitPicks = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  if (req.method !== "POST") {
    sendError(res, 405, "POST only");
    return;
  }

  // Verify Firebase Auth token - REQUIRED
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith("Bearer ")) {
    sendError(res, 401, "Authentication required");
    return;
  }

  let authUserId: string;
  try {
    const token = authHeader.slice(7);
    const decoded = await admin.auth().verifyIdToken(token);
    authUserId = decoded.uid;
  } catch {
    sendError(res, 401, "Invalid authentication token");
    return;
  }

  const { leagueId, weekId, picks } = req.body as {
    leagueId: string;
    weekId: string;
    picks: {
      qbPlayerId?: string;
      qbGameId?: string;
      rbPlayerId?: string;
      rbGameId?: string;
      wrPlayerId?: string;
      wrGameId?: string;
    };
  };

  if (!leagueId || !weekId) {
    sendError(res, 400, "leagueId and weekId required");
    return;
  }

  // Use authenticated user ID
  const userId = authUserId;

  const positions: ("qb" | "rb" | "wr")[] = ["qb", "rb", "wr"];
  const positionMap: Record<string, EligiblePosition> = { qb: "QB", rb: "RB", wr: "WR" };
  const skipped: string[] = [];
  const accepted: string[] = [];

  try {
    const pickRef = db
      .collection("leagues")
      .doc(leagueId)
      .collection("weeks")
      .doc(weekId)
      .collection("picks")
      .doc(userId);

    const existing = await pickRef.get();
    const existingData = existing.data() || {};

    const updates: Record<string, unknown> = { updatedAt: new Date() };

    for (const pos of positions) {
      const playerIdKey = `${pos}PlayerId` as const;
      const gameIdKey = `${pos}GameId` as const;
      const lockedKey = `${pos}Locked` as const;

      const newPlayerId = (picks as Record<string, string>)[playerIdKey];
      const newGameId = (picks as Record<string, string>)[gameIdKey];

      // If no new pick given for this position, skip
      if (!newPlayerId || !newGameId) continue;

      // Check if already locked
      if (existingData[lockedKey]) {
        skipped.push(`${pos.toUpperCase()}: already locked`);
        continue;
      }

      // Validate player exists and has correct eligibility
      const playerDoc = await db.collection("players").doc(newPlayerId).get();
      const player = playerDoc.data();

      if (!player) {
        skipped.push(`${pos.toUpperCase()}: unknown player`);
        continue;
      }

      const eligiblePositions = player.eligiblePositions as string[] || [];
      if (!eligiblePositions.includes(positionMap[pos])) {
        skipped.push(`${pos.toUpperCase()}: player not eligible for this position`);
        continue;
      }

      // Check if player was already used in a different week (one-and-done rule)
      const usageRef = db
        .collection("users")
        .doc(userId)
        .collection("playerUsage")
        .doc(`${SEASON}_${newPlayerId}`);
      const usageSnap = await usageRef.get();

      if (usageSnap.exists) {
        const usageData = usageSnap.data();
        if (usageData?.firstUsedWeek !== weekId) {
          skipped.push(`${pos.toUpperCase()}: player already used in ${usageData?.firstUsedWeek}`);
          continue;
        }
      }

      // Enforce kickoff - 1 hour rule
      const gameDoc = await db.collection("games").doc(newGameId).get();
      const game = gameDoc.data();
      if (!game) {
        skipped.push(`${pos.toUpperCase()}: unknown game`);
        continue;
      }

      const kickoffTime = (game.kickoffTime as admin.firestore.Timestamp).toDate().getTime();
      const now = Date.now();
      const oneHour = 60 * 60 * 1000;

      if (now > kickoffTime - oneHour) {
        skipped.push(`${pos.toUpperCase()}: game locks in < 1 hour`);
        continue;
      }

      updates[playerIdKey] = newPlayerId;
      updates[gameIdKey] = newGameId;
      accepted.push(pos.toUpperCase());

      // Write player usage immediately when pick is saved (if not already recorded for this week)
      if (!usageSnap.exists) {
        await usageRef.set({
          season: SEASON,
          playerId: newPlayerId,
          firstUsedWeek: weekId,
        });
      }
    }

    await pickRef.set(
      {
        ...existingData,
        ...updates,
        qbLocked: existingData.qbLocked || false,
        rbLocked: existingData.rbLocked || false,
        wrLocked: existingData.wrLocked || false,
        createdAt: existing.exists ? existingData.createdAt : new Date()
      },
      { merge: true }
    );

    sendSuccess(res, { ok: true, accepted, skipped });
  } catch (err: unknown) {
    console.error(err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Lock picks for games starting within 1 hour
 * Runs every 5 minutes
 */
export const lockPicks = onSchedule("*/5 * * * *", async () => {
  const now = Date.now();
  const oneHour = 60 * 60 * 1000;
  const lockThreshold = now + oneHour;

  // Find games that are about to start (within 1 hour)
  const gamesSnap = await db
    .collection("games")
    .where("kickoffTime", "<=", new Date(lockThreshold))
    .where("kickoffTime", ">", new Date(now - oneHour)) // Not too old
    .get();

  const gameIdsToLock = new Set(gamesSnap.docs.map(d => d.id));
  if (gameIdsToLock.size === 0) {
    console.log("No games to lock");
    return;
  }

  console.log(`Locking picks for ${gameIdsToLock.size} games`);

  // Get all leagues
  const leaguesSnap = await db.collection("leagues").get();

  for (const leagueDoc of leaguesSnap.docs) {
    const leagueId = leagueDoc.id;

    // Get all weeks
    const weeksSnap = await db
      .collection("leagues")
      .doc(leagueId)
      .collection("weeks")
      .where("status", "==", "pending")
      .get();

    for (const weekDoc of weeksSnap.docs) {
      const weekId = weekDoc.id;

      // Get all picks for this week
      const picksSnap = await db
        .collection("leagues")
        .doc(leagueId)
        .collection("weeks")
        .doc(weekId)
        .collection("picks")
        .get();

      for (const pickDoc of picksSnap.docs) {
        const pick = pickDoc.data();
        const updates: Record<string, boolean> = {};

        if (pick.qbGameId && gameIdsToLock.has(pick.qbGameId) && !pick.qbLocked) {
          updates.qbLocked = true;
        }
        if (pick.rbGameId && gameIdsToLock.has(pick.rbGameId) && !pick.rbLocked) {
          updates.rbLocked = true;
        }
        if (pick.wrGameId && gameIdsToLock.has(pick.wrGameId) && !pick.wrLocked) {
          updates.wrLocked = true;
        }

        if (Object.keys(updates).length > 0) {
          await pickDoc.ref.update(updates);
          console.log(`Locked ${Object.keys(updates).join(", ")} for user ${pickDoc.id}`);
        }
      }
    }
  }
});

/**
 * Compute season standings for a league
 */
export const computeSeasonStandings = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  // Verify admin key
  if (!verifyAdminKey(req.headers["x-admin-key"] as string)) {
    sendError(res, 403, "Admin access required");
    return;
  }

  const leagueId = (req.query.leagueId || req.body?.leagueId) as string;
  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  try {
    // Get all weeks
    const weeksSnap = await db
      .collection("leagues")
      .doc(leagueId)
      .collection("weeks")
      .get();

    // Aggregate scores per user
    const userTotals: Record<string, {
      total: number;
      weeks: number;
      bestWeekPoints: number;
      bestWeek: string;
    }> = {};

    for (const weekDoc of weeksSnap.docs) {
      const weekId = weekDoc.id;
      const scoresSnap = await db
        .collection("leagues")
        .doc(leagueId)
        .collection("weeks")
        .doc(weekId)
        .collection("scores")
        .get();

      for (const scoreDoc of scoresSnap.docs) {
        const userId = scoreDoc.id;
        const score = scoreDoc.data();
        const totalPoints = score.totalPoints || 0;

        if (!userTotals[userId]) {
          userTotals[userId] = { total: 0, weeks: 0, bestWeekPoints: 0, bestWeek: "" };
        }

        userTotals[userId].total += totalPoints;
        userTotals[userId].weeks += 1;

        if (totalPoints > userTotals[userId].bestWeekPoints) {
          userTotals[userId].bestWeekPoints = totalPoints;
          userTotals[userId].bestWeek = weekId;
        }
      }
    }

    // Get user display names
    const userIds = Object.keys(userTotals);
    const userDocs = await Promise.all(
      userIds.map(uid => db.collection("users").doc(uid).get())
    );
    const userNames: Record<string, string> = {};
    userDocs.forEach(doc => {
      if (doc.exists) {
        userNames[doc.id] = doc.data()?.displayName || doc.id;
      }
    });

    // Write season standings
    const batch = db.batch();
    for (const [userId, data] of Object.entries(userTotals)) {
      const standingRef = db
        .collection("leagues")
        .doc(leagueId)
        .collection("seasonStandings")
        .doc(userId);

      batch.set(standingRef, {
        userId,
        displayName: userNames[userId] || userId,
        seasonTotalPoints: data.total,
        weeksPlayed: data.weeks,
        bestWeekPoints: data.bestWeekPoints,
        bestWeek: data.bestWeek,
        updatedAt: new Date(),
      });
    }

    await batch.commit();
    sendSuccess(res, { ok: true, users: userIds.length });
  } catch (err: unknown) {
    console.error(err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Initialize a league with weeks for the NFL season
 * Protected by admin API key.
 */
export const initializeLeague = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  // Verify admin key
  if (!verifyAdminKey(req.headers["x-admin-key"] as string)) {
    sendError(res, 403, "Admin access required");
    return;
  }

  const leagueId = (req.query.leagueId || req.body?.leagueId) as string;
  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  try {
    const leagueRef = db.collection("leagues").doc(leagueId);
    const leagueDoc = await leagueRef.get();

    if (!leagueDoc.exists) {
      // Create the league
      await leagueRef.set({
        name: "Three Man League",
        season: SEASON,
        entryFee: 50,
        payouts: { "1": 1200, "2": 750, "3": 500, "4": 415, "5": 270, "6": 195, "7": 120 },
        createdAt: new Date(),
      });
    }

    // Create weeks 1-18
    const batch = db.batch();
    for (let w = 1; w <= 18; w++) {
      const weekRef = leagueRef.collection("weeks").doc(`week-${w}`);
      batch.set(weekRef, {
        weekNumber: w,
        status: "pending",
      }, { merge: true });
    }

    await batch.commit();
    sendSuccess(res, { ok: true, leagueId });
  } catch (err: unknown) {
    console.error(err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});


========================================
FILE: functions/src/leagueManagement.ts
========================================

/**
 * League Management Cloud Functions
 *
 * Handles league creation, joining, settings management, and member operations.
 */

import { onRequest } from "firebase-functions/v2/https";
import { db, SEASON } from "./config.js";
import { setCors, verifyAuth, handlePreflight, sendError, sendSuccess } from "./utils/http.js";
import type {
  CreateLeagueRequest,
  CreateLeagueResponse,
  JoinLeagueRequest,
  JoinLeagueResponse,
  LeagueSummary,
  PublicLeagueSummary,
  PayoutEntry,
  LeagueStatus,
  MemberRole,
} from "./types.js";

// Generate a unique join code (6 uppercase alphanumeric characters)
function generateJoinCode(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // Excluded I, O, 0, 1 for clarity
  let code = "";
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Check if a join code is already in use
async function isJoinCodeTaken(code: string): Promise<boolean> {
  const snap = await db.collection("leagues")
    .where("joinCode", "==", code)
    .where("status", "in", ["preseason", "active"])
    .limit(1)
    .get();
  return !snap.empty;
}

// Generate a unique join code with collision checking
async function generateUniqueJoinCode(): Promise<string> {
  let attempts = 0;
  const maxAttempts = 10;
  
  while (attempts < maxAttempts) {
    const code = generateJoinCode();
    if (!(await isJoinCodeTaken(code))) {
      return code;
    }
    attempts++;
  }
  
  // Fallback to longer code if we can't find a unique short one
  return generateJoinCode() + generateJoinCode().slice(0, 2);
}

/**
 * Create a new league
 */
export const createLeague = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { name, entryFee, maxPlayers, payoutStructure, season } = req.body as CreateLeagueRequest;

  // Validation
  if (!name || typeof name !== "string" || name.trim().length < 2) {
    sendError(res, 400, "League name must be at least 2 characters");
    return;
  }

  if (name.length > 50) {
    sendError(res, 400, "League name must be 50 characters or less");
    return;
  }

  if (entryFee !== undefined && (typeof entryFee !== "number" || entryFee < 0)) {
    sendError(res, 400, "Entry fee must be a non-negative number");
    return;
  }

  if (maxPlayers !== undefined && (typeof maxPlayers !== "number" || maxPlayers < 2 || maxPlayers > 100)) {
    sendError(res, 400, "Max players must be between 2 and 100");
    return;
  }

  try {
    // Get user info for denormalization
    const userDoc = await db.collection("users").doc(userId).get();
    const userData = userDoc.data() || {};
    const userDisplayName = userData.displayName || "Unknown";
    const userEmail = userData.email || "";

    // Generate unique join code
    const joinCode = await generateUniqueJoinCode();
    const leagueId = db.collection("leagues").doc().id;
    const baseUrl = req.headers.origin || "https://three-man-league.web.app";
    const joinLink = `${baseUrl}/join?code=${joinCode}`;

    // Normalize payout structure
    let normalizedPayouts: Record<string, number> = {};
    let payoutTotal = 0;

    if (payoutStructure && Array.isArray(payoutStructure)) {
      for (const p of payoutStructure) {
        if (p.rank && p.amount >= 0) {
          normalizedPayouts[String(p.rank)] = p.amount;
          payoutTotal += p.amount;
        }
      }
    } else {
      // Default payout structure
      normalizedPayouts = { "1": 0 };
    }

    const now = new Date();
    const leagueSeason = season || SEASON;

    // Create league document - public by default
    await db.collection("leagues").doc(leagueId).set({
      name: name.trim(),
      ownerId: userId,
      season: leagueSeason,
      entryFee: entryFee || 0,
      payouts: normalizedPayouts,
      payoutStructure: payoutStructure || [{ rank: 1, amount: 0 }],
      payoutTotal,
      maxPlayers: maxPlayers || null,
      joinCode,
      joinLink,
      status: "preseason" as LeagueStatus,
      membershipLocked: false,
      isPublic: true, // Public by default
      createdAt: now,
      updatedAt: now,
    });

    // Add owner as first member
    await db.collection("leagues").doc(leagueId).collection("members").doc(userId).set({
      userId,
      displayName: userDisplayName,
      email: userEmail,
      role: "owner" as MemberRole,
      joinedAt: now,
      isActive: true,
    });

    // Initialize 18 weeks for the league
    const batch = db.batch();
    for (let w = 1; w <= 18; w++) {
      const weekRef = db.collection("leagues").doc(leagueId).collection("weeks").doc(`week-${w}`);
      batch.set(weekRef, {
        weekNumber: w,
        status: "pending",
      });
    }
    await batch.commit();

    const response: CreateLeagueResponse = {
      ok: true,
      leagueId,
      joinCode,
      joinLink,
    };

    sendSuccess(res, response);
  } catch (err: unknown) {
    console.error("Create league error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Join a league - public leagues can be joined directly, private leagues require a passcode
 */
export const joinLeague = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { joinCode, leagueId: providedLeagueId, passcode } = req.body as JoinLeagueRequest;

  // Need either a leagueId or a joinCode
  if (!providedLeagueId && !joinCode) {
    sendError(res, 400, "Either leagueId or joinCode required");
    return;
  }

  try {
    let leagueId = providedLeagueId;
    let leagueData: FirebaseFirestore.DocumentData | undefined;

    if (providedLeagueId) {
      // Join by leagueId directly (for public leagues shown in list)
      const leagueDoc = await db.collection("leagues").doc(providedLeagueId).get();
      if (leagueDoc.exists) {
        leagueId = providedLeagueId;
        leagueData = leagueDoc.data();
      }
    }

    if (!leagueData && joinCode) {
      // Search by join code (for private leagues or direct code entry)
      const normalizedCode = joinCode.toUpperCase().trim();
      const snap = await db.collection("leagues")
        .where("joinCode", "==", normalizedCode)
        .where("status", "in", ["preseason", "active"])
        .limit(1)
        .get();

      if (!snap.empty) {
        const doc = snap.docs[0];
        leagueId = doc.id;
        leagueData = doc.data();
      }
    }

    if (!leagueData || !leagueId) {
      sendError(res, 404, "Invalid join code or league not found");
      return;
    }

    // Check if league is accepting members
    if (leagueData.membershipLocked) {
      sendError(res, 403, "This league is no longer accepting new members");
      return;
    }

    if (leagueData.status === "completed" || leagueData.status === "archived") {
      sendError(res, 403, "This league has ended");
      return;
    }

    // For private leagues, verify passcode
    if (!leagueData.isPublic) {
      if (!passcode) {
        sendError(res, 400, "Passcode required for private leagues");
        return;
      }
      if (passcode !== leagueData.passcode) {
        sendError(res, 403, "Invalid passcode");
        return;
      }
    }

    // Check if already a member
    const memberDoc = await db.collection("leagues").doc(leagueId).collection("members").doc(userId).get();
    if (memberDoc.exists && memberDoc.data()?.isActive) {
      sendError(res, 400, "You are already a member of this league");
      return;
    }

    // Check max players limit
    if (leagueData.maxPlayers) {
      const membersSnap = await db.collection("leagues").doc(leagueId)
        .collection("members")
        .where("isActive", "==", true)
        .count()
        .get();

      if (membersSnap.data().count >= leagueData.maxPlayers) {
        sendError(res, 403, "This league is full");
        return;
      }
    }

    // Get user info
    const userDoc = await db.collection("users").doc(userId).get();
    const userData = userDoc.data() || {};

    const now = new Date();

    // Add or reactivate membership
    await db.collection("leagues").doc(leagueId).collection("members").doc(userId).set({
      userId,
      displayName: userData.displayName || "Unknown",
      email: userData.email || "",
      role: "member" as MemberRole,
      joinedAt: now,
      isActive: true,
    }, { merge: true });

    const response: JoinLeagueResponse = {
      ok: true,
      leagueId,
      leagueName: leagueData.name,
    };

    sendSuccess(res, response);
  } catch (err: unknown) {
    console.error("Join league error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Get all leagues for the current user
 */
export const getUserLeagues = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  try {
    // Get all leagues where user is a member
    const leaguesSnap = await db.collection("leagues").get();
    const userLeagues: LeagueSummary[] = [];

    for (const leagueDoc of leaguesSnap.docs) {
      const memberDoc = await db.collection("leagues").doc(leagueDoc.id)
        .collection("members")
        .doc(userId)
        .get();

      if (memberDoc.exists && memberDoc.data()?.isActive) {
        const leagueData = leagueDoc.data();
        const memberData = memberDoc.data();

        // Get member count
        const membersSnap = await db.collection("leagues").doc(leagueDoc.id)
          .collection("members")
          .where("isActive", "==", true)
          .count()
          .get();

        userLeagues.push({
          id: leagueDoc.id,
          name: leagueData.name,
          season: leagueData.season,
          memberCount: membersSnap.data().count,
          role: memberData?.role || "member",
          status: leagueData.status,
          entryFee: leagueData.entryFee || 0,
          isPublic: leagueData.isPublic ?? true, // Default to true for backwards compatibility
        });
      }
    }

    // Sort by most recent first (could also sort by name)
    userLeagues.sort((a, b) => a.name.localeCompare(b.name));

    sendSuccess(res, { ok: true, leagues: userLeagues });
  } catch (err: unknown) {
    console.error("Get user leagues error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Get all available leagues (public leagues the user is not a member of)
 */
export const getAvailableLeagues = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  try {
    // Get all leagues that are accepting members
    // Note: We query by status first, then filter isPublic in code
    // because existing leagues may not have isPublic field (defaults to true)
    const leaguesSnap = await db.collection("leagues")
      .where("status", "in", ["preseason", "active"])
      .get();

    const availableLeagues: PublicLeagueSummary[] = [];

    for (const leagueDoc of leaguesSnap.docs) {
      const leagueData = leagueDoc.data();

      // Skip private leagues (default is public if isPublic is undefined)
      if (leagueData.isPublic === false) continue;

      // Skip if membership is locked
      if (leagueData.membershipLocked) continue;

      // Check if user is already a member
      const memberDoc = await db.collection("leagues").doc(leagueDoc.id)
        .collection("members")
        .doc(userId)
        .get();

      if (memberDoc.exists && memberDoc.data()?.isActive) {
        // User is already a member, skip
        continue;
      }

      // Get member count
      const membersSnap = await db.collection("leagues").doc(leagueDoc.id)
        .collection("members")
        .where("isActive", "==", true)
        .count()
        .get();

      const memberCount = membersSnap.data().count;

      // Skip if league is full
      if (leagueData.maxPlayers && memberCount >= leagueData.maxPlayers) {
        continue;
      }

      availableLeagues.push({
        id: leagueDoc.id,
        name: leagueData.name,
        season: leagueData.season,
        memberCount,
        maxPlayers: leagueData.maxPlayers || undefined,
        status: leagueData.status,
        entryFee: leagueData.entryFee || 0,
        isPublic: true,
      });
    }

    // Sort by name
    availableLeagues.sort((a, b) => a.name.localeCompare(b.name));

    sendSuccess(res, { ok: true, leagues: availableLeagues });
  } catch (err: unknown) {
    console.error("Get available leagues error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Get league details including members
 */
export const getLeagueDetails = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const leagueId = (req.query.leagueId || req.body?.leagueId) as string;
  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  try {
    // Verify user is a member
    const memberDoc = await db.collection("leagues").doc(leagueId)
      .collection("members").doc(userId).get();

    if (!memberDoc.exists || !memberDoc.data()?.isActive) {
      sendError(res, 403, "You are not a member of this league");
      return;
    }

    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) {
      sendError(res, 404, "League not found");
      return;
    }

    const leagueData = leagueDoc.data()!;
    const isOwner = leagueData.ownerId === userId;

    // Get all active members
    const membersSnap = await db.collection("leagues").doc(leagueId)
      .collection("members")
      .where("isActive", "==", true)
      .get();

    const members = membersSnap.docs.map(doc => ({
      userId: doc.id,
      ...doc.data(),
    }));

    sendSuccess(res, {
      ok: true,
      league: {
        id: leagueDoc.id,
        ...leagueData,
        // Only include sensitive info for owner
        joinCode: isOwner ? leagueData.joinCode : undefined,
        joinLink: isOwner ? leagueData.joinLink : undefined,
      },
      members,
      isOwner,
    });
  } catch (err: unknown) {
    console.error("Get league details error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Update league settings (owner only)
 */
export const updateLeagueSettings = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId, name, entryFee, payoutStructure, maxPlayers, membershipLocked, isPublic, passcode } = req.body as {
    leagueId: string;
    name?: string;
    entryFee?: number;
    payoutStructure?: PayoutEntry[];
    maxPlayers?: number;
    membershipLocked?: boolean;
    isPublic?: boolean;
    passcode?: string;
  };

  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  try {
    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) {
      sendError(res, 404, "League not found");
      return;
    }

    const leagueData = leagueDoc.data()!;

    // Only owner can update
    if (leagueData.ownerId !== userId) {
      sendError(res, 403, "Only the league owner can update settings");
      return;
    }

    const updates: Record<string, unknown> = { updatedAt: new Date() };

    // Name update
    if (name !== undefined) {
      if (typeof name !== "string" || name.trim().length < 2 || name.length > 50) {
        sendError(res, 400, "League name must be 2-50 characters");
        return;
      }
      updates.name = name.trim();
    }

    // Entry fee update (only in preseason)
    if (entryFee !== undefined) {
      if (leagueData.status !== "preseason") {
        sendError(res, 400, "Cannot change entry fee after season starts");
        return;
      }
      if (typeof entryFee !== "number" || entryFee < 0) {
        sendError(res, 400, "Entry fee must be a non-negative number");
        return;
      }
      updates.entryFee = entryFee;
    }

    // Payout structure update (only in preseason)
    if (payoutStructure !== undefined) {
      if (leagueData.status !== "preseason") {
        sendError(res, 400, "Cannot change payouts after season starts");
        return;
      }

      const normalizedPayouts: Record<string, number> = {};
      let payoutTotal = 0;

      for (const p of payoutStructure) {
        if (p.rank && p.amount >= 0) {
          normalizedPayouts[String(p.rank)] = p.amount;
          payoutTotal += p.amount;
        }
      }

      updates.payoutStructure = payoutStructure;
      updates.payouts = normalizedPayouts;
      updates.payoutTotal = payoutTotal;
    }

    // Max players update
    if (maxPlayers !== undefined) {
      if (typeof maxPlayers !== "number" || maxPlayers < 2 || maxPlayers > 100) {
        sendError(res, 400, "Max players must be between 2 and 100");
        return;
      }
      updates.maxPlayers = maxPlayers;
    }

    // Membership lock update
    if (membershipLocked !== undefined) {
      updates.membershipLocked = Boolean(membershipLocked);
    }

    // Public/private update
    if (isPublic !== undefined) {
      updates.isPublic = Boolean(isPublic);
      // If making private, require a passcode to be set (now or previously)
      if (!isPublic && !passcode && !leagueData.passcode) {
        sendError(res, 400, "Passcode required when making league private");
        return;
      }
    }

    // Passcode update (only relevant for private leagues)
    if (passcode !== undefined) {
      if (passcode.length < 4 || passcode.length > 20) {
        sendError(res, 400, "Passcode must be 4-20 characters");
        return;
      }
      updates.passcode = passcode;
    }

    await db.collection("leagues").doc(leagueId).update(updates);

    sendSuccess(res, { ok: true });
  } catch (err: unknown) {
    console.error("Update league settings error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Regenerate join code (owner only)
 */
export const regenerateJoinCode = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId } = req.body as { leagueId: string };

  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  try {
    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) {
      sendError(res, 404, "League not found");
      return;
    }

    const leagueData = leagueDoc.data()!;

    if (leagueData.ownerId !== userId) {
      sendError(res, 403, "Only the league owner can regenerate the join code");
      return;
    }

    const newJoinCode = await generateUniqueJoinCode();
    const baseUrl = req.headers.origin || "https://three-man-league.web.app";
    const joinLink = `${baseUrl}/join?code=${newJoinCode}`;

    await db.collection("leagues").doc(leagueId).update({
      joinCode: newJoinCode,
      joinLink,
      updatedAt: new Date(),
    });

    sendSuccess(res, { ok: true, joinCode: newJoinCode, joinLink });
  } catch (err: unknown) {
    console.error("Regenerate join code error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Remove a member from the league (owner only) or leave league (self)
 */
export const leaveOrRemoveMember = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId, targetUserId } = req.body as { leagueId: string; targetUserId: string };

  if (!leagueId || !targetUserId) {
    sendError(res, 400, "leagueId and targetUserId required");
    return;
  }

  try {
    const leagueDoc = await db.collection("leagues").doc(leagueId).get();
    if (!leagueDoc.exists) {
      sendError(res, 404, "League not found");
      return;
    }

    const leagueData = leagueDoc.data()!;
    const isOwner = leagueData.ownerId === userId;
    const isSelf = userId === targetUserId;

    // Can only remove others if owner, or remove self
    if (!isSelf && !isOwner) {
      sendError(res, 403, "Only the league owner can remove members");
      return;
    }

    // Cannot remove the owner
    if (targetUserId === leagueData.ownerId) {
      sendError(res, 400, "Cannot remove the league owner. Transfer ownership first.");
      return;
    }

    // Soft delete the membership
    await db.collection("leagues").doc(leagueId)
      .collection("members").doc(targetUserId)
      .update({ isActive: false });

    sendSuccess(res, { ok: true });
  } catch (err: unknown) {
    console.error("Leave/remove member error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});

/**
 * Set user's active league
 */
export const setActiveLeague = onRequest(async (req, res) => {
  setCors(res);
  if (handlePreflight(req.method, res)) return;
  if (req.method !== "POST") { sendError(res, 405, "POST only"); return; }

  const userId = await verifyAuth(req.headers.authorization);
  if (!userId) {
    sendError(res, 401, "Authentication required");
    return;
  }

  const { leagueId } = req.body as { leagueId: string };

  if (!leagueId) {
    sendError(res, 400, "leagueId required");
    return;
  }

  try {
    // Verify user is a member of this league
    const memberDoc = await db.collection("leagues").doc(leagueId)
      .collection("members").doc(userId).get();

    if (!memberDoc.exists || !memberDoc.data()?.isActive) {
      sendError(res, 403, "You are not a member of this league");
      return;
    }

    // Update user's active league
    await db.collection("users").doc(userId).set({
      activeLeagueId: leagueId,
      updatedAt: new Date(),
    }, { merge: true });

    sendSuccess(res, { ok: true });
  } catch (err: unknown) {
    console.error("Set active league error:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    sendError(res, 500, errorMessage);
  }
});



========================================
FILE: functions/src/scoring.test.ts
========================================

import { calculateDraftKingsPoints, emptyStats, type PlayerGameStats } from "./scoring.js";

describe("calculateDraftKingsPoints", () => {
  it("returns 0 for empty stats", () => {
    const stats = emptyStats();
    expect(calculateDraftKingsPoints(stats)).toBe(0);
  });

  it("calculates passing yards correctly (0.04 per yard)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      passingYards: 250,
    };
    // 250 * 0.04 = 10
    expect(calculateDraftKingsPoints(stats)).toBe(10);
  });

  it("adds 300+ passing yard bonus", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      passingYards: 300,
    };
    // 300 * 0.04 = 12 + 3 bonus = 15
    expect(calculateDraftKingsPoints(stats)).toBe(15);
  });

  it("calculates passing TDs correctly (4 pts each)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      passingTD: 3,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(12);
  });

  it("calculates rushing yards correctly (0.1 per yard)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      rushingYards: 80,
    };
    // 80 * 0.1 = 8
    expect(calculateDraftKingsPoints(stats)).toBe(8);
  });

  it("adds 100+ rushing yard bonus", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      rushingYards: 100,
    };
    // 100 * 0.1 = 10 + 3 bonus = 13
    expect(calculateDraftKingsPoints(stats)).toBe(13);
  });

  it("calculates rushing TDs correctly (6 pts each)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      rushingTD: 2,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(12);
  });

  it("calculates receiving yards correctly (0.1 per yard)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      receivingYards: 75,
    };
    // 75 * 0.1 = 7.5
    expect(calculateDraftKingsPoints(stats)).toBe(7.5);
  });

  it("adds 100+ receiving yard bonus", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      receivingYards: 120,
    };
    // 120 * 0.1 = 12 + 3 bonus = 15
    expect(calculateDraftKingsPoints(stats)).toBe(15);
  });

  it("calculates receiving TDs correctly (6 pts each)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      receivingTD: 1,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(6);
  });

  it("calculates receptions correctly (1 pt each - PPR)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      receptions: 8,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(8);
  });

  it("deducts interceptions correctly (-1 pt each)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      interceptions: 2,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(-2);
  });

  it("deducts fumbles lost correctly (-1 pt each)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      fumblesLost: 1,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(-1);
  });

  it("calculates 2-pt conversions correctly (2 pts each)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      twoPtConversions: 1,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(2);
  });

  it("calculates offensive fumble recovery TD correctly (6 pts)", () => {
    const stats: PlayerGameStats = {
      ...emptyStats(),
      offensiveFumbleRecoveryTD: 1,
    };
    expect(calculateDraftKingsPoints(stats)).toBe(6);
  });

  it("calculates a realistic QB game correctly", () => {
    // Patrick Mahomes-style game
    const stats: PlayerGameStats = {
      passingYards: 325,
      passingTD: 3,
      interceptions: 1,
      rushingYards: 25,
      rushingTD: 0,
      receivingYards: 0,
      receivingTD: 0,
      receptions: 0,
      fumblesLost: 0,
      twoPtConversions: 0,
      offensiveFumbleRecoveryTD: 0,
    };
    // 325 * 0.04 = 13 + 3 (300+ bonus) + 12 (3 TDs) - 1 (INT) + 2.5 (25 rush) = 29.5
    expect(calculateDraftKingsPoints(stats)).toBe(29.5);
  });

  it("calculates a realistic RB game correctly", () => {
    // Derrick Henry-style game
    const stats: PlayerGameStats = {
      passingYards: 0,
      passingTD: 0,
      interceptions: 0,
      rushingYards: 145,
      rushingTD: 2,
      receivingYards: 22,
      receivingTD: 0,
      receptions: 3,
      fumblesLost: 0,
      twoPtConversions: 0,
      offensiveFumbleRecoveryTD: 0,
    };
    // 14.5 (rush yds) + 3 (100+ bonus) + 12 (2 TDs) + 2.2 (rec yds) + 3 (receptions) = 34.7
    expect(calculateDraftKingsPoints(stats)).toBe(34.7);
  });
});



========================================
FILE: functions/src/scoring.ts
========================================

import type { SportsPlayerStats } from "./sportsApi.js";

export interface PlayerGameStats {
  passingYards: number;
  passingTD: number;
  interceptions: number;
  rushingYards: number;
  rushingTD: number;
  receivingYards: number;
  receivingTD: number;
  receptions: number;
  fumblesLost: number;
  twoPtConversions: number;
  offensiveFumbleRecoveryTD: number;
}

/**
 * Calculate DraftKings NFL scoring
 *
 * Scoring rules:
 * - Passing TD: 4 pts
 * - 25 Passing Yards: 1 pt (= 0.04 per yard)
 * - 300+ Pass Yards game: +3 pts bonus
 * - Interception: -1 pt
 * - Rushing TD: 6 pts
 * - 10 Rushing Yards: 1 pt (= 0.1 per yard)
 * - 100+ Rush Yards game: +3 pts bonus
 * - Receiving TD: 6 pts
 * - 10 Receiving Yards: 1 pt (= 0.1 per yard)
 * - 100+ Rec Yards game: +3 pts bonus
 * - Reception: 1 pt (PPR)
 * - Fumble Lost: -1 pt
 * - 2-pt Conversion: 2 pts
 * - Offensive Fumble Recovery TD: 6 pts
 */
export function calculateDraftKingsPoints(stats: PlayerGameStats): number {
  let pts = 0;

  // Passing
  pts += 4 * stats.passingTD;
  pts += 0.04 * stats.passingYards;
  if (stats.passingYards >= 300) pts += 3;

  // Rushing
  pts += 6 * stats.rushingTD;
  pts += 0.1 * stats.rushingYards;
  if (stats.rushingYards >= 100) pts += 3;

  // Receiving
  pts += 6 * stats.receivingTD;
  pts += 0.1 * stats.receivingYards;
  if (stats.receivingYards >= 100) pts += 3;

  // PPR
  pts += stats.receptions;

  // Turnovers
  pts -= stats.interceptions;
  pts -= stats.fumblesLost;

  // Bonuses
  pts += 2 * stats.twoPtConversions;
  pts += 6 * stats.offensiveFumbleRecoveryTD;

  // Round to 2 decimal places
  return Math.round(pts * 100) / 100;
}

/**
 * Map ESPN API player stats to our PlayerGameStats interface
 * ESPN API returns stats with proper field names already
 */
export function mapSportsDbToStats(rawStats: SportsPlayerStats): PlayerGameStats {
  return {
    passingYards: rawStats.passingYards || 0,
    passingTD: rawStats.passingTouchdowns || 0,
    interceptions: rawStats.interceptions || 0,
    rushingYards: rawStats.rushingYards || 0,
    rushingTD: rawStats.rushingTouchdowns || 0,
    receivingYards: rawStats.receivingYards || 0,
    receivingTD: rawStats.receivingTouchdowns || 0,
    receptions: rawStats.receptions || 0,
    fumblesLost: rawStats.fumblesLost || 0,
    twoPtConversions: rawStats.twoPtConversions || 0,
    offensiveFumbleRecoveryTD: 0, // Rarely available in free APIs
  };
}

/**
 * Create empty stats (for testing or when no data available)
 */
export function emptyStats(): PlayerGameStats {
  return {
    passingYards: 0,
    passingTD: 0,
    interceptions: 0,
    rushingYards: 0,
    rushingTD: 0,
    receivingYards: 0,
    receivingTD: 0,
    receptions: 0,
    fumblesLost: 0,
    twoPtConversions: 0,
    offensiveFumbleRecoveryTD: 0,
  };
}



========================================
FILE: functions/src/sportsApi.ts
========================================

import fetch from "node-fetch";
import { SEASON, ESPN_SITE_API, ESPN_CORE_API } from "./config.js";

/**
 * ESPN NFL API Integration
 *
 * ESPN provides a free, undocumented API with comprehensive NFL data.
 * No API key required. Endpoints used:
 * - Scoreboard: Schedule and game status
 * - Teams: All 32 NFL teams with rosters
 * - Athletes: Player info and game stats
 * - Summary: Detailed game box scores
 */

// Retry configuration for robustness
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;

async function espnFetch<T>(url: string, retries = MAX_RETRIES): Promise<T> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const res = await fetch(url, {
        headers: {
          "Accept": "application/json",
          "User-Agent": "three-man-league/1.0",
        },
      });
      if (!res.ok) {
        throw new Error(`ESPN API error ${res.status} for ${url}`);
      }
      return (await res.json()) as T;
    } catch (err) {
      if (attempt === retries) throw err;
      console.warn(`ESPN API attempt ${attempt} failed, retrying in ${RETRY_DELAY_MS}ms...`);
      await new Promise((r) => setTimeout(r, RETRY_DELAY_MS * attempt));
    }
  }
  throw new Error("ESPN API fetch failed after retries");
}

// ===== ESPN Response Types =====

export interface ESPNTeam {
  id: string;
  abbreviation: string;
  displayName: string;
  shortDisplayName: string;
  logo?: string;
}

export interface ESPNAthlete {
  id: string;
  fullName: string;
  displayName: string;
  position: {
    abbreviation: string;
    name: string;
  };
  team?: {
    id: string;
    abbreviation: string;
    displayName: string;
  };
}

export interface ESPNEvent {
  id: string;
  name: string;
  date: string; // ISO date string
  week?: { number: number };
  season?: { year: number; type: number };
  status: {
    type: {
      name: string; // "STATUS_SCHEDULED", "STATUS_IN_PROGRESS", "STATUS_FINAL"
      completed: boolean;
    };
  };
  competitions: Array<{
    id: string;
    date: string;
    competitors: Array<{
      id: string;
      homeAway: "home" | "away";
      team: ESPNTeam;
      score?: string;
    }>;
  }>;
}

export interface ESPNScoreboardResponse {
  events: ESPNEvent[];
  week?: { number: number };
  season?: { year: number; type: number };
}

export interface ESPNTeamsResponse {
  sports: Array<{
    leagues: Array<{
      teams: Array<{ team: ESPNTeam }>;
    }>;
  }>;
}

export interface ESPNRosterAthlete {
  id: string;
  fullName: string;
  displayName: string;
  position: {
    abbreviation: string;
    name: string;
  };
  jersey?: string;
  status?: { type: { name: string } };
}

export interface ESPNRosterResponse {
  athletes: Array<{
    position: string;
    items: ESPNRosterAthlete[];
  }>;
}

// Player game statistics from box score
export interface ESPNPlayerStatistics {
  athlete: {
    id: string;
    displayName: string;
  };
  stats: string[]; // Array of stat values as strings
}

export interface ESPNBoxScoreCategory {
  name: string;
  labels: string[];
  athletes: ESPNPlayerStatistics[];
}

// ===== Normalized Types (for internal use) =====

export interface SportsEvent {
  idEvent: string;
  strEvent: string;
  dateEvent: string;
  strTime: string;
  idHomeTeam: string;
  idAwayTeam: string;
  strHomeTeam: string;
  strAwayTeam: string;
  intRound?: string;
  strStatus?: string;
}

export interface SportsTeam {
  idTeam: string;
  strTeam: string;
  strTeamShort?: string;
}

export interface SportsPlayer {
  idPlayer: string;
  strPlayer: string;
  strPosition: string;
  idTeam: string;
  strTeam?: string;
}

export interface SportsPlayerStats {
  idPlayer: string;
  strPlayer: string;
  passingYards: number;
  passingTouchdowns: number;
  interceptions: number;
  rushingYards: number;
  rushingTouchdowns: number;
  receivingYards: number;
  receivingTouchdowns: number;
  receptions: number;
  fumblesLost: number;
  twoPtConversions: number;
}


// ===== Schedule =====

/**
 * Fetch NFL season schedule from ESPN
 * Returns all games for the specified season
 */
export async function fetchSeasonSchedule(): Promise<SportsEvent[]> {
  const events: SportsEvent[] = [];

  // Fetch regular season (type 2) and postseason (type 3)
  for (const seasonType of [2, 3]) {
    try {
      const url = `${ESPN_SITE_API}/scoreboard?limit=1000&dates=${SEASON}&seasontype=${seasonType}`;
      const data = await espnFetch<ESPNScoreboardResponse>(url);

      for (const event of data.events || []) {
        const competition = event.competitions[0];
        if (!competition) continue;

        const homeTeam = competition.competitors.find((c) => c.homeAway === "home");
        const awayTeam = competition.competitors.find((c) => c.homeAway === "away");

        if (!homeTeam || !awayTeam) continue;

        const kickoffDate = new Date(event.date);

        events.push({
          idEvent: event.id,
          strEvent: event.name,
          dateEvent: kickoffDate.toISOString().split("T")[0],
          strTime: kickoffDate.toISOString().split("T")[1]?.replace("Z", "") || "00:00:00",
          idHomeTeam: homeTeam.team.id,
          idAwayTeam: awayTeam.team.id,
          strHomeTeam: homeTeam.team.displayName,
          strAwayTeam: awayTeam.team.displayName,
          intRound: event.week?.number?.toString(),
          strStatus: event.status.type.name,
        });
      }
    } catch (err) {
      console.error(`Failed to fetch season ${SEASON} type ${seasonType}:`, err);
    }
  }

  return events;
}

/**
 * Fetch games for a specific week
 */
export async function fetchWeekSchedule(weekNumber: number, seasonType = 2): Promise<SportsEvent[]> {
  const url = `${ESPN_SITE_API}/scoreboard?dates=${SEASON}&seasontype=${seasonType}&week=${weekNumber}`;
  const data = await espnFetch<ESPNScoreboardResponse>(url);

  const events: SportsEvent[] = [];

  for (const event of data.events || []) {
    const competition = event.competitions[0];
    if (!competition) continue;

    const homeTeam = competition.competitors.find((c) => c.homeAway === "home");
    const awayTeam = competition.competitors.find((c) => c.homeAway === "away");

    if (!homeTeam || !awayTeam) continue;

    const kickoffDate = new Date(event.date);

    events.push({
      idEvent: event.id,
      strEvent: event.name,
      dateEvent: kickoffDate.toISOString().split("T")[0],
      strTime: kickoffDate.toISOString().split("T")[1]?.replace("Z", "") || "00:00:00",
      idHomeTeam: homeTeam.team.id,
      idAwayTeam: awayTeam.team.id,
      strHomeTeam: homeTeam.team.displayName,
      strAwayTeam: awayTeam.team.displayName,
      intRound: weekNumber.toString(),
      strStatus: event.status.type.name,
    });
  }

  return events;
}

// ===== Teams =====

/**
 * Fetch all 32 NFL teams
 */
export async function fetchLeagueTeams(): Promise<SportsTeam[]> {
  const url = `${ESPN_SITE_API}/teams`;
  const data = await espnFetch<ESPNTeamsResponse>(url);

  const teams: SportsTeam[] = [];

  for (const sport of data.sports || []) {
    for (const league of sport.leagues || []) {
      for (const { team } of league.teams || []) {
        teams.push({
          idTeam: team.id,
          strTeam: team.displayName,
          strTeamShort: team.abbreviation,
        });
      }
    }
  }

  return teams;
}

// ===== Players =====

/**
 * Fetch roster for a specific team
 */
export async function fetchTeamPlayers(teamId: string): Promise<SportsPlayer[]> {
  const url = `${ESPN_SITE_API}/teams/${teamId}/roster`;

  interface RosterResponse {
    athletes?: Array<{
      position?: string;
      items?: ESPNRosterAthlete[];
    }>;
  }

  const data = await espnFetch<RosterResponse>(url);
  const players: SportsPlayer[] = [];

  for (const group of data.athletes || []) {
    for (const athlete of group.items || []) {
      // Only include offensive skill positions we care about
      const pos = athlete.position?.abbreviation || "";
      if (["QB", "RB", "WR", "TE", "FB"].includes(pos)) {
        players.push({
          idPlayer: athlete.id,
          strPlayer: athlete.fullName || athlete.displayName,
          strPosition: pos,
          idTeam: teamId,
        });
      }
    }
  }

  return players;
}

/**
 * Fetch all NFL players (skill positions only)
 */
export async function fetchAllNflPlayers(): Promise<SportsPlayer[]> {
  const teams = await fetchLeagueTeams();
  const allPlayers: SportsPlayer[] = [];

  for (const team of teams) {
    try {
      const players = await fetchTeamPlayers(team.idTeam);
      for (const p of players) {
        allPlayers.push({ ...p, strTeam: team.strTeam });
      }
    } catch (err) {
      console.error(`Failed to fetch players for team ${team.idTeam}:`, err);
    }
  }

  return allPlayers;
}


// ===== Game Stats =====

/**
 * Fetch detailed game summary with box score stats
 * This is the key endpoint for getting player game statistics
 */
export async function fetchGameSummary(eventId: string): Promise<{
  boxScore: Map<string, SportsPlayerStats>;
  gameStatus: string;
}> {
  const url = `${ESPN_SITE_API}/summary?event=${eventId}`;

  interface SummaryResponse {
    boxscore?: {
      players?: Array<{
        team: { id: string };
        statistics: ESPNBoxScoreCategory[];
      }>;
    };
    header?: {
      competitions?: Array<{
        status?: { type?: { name?: string } };
      }>;
    };
  }

  const data = await espnFetch<SummaryResponse>(url);
  const boxScore = new Map<string, SportsPlayerStats>();

  const gameStatus = data.header?.competitions?.[0]?.status?.type?.name || "STATUS_SCHEDULED";

  // Parse box score statistics
  for (const teamStats of data.boxscore?.players || []) {
    for (const category of teamStats.statistics || []) {
      const labels = category.labels || [];

      for (const athlete of category.athletes || []) {
        const playerId = athlete.athlete.id;
        const playerName = athlete.athlete.displayName;
        const stats = athlete.stats || [];

        // Get or create player stats
        let playerStats = boxScore.get(playerId);
        if (!playerStats) {
          playerStats = {
            idPlayer: playerId,
            strPlayer: playerName,
            passingYards: 0,
            passingTouchdowns: 0,
            interceptions: 0,
            rushingYards: 0,
            rushingTouchdowns: 0,
            receivingYards: 0,
            receivingTouchdowns: 0,
            receptions: 0,
            fumblesLost: 0,
            twoPtConversions: 0,
          };
          boxScore.set(playerId, playerStats);
        }

        // Map stats based on category and labels
        if (category.name === "passing") {
          parsePassingStats(playerStats, labels, stats);
        } else if (category.name === "rushing") {
          parseRushingStats(playerStats, labels, stats);
        } else if (category.name === "receiving") {
          parseReceivingStats(playerStats, labels, stats);
        } else if (category.name === "fumbles") {
          parseFumbleStats(playerStats, labels, stats);
        }
      }
    }
  }

  return { boxScore, gameStatus };
}

function parsePassingStats(stats: SportsPlayerStats, labels: string[], values: string[]): void {
  for (let i = 0; i < labels.length; i++) {
    const label = labels[i]?.toUpperCase();
    const value = parseFloat(values[i]) || 0;

    if (label === "YDS") stats.passingYards = value;
    else if (label === "TD") stats.passingTouchdowns = value;
    else if (label === "INT") stats.interceptions = value;
  }
}

function parseRushingStats(stats: SportsPlayerStats, labels: string[], values: string[]): void {
  for (let i = 0; i < labels.length; i++) {
    const label = labels[i]?.toUpperCase();
    const value = parseFloat(values[i]) || 0;

    if (label === "YDS") stats.rushingYards = value;
    else if (label === "TD") stats.rushingTouchdowns = value;
    else if (label === "FUM") stats.fumblesLost += value;
  }
}

function parseReceivingStats(stats: SportsPlayerStats, labels: string[], values: string[]): void {
  for (let i = 0; i < labels.length; i++) {
    const label = labels[i]?.toUpperCase();
    const value = parseFloat(values[i]) || 0;

    if (label === "YDS") stats.receivingYards = value;
    else if (label === "TD") stats.receivingTouchdowns = value;
    else if (label === "REC") stats.receptions = value;
    else if (label === "FUM") stats.fumblesLost += value;
  }
}

function parseFumbleStats(stats: SportsPlayerStats, labels: string[], values: string[]): void {
  for (let i = 0; i < labels.length; i++) {
    const label = labels[i]?.toUpperCase();
    const value = parseFloat(values[i]) || 0;

    if (label === "LOST" || label === "FUM") stats.fumblesLost = value;
  }
}

/**
 * Fetch player stats for a specific event
 * Returns array of player stats for all players in the game
 */
export async function fetchEventStats(eventId: string): Promise<SportsPlayerStats[]> {
  const { boxScore } = await fetchGameSummary(eventId);
  return Array.from(boxScore.values());
}

/**
 * Fetch player's game log (all games in season)
 */
export async function fetchPlayerGameLog(playerId: string): Promise<Array<{
  eventId: string;
  stats: SportsPlayerStats;
}>> {
  const url = `https://site.web.api.espn.com/apis/common/v3/sports/football/nfl/athletes/${playerId}/gamelog`;

  interface GameLogResponse {
    events?: Record<string, { id: string }>;
    seasonTypes?: Array<{
      categories?: Array<{
        events?: Array<{
          eventId: string;
          stats: string[];
        }>;
      }>;
    }>;
  }

  const data = await espnFetch<GameLogResponse>(url);
  const games: Array<{ eventId: string; stats: SportsPlayerStats }> = [];

  // Parse game log - structure varies by player position
  for (const seasonType of data.seasonTypes || []) {
    for (const category of seasonType.categories || []) {
      for (const event of category.events || []) {
        games.push({
          eventId: event.eventId,
          stats: {
            idPlayer: playerId,
            strPlayer: "",
            passingYards: 0,
            passingTouchdowns: 0,
            interceptions: 0,
            rushingYards: 0,
            rushingTouchdowns: 0,
            receivingYards: 0,
            receivingTouchdowns: 0,
            receptions: 0,
            fumblesLost: 0,
            twoPtConversions: 0,
          },
        });
      }
    }
  }

  return games;
}

/**
 * Check if a game has started (for pick locking)
 */
export async function hasGameStarted(eventId: string): Promise<boolean> {
  const { gameStatus } = await fetchGameSummary(eventId);
  return gameStatus !== "STATUS_SCHEDULED";
}

/**
 * Get current NFL week number
 */
export async function getCurrentWeek(): Promise<number> {
  const url = `${ESPN_SITE_API}/scoreboard`;
  const data = await espnFetch<ESPNScoreboardResponse>(url);
  return data.week?.number || 1;
}

// ===== Season Statistics =====

export interface SeasonStatistics {
  passingYards: number;
  passingTouchdowns: number;
  interceptions: number;
  rushingYards: number;
  rushingTouchdowns: number;
  receivingYards: number;
  receivingTouchdowns: number;
  receptions: number;
  fumblesLost: number;
  gamesPlayed: number;
}

interface ESPNCoreStatResponse {
  splits?: {
    categories?: Array<{
      name: string;
      stats?: Array<{
        name: string;
        value: number;
      }>;
    }>;
  };
}

/**
 * Fetch a player's season statistics from ESPN Core API
 * Returns aggregated stats for the entire season
 */
export async function fetchPlayerSeasonStats(
  playerId: string,
  season: number = parseInt(SEASON),
  seasonType: number = 2 // Regular season
): Promise<SeasonStatistics | null> {
  const url = `${ESPN_CORE_API}/seasons/${season}/types/${seasonType}/athletes/${playerId}/statistics`;

  try {
    const data = await espnFetch<ESPNCoreStatResponse>(url);

    const stats: SeasonStatistics = {
      passingYards: 0,
      passingTouchdowns: 0,
      interceptions: 0,
      rushingYards: 0,
      rushingTouchdowns: 0,
      receivingYards: 0,
      receivingTouchdowns: 0,
      receptions: 0,
      fumblesLost: 0,
      gamesPlayed: 0,
    };

    for (const category of data.splits?.categories || []) {
      const statMap = new Map(
        (category.stats || []).map((s) => [s.name, s.value])
      );

      if (category.name === "general") {
        stats.gamesPlayed = statMap.get("gamesPlayed") || 0;
        stats.fumblesLost = statMap.get("fumblesLost") || 0;
      } else if (category.name === "passing") {
        stats.passingYards = statMap.get("passingYards") || 0;
        stats.passingTouchdowns = statMap.get("passingTouchdowns") || 0;
        stats.interceptions = statMap.get("interceptions") || 0;
      } else if (category.name === "rushing") {
        stats.rushingYards = statMap.get("rushingYards") || 0;
        stats.rushingTouchdowns = statMap.get("rushingTouchdowns") || 0;
      } else if (category.name === "receiving") {
        stats.receivingYards = statMap.get("receivingYards") || 0;
        stats.receivingTouchdowns = statMap.get("receivingTouchdowns") || 0;
        stats.receptions = statMap.get("receptions") || 0;
      }
    }

    return stats;
  } catch (err) {
    // Player might not have stats (rookie, injured, etc.)
    console.warn(`Failed to fetch season stats for player ${playerId}:`, err);
    return null;
  }
}

/**
 * Calculate DraftKings fantasy points from season stats
 * Uses DraftKings PPR scoring
 */
export function calculateFantasyPoints(stats: SeasonStatistics): number {
  // DraftKings PPR Scoring
  const points =
    stats.passingYards * 0.04 +       // 1 point per 25 passing yards
    stats.passingTouchdowns * 4 +      // 4 points per passing TD
    stats.interceptions * -1 +         // -1 per interception
    stats.rushingYards * 0.1 +         // 1 point per 10 rushing yards
    stats.rushingTouchdowns * 6 +      // 6 points per rushing TD
    stats.receivingYards * 0.1 +       // 1 point per 10 receiving yards
    stats.receivingTouchdowns * 6 +    // 6 points per receiving TD
    stats.receptions * 1 +             // 1 point per reception (PPR)
    stats.fumblesLost * -1;            // -1 per fumble lost

  return Math.round(points * 10) / 10; // Round to 1 decimal
}


========================================
FILE: functions/src/types.ts
========================================

/**
 * Firestore schema types for three-man-league
 *
 * DATA MODEL OVERVIEW:
 *
 * /users/{userId}                    - User profile (displayName, email, photoURL, activeLeagueId)
 * /users/{userId}/playerUsage/{id}   - Player usage tracking (season, playerId, firstUsedWeek, leagueId)
 *
 * /leagues/{leagueId}                - League configuration and settings
 * /leagues/{leagueId}/members/{uid}  - League membership (role, joinedAt, invitedBy)
 * /leagues/{leagueId}/weeks/{weekId} - Week status
 * /leagues/{leagueId}/weeks/{weekId}/picks/{userId}  - User picks for week
 * /leagues/{leagueId}/weeks/{weekId}/scores/{userId} - User scores for week
 * /leagues/{leagueId}/seasonStandings/{userId}       - Season standings
 *
 * /players/{playerId}                - NFL player data
 * /games/{gameId}                    - NFL game schedule
 * /config/season                     - Global season config
 */

import type { Timestamp } from "firebase-admin/firestore";

// ===== Users =====
export interface User {
  displayName: string;
  email: string;
  photoURL?: string;
  activeLeagueId?: string; // Currently selected league
  createdAt?: Date | Timestamp;
  updatedAt?: Date | Timestamp;
}

export interface PlayerUsage {
  season: string;
  playerId: string;
  firstUsedWeek: string;
  leagueId: string; // Player usage is now scoped per league
}

// ===== Leagues =====
export type LeagueStatus = "preseason" | "active" | "completed" | "archived";
export type MemberRole = "owner" | "coOwner" | "member";

export interface PayoutEntry {
  rank: number;
  amount: number;
}

export interface League {
  name: string;
  ownerId: string;
  season: string;
  entryFee: number;
  payouts: Record<string, number>; // Legacy format: rank -> amount e.g. {"1": 1200}
  payoutStructure?: PayoutEntry[]; // New format: ordered array [{rank: 1, amount: 1200}, ...]
  payoutTotal?: number; // Computed total of all payouts
  maxPlayers?: number; // Optional limit on league size
  joinCode: string; // Short unique code for joining (e.g., "ABC123")
  joinLink?: string; // Full URL with join code
  joinCodeExpiresAt?: Date | Timestamp; // Optional expiration
  status: LeagueStatus;
  membershipLocked?: boolean; // Prevent new members after season starts
  isPublic: boolean; // Public leagues are visible to all users, private require passcode
  passcode?: string; // Required passcode for joining private leagues
  createdAt: Date | Timestamp;
  updatedAt?: Date | Timestamp;
}

export interface LeagueMember {
  userId: string;
  displayName: string;
  email: string;
  role: MemberRole;
  joinedAt: Date | Timestamp;
  invitedBy?: string; // userId who invited this member
  isActive: boolean; // For soft-delete / leaving league
}

// ===== League API Types =====
export interface CreateLeagueRequest {
  name: string;
  entryFee?: number;
  maxPlayers?: number;
  payoutStructure?: PayoutEntry[];
  season?: string;
}

export interface CreateLeagueResponse {
  ok: boolean;
  leagueId: string;
  joinCode: string;
  joinLink: string;
  error?: string;
}

export interface JoinLeagueRequest {
  joinCode?: string; // Required for private leagues or direct join
  leagueId?: string; // Optional for explicit join by ID
  passcode?: string; // Required for private leagues
}

export interface JoinLeagueResponse {
  ok: boolean;
  leagueId: string;
  leagueName: string;
  error?: string;
}

export interface LeagueSummary {
  id: string;
  name: string;
  season: string;
  memberCount: number;
  role: MemberRole;
  status: LeagueStatus;
  entryFee: number;
  isPublic: boolean;
}

// For listing available public leagues (user not a member)
export interface PublicLeagueSummary {
  id: string;
  name: string;
  season: string;
  memberCount: number;
  maxPlayers?: number;
  status: LeagueStatus;
  entryFee: number;
  isPublic: boolean;
}

// ===== Weeks =====
export type WeekStatus = "pending" | "scoring" | "final";

export interface Week {
  weekNumber: number;
  startDate: Date | Timestamp;
  endDate: Date | Timestamp;
  status: WeekStatus;
}

// ===== Picks =====
export interface UserPicks {
  qbPlayerId?: string;
  qbGameId?: string;
  qbLocked: boolean;
  rbPlayerId?: string;
  rbGameId?: string;
  rbLocked: boolean;
  wrPlayerId?: string;
  wrGameId?: string;
  wrLocked: boolean;
  createdAt: Date | Timestamp;
  updatedAt: Date | Timestamp;
}

// ===== Scores =====
export interface UserScore {
  qbPoints: number;
  rbPoints: number;
  wrPoints: number;
  totalPoints: number;
  doublePickPositions: string[];
  updatedAt: Date | Timestamp;
}

// ===== Season Standings =====
export interface SeasonStanding {
  userId: string;
  displayName: string;
  seasonTotalPoints: number;
  weeksPlayed: number;
  bestWeekPoints: number;
  bestWeek: string;
  updatedAt: Date | Timestamp;
}

// ===== Players =====
export type Position = "QB" | "RB" | "WR" | "TE";
export type EligiblePosition = "QB" | "RB" | "WR";

export interface SeasonStats {
  passingYards: number;
  passingTD: number;
  interceptions: number;
  rushingYards: number;
  rushingTD: number;
  receivingYards: number;
  receivingTD: number;
  receptions: number;
  fumblesLost: number;
  gamesPlayed: number;
  fantasyPoints: number; // Calculated DraftKings PPR points
}

export interface Player {
  name: string;
  position: Position;
  teamId: string;
  teamName?: string;
  externalId: string;
  eligiblePositions: EligiblePosition[];
  seasonStats?: SeasonStats;
  statsUpdatedAt?: Date | Timestamp;
}

// ===== Games =====
export interface Game {
  gameId: string;
  externalEventId: string;
  homeTeamId: string;
  awayTeamId: string;
  homeTeamName?: string;
  awayTeamName?: string;
  weekNumber: number;
  kickoffTime: Date | Timestamp;
  status?: "scheduled" | "in_progress" | "final";
}

// ===== Scoring =====
export interface PlayerGameStats {
  passingYards: number;
  passingTD: number;
  interceptions: number;
  rushingYards: number;
  rushingTD: number;
  receivingYards: number;
  receivingTD: number;
  receptions: number;
  fumblesLost: number;
  twoPtConversions: number;
  offensiveFumbleRecoveryTD: number;
}

// ===== API Request/Response Types =====
export interface SubmitPicksRequest {
  leagueId: string;
  weekId: string;
  picks: {
    qbPlayerId?: string;
    qbGameId?: string;
    rbPlayerId?: string;
    rbGameId?: string;
    wrPlayerId?: string;
    wrGameId?: string;
  };
}

// ===== Payout Structure =====
export const PAYOUT_STRUCTURE: Record<number, number> = {
  1: 1200,
  2: 750,
  3: 500,
  4: 415,
  5: 270,
  6: 195,
  7: 120,
};

export const TOTAL_POT = 3450;
export const ENTRY_FEE = 50;

// ===== Backfill Types =====
export type BackfillStatus = "not_started" | "in_progress" | "completed" | "error";

/**
 * Extended League interface with backfill fields
 */
export interface LeagueBackfillConfig {
  backfillEnabled?: boolean;
  backfillFromWeek?: number; // First week to backfill (e.g., 1)
  backfillToWeek?: number;   // Last week to backfill (e.g., 12)
  backfillStatus?: BackfillStatus;
  backfillCompletedAt?: Date | Timestamp;
  backfillCompletedBy?: string; // userId who completed backfill
}

/**
 * Extended Week interface with backfill tracking
 */
export interface WeekBackfillInfo {
  backfillStatus?: "not_backfilled" | "backfilled" | "error";
  backfilledAt?: Date | Timestamp;
  backfilledBy?: string; // userId who backfilled
  isBackfilled?: boolean;
}

/**
 * Member pick for backfill - one member's picks for a week
 */
export interface BackfillMemberPick {
  userId: string;
  qbPlayerId?: string;
  rbPlayerId?: string;
  wrPlayerId?: string;
  // Optional score overrides (if admin needs to manually adjust)
  qbPointsOverride?: number;
  rbPointsOverride?: number;
  wrPointsOverride?: number;
}

/**
 * Request payload for backfilling a single week
 */
export interface BackfillWeekRequest {
  leagueId: string;
  weekNumber: number;
  memberPicks: BackfillMemberPick[];
}

/**
 * Result for a single member in backfill operation
 */
export interface BackfillMemberResult {
  userId: string;
  displayName?: string;
  qbPoints: number;
  rbPoints: number;
  wrPoints: number;
  totalPoints: number;
  qbPlayerName?: string;
  rbPlayerName?: string;
  wrPlayerName?: string;
  errors?: string[];
  warnings?: string[];
}

/**
 * Response from backfill operation
 */
export interface BackfillWeekResponse {
  ok: boolean;
  weekNumber: number;
  results: BackfillMemberResult[];
  error?: string;
}

/**
 * Status for a single week in backfill progress
 */
export interface BackfillWeekStatus {
  weekNumber: number;
  weekId: string;
  status: "not_backfilled" | "backfilled" | "error";
  memberCount: number;
  scores?: BackfillMemberResult[];
  backfilledAt?: string;
  backfilledBy?: string;
}

/**
 * Status response for getting backfill progress
 */
export interface BackfillStatusResponse {
  ok: boolean;
  leagueId: string;
  backfillEnabled: boolean;
  backfillFromWeek?: number;
  backfillToWeek?: number;
  overallStatus: BackfillStatus;
  weeks: BackfillWeekStatus[];
}

/**
 * Extended UserScore with backfill metadata
 */
export interface BackfilledUserScore extends UserScore {
  isBackfilled?: boolean;
  computedTotalPoints?: number;      // Original computed score
  adjustedTotalPoints?: number;       // Final score after override
  adjustmentReason?: string;          // Reason for manual adjustment
  backfilledAt?: Date | Timestamp;
  backfilledBy?: string;
}



========================================
FILE: functions/src/utils/firestore.test.ts
========================================

/**
 * Tests for Firestore document mappers
 */

import {
  mapDocWithId,
  mapUser,
  mapPlayerUsage,
  mapLeague,
  mapUserPicks,
  mapPlayer,
} from "./firestore.js";
import type { DocumentSnapshot } from "firebase-admin/firestore";

// Helper to create mock DocumentSnapshot
function createMockDoc(exists: boolean, id: string, data?: Record<string, unknown>): DocumentSnapshot {
  return {
    exists,
    id,
    data: () => data,
  } as unknown as DocumentSnapshot;
}

describe("mapDocWithId", () => {
  it("returns null for non-existent document", () => {
    const doc = createMockDoc(false, "test-id");
    expect(mapDocWithId(doc)).toBeNull();
  });

  it("returns data with id for existing document", () => {
    const doc = createMockDoc(true, "test-id", { name: "Test" });
    const result = mapDocWithId<{ name: string }>(doc);
    expect(result).toEqual({ id: "test-id", name: "Test" });
  });
});

describe("mapUser", () => {
  it("returns null for non-existent document", () => {
    const doc = createMockDoc(false, "user-id");
    expect(mapUser(doc)).toBeNull();
  });

  it("maps user with all fields", () => {
    const doc = createMockDoc(true, "user-id", {
      displayName: "John Doe",
      email: "john@example.com",
      photoURL: "https://example.com/photo.jpg",
      activeLeagueId: "league-123",
    });
    const result = mapUser(doc);
    expect(result).toEqual({
      displayName: "John Doe",
      email: "john@example.com",
      photoURL: "https://example.com/photo.jpg",
      activeLeagueId: "league-123",
      createdAt: undefined,
      updatedAt: undefined,
    });
  });

  it("provides defaults for missing fields", () => {
    const doc = createMockDoc(true, "user-id", {});
    const result = mapUser(doc);
    expect(result?.displayName).toBe("");
    expect(result?.email).toBe("");
  });
});

describe("mapPlayerUsage", () => {
  it("returns null for non-existent document", () => {
    const doc = createMockDoc(false, "usage-id");
    expect(mapPlayerUsage(doc)).toBeNull();
  });

  it("maps player usage correctly", () => {
    const doc = createMockDoc(true, "usage-id", {
      season: "2025",
      playerId: "player-123",
      firstUsedWeek: "week-5",
      leagueId: "league-456",
    });
    const result = mapPlayerUsage(doc);
    expect(result).toEqual({
      season: "2025",
      playerId: "player-123",
      firstUsedWeek: "week-5",
      leagueId: "league-456",
    });
  });
});

describe("mapLeague", () => {
  it("returns null for non-existent document", () => {
    const doc = createMockDoc(false, "league-id");
    expect(mapLeague(doc)).toBeNull();
  });

  it("maps league with all fields", () => {
    const createdAt = new Date();
    const doc = createMockDoc(true, "league-id", {
      name: "Test League",
      ownerId: "owner-123",
      season: "2025",
      entryFee: 50,
      payouts: { "1": 100 },
      joinCode: "ABC123",
      status: "active",
      createdAt,
    });
    const result = mapLeague(doc);
    expect(result?.id).toBe("league-id");
    expect(result?.name).toBe("Test League");
    expect(result?.ownerId).toBe("owner-123");
    expect(result?.entryFee).toBe(50);
    expect(result?.status).toBe("active");
  });
});

describe("mapUserPicks", () => {
  it("returns null for non-existent document", () => {
    const doc = createMockDoc(false, "picks-id");
    expect(mapUserPicks(doc)).toBeNull();
  });

  it("maps picks with locked status", () => {
    const doc = createMockDoc(true, "picks-id", {
      qbPlayerId: "qb-123",
      qbGameId: "game-1",
      qbLocked: true,
      rbPlayerId: "rb-456",
      rbGameId: "game-2",
      rbLocked: false,
    });
    const result = mapUserPicks(doc);
    expect(result?.qbPlayerId).toBe("qb-123");
    expect(result?.qbLocked).toBe(true);
    expect(result?.rbLocked).toBe(false);
    expect(result?.wrLocked).toBe(false); // default
  });
});

describe("mapPlayer", () => {
  it("returns null for non-existent document", () => {
    const doc = createMockDoc(false, "player-id");
    expect(mapPlayer(doc)).toBeNull();
  });

  it("maps player with season stats", () => {
    const doc = createMockDoc(true, "player-id", {
      name: "Patrick Mahomes",
      position: "QB",
      teamId: "team-kc",
      teamName: "Kansas City Chiefs",
      eligiblePositions: ["QB"],
      seasonStats: { fantasyPoints: 250.5 },
    });
    const result = mapPlayer(doc);
    expect(result?.id).toBe("player-id");
    expect(result?.name).toBe("Patrick Mahomes");
    expect(result?.position).toBe("QB");
    expect(result?.seasonStats?.fantasyPoints).toBe(250.5);
  });
});



========================================
FILE: functions/src/utils/firestore.ts
========================================

/**
 * Firestore Document Mappers
 *
 * Type-safe helpers for reading Firestore documents with proper typing.
 * These replace loose casts like `doc.data() as SomeType` with validated mappers.
 */

import type { DocumentSnapshot, QueryDocumentSnapshot } from "firebase-admin/firestore";
import type {
  User,
  PlayerUsage,
  League,
  LeagueMember,
  Week,
  UserPicks,
  UserScore,
  SeasonStanding,
  Player,
  Game,
} from "../types.js";

/**
 * Generic mapper that adds the document ID to the data
 */
export function mapDocWithId<T>(
  doc: DocumentSnapshot | QueryDocumentSnapshot
): (T & { id: string }) | null {
  if (!doc.exists) return null;
  return { id: doc.id, ...doc.data() } as T & { id: string };
}

/**
 * Map a Firestore document to a User type
 */
export function mapUser(doc: DocumentSnapshot): User | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    displayName: data.displayName ?? "",
    email: data.email ?? "",
    photoURL: data.photoURL,
    activeLeagueId: data.activeLeagueId,
    createdAt: data.createdAt,
    updatedAt: data.updatedAt,
  };
}

/**
 * Map a Firestore document to a PlayerUsage type
 */
export function mapPlayerUsage(doc: DocumentSnapshot): PlayerUsage | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    season: data.season ?? "",
    playerId: data.playerId ?? "",
    firstUsedWeek: data.firstUsedWeek ?? "",
    leagueId: data.leagueId ?? "",
  };
}

/**
 * Map a Firestore document to a League type
 */
export function mapLeague(doc: DocumentSnapshot): (League & { id: string }) | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    id: doc.id,
    name: data.name ?? "",
    ownerId: data.ownerId ?? "",
    season: data.season ?? "",
    entryFee: data.entryFee ?? 0,
    payouts: data.payouts ?? {},
    payoutStructure: data.payoutStructure,
    payoutTotal: data.payoutTotal,
    maxPlayers: data.maxPlayers,
    joinCode: data.joinCode ?? "",
    joinLink: data.joinLink,
    joinCodeExpiresAt: data.joinCodeExpiresAt,
    status: data.status ?? "preseason",
    membershipLocked: data.membershipLocked,
    isPublic: data.isPublic ?? true, // Default to true for backwards compatibility
    passcode: data.passcode,
    createdAt: data.createdAt ?? new Date(),
    updatedAt: data.updatedAt,
  };
}

/**
 * Map a Firestore document to a LeagueMember type
 */
export function mapLeagueMember(doc: DocumentSnapshot): (LeagueMember & { id: string }) | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    id: doc.id,
    userId: data.userId ?? doc.id,
    displayName: data.displayName ?? "",
    email: data.email ?? "",
    role: data.role ?? "member",
    joinedAt: data.joinedAt ?? new Date(),
    invitedBy: data.invitedBy,
    isActive: data.isActive ?? true,
  };
}

/**
 * Map a Firestore document to a Week type
 */
export function mapWeek(doc: DocumentSnapshot): (Week & { id: string }) | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    id: doc.id,
    weekNumber: data.weekNumber ?? 0,
    startDate: data.startDate ?? new Date(),
    endDate: data.endDate ?? new Date(),
    status: data.status ?? "pending",
  };
}

/**
 * Map a Firestore document to a UserPicks type
 */
export function mapUserPicks(doc: DocumentSnapshot): UserPicks | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    qbPlayerId: data.qbPlayerId,
    qbGameId: data.qbGameId,
    qbLocked: data.qbLocked ?? false,
    rbPlayerId: data.rbPlayerId,
    rbGameId: data.rbGameId,
    rbLocked: data.rbLocked ?? false,
    wrPlayerId: data.wrPlayerId,
    wrGameId: data.wrGameId,
    wrLocked: data.wrLocked ?? false,
    createdAt: data.createdAt ?? new Date(),
    updatedAt: data.updatedAt ?? new Date(),
  };
}

/**
 * Map a Firestore document to a UserScore type
 */
export function mapUserScore(doc: DocumentSnapshot): UserScore | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    qbPoints: data.qbPoints ?? 0,
    rbPoints: data.rbPoints ?? 0,
    wrPoints: data.wrPoints ?? 0,
    totalPoints: data.totalPoints ?? 0,
    doublePickPositions: data.doublePickPositions ?? [],
    updatedAt: data.updatedAt ?? new Date(),
  };
}

/**
 * Map a Firestore document to a SeasonStanding type
 */
export function mapSeasonStanding(doc: DocumentSnapshot): SeasonStanding | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    userId: data.userId ?? doc.id,
    displayName: data.displayName ?? "",
    seasonTotalPoints: data.seasonTotalPoints ?? 0,
    weeksPlayed: data.weeksPlayed ?? 0,
    bestWeekPoints: data.bestWeekPoints ?? 0,
    bestWeek: data.bestWeek ?? "",
    updatedAt: data.updatedAt ?? new Date(),
  };
}

/**
 * Map a Firestore document to a Player type
 */
export function mapPlayer(doc: DocumentSnapshot): (Player & { id: string }) | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    id: doc.id,
    name: data.name ?? "",
    position: data.position ?? "QB",
    teamId: data.teamId ?? "",
    teamName: data.teamName,
    externalId: data.externalId ?? "",
    eligiblePositions: data.eligiblePositions ?? [],
    seasonStats: data.seasonStats,
    statsUpdatedAt: data.statsUpdatedAt,
  };
}

/**
 * Map a Firestore document to a Game type
 */
export function mapGame(doc: DocumentSnapshot): (Game & { id: string }) | null {
  if (!doc.exists) return null;
  const data = doc.data()!;
  return {
    id: doc.id,
    gameId: data.gameId ?? doc.id,
    externalEventId: data.externalEventId ?? "",
    homeTeamId: data.homeTeamId ?? "",
    awayTeamId: data.awayTeamId ?? "",
    homeTeamName: data.homeTeamName,
    awayTeamName: data.awayTeamName,
    weekNumber: data.weekNumber ?? 0,
    kickoffTime: data.kickoffTime ?? new Date(),
    status: data.status,
  };
}



========================================
FILE: functions/src/utils/http.test.ts
========================================

/**
 * Tests for HTTP utilities
 */

import { setCors, handlePreflight, sendError, sendSuccess, verifyAdminKey } from "./http.js";
import type { Response } from "express";

// Mock Response object
function createMockResponse(): Response {
  const headers: Record<string, string> = {};
  const res = {
    set: jest.fn((key: string, value: string) => {
      headers[key] = value;
      return res;
    }),
    status: jest.fn(() => res),
    send: jest.fn(() => res),
    getHeaders: () => headers,
  } as unknown as Response;
  return res;
}

describe("setCors", () => {
  it("sets production origin when no origin provided", () => {
    const res = createMockResponse();
    setCors(res);
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "https://three-man-league.web.app"
    );
  });

  it("allows production web.app origin", () => {
    const res = createMockResponse();
    setCors(res, "https://three-man-league.web.app");
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "https://three-man-league.web.app"
    );
  });

  it("allows production firebaseapp.com origin", () => {
    const res = createMockResponse();
    setCors(res, "https://three-man-league.firebaseapp.com");
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "https://three-man-league.firebaseapp.com"
    );
  });

  it("allows localhost:5173 for development", () => {
    const res = createMockResponse();
    setCors(res, "http://localhost:5173");
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "http://localhost:5173"
    );
  });

  it("allows localhost:5000 for development", () => {
    const res = createMockResponse();
    setCors(res, "http://localhost:5000");
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "http://localhost:5000"
    );
  });

  it("allows 127.0.0.1 for development", () => {
    const res = createMockResponse();
    setCors(res, "http://127.0.0.1:5173");
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "http://127.0.0.1:5173"
    );
  });

  it("falls back to production for unknown origins", () => {
    const res = createMockResponse();
    setCors(res, "https://malicious-site.com");
    expect(res.set).toHaveBeenCalledWith(
      "Access-Control-Allow-Origin",
      "https://three-man-league.web.app"
    );
  });

  it("sets all required CORS headers", () => {
    const res = createMockResponse();
    setCors(res);
    expect(res.set).toHaveBeenCalledWith("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
    expect(res.set).toHaveBeenCalledWith("Access-Control-Allow-Headers", "Content-Type, Authorization");
    expect(res.set).toHaveBeenCalledWith("Access-Control-Allow-Credentials", "true");
  });
});

describe("handlePreflight", () => {
  it("returns true and sends 204 for OPTIONS requests", () => {
    const res = createMockResponse();
    const result = handlePreflight("OPTIONS", res);
    expect(result).toBe(true);
    expect(res.status).toHaveBeenCalledWith(204);
    expect(res.send).toHaveBeenCalledWith("");
  });

  it("returns false for GET requests", () => {
    const res = createMockResponse();
    const result = handlePreflight("GET", res);
    expect(result).toBe(false);
    expect(res.status).not.toHaveBeenCalled();
  });

  it("returns false for POST requests", () => {
    const res = createMockResponse();
    const result = handlePreflight("POST", res);
    expect(result).toBe(false);
    expect(res.status).not.toHaveBeenCalled();
  });
});

describe("sendError", () => {
  it("sends error response with correct status and message", () => {
    const res = createMockResponse();
    sendError(res, 400, "Bad request");
    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.send).toHaveBeenCalledWith({ error: "Bad request" });
  });

  it("handles 401 unauthorized", () => {
    const res = createMockResponse();
    sendError(res, 401, "Unauthorized");
    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.send).toHaveBeenCalledWith({ error: "Unauthorized" });
  });

  it("handles 500 internal error", () => {
    const res = createMockResponse();
    sendError(res, 500, "Internal server error");
    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.send).toHaveBeenCalledWith({ error: "Internal server error" });
  });
});

describe("sendSuccess", () => {
  it("sends success response with data", () => {
    const res = createMockResponse();
    const data = { message: "Success", id: "123" };
    sendSuccess(res, data);
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith(data);
  });

  it("handles empty object", () => {
    const res = createMockResponse();
    sendSuccess(res, {});
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith({});
  });

  it("handles array data", () => {
    const res = createMockResponse();
    const data = [{ id: 1 }, { id: 2 }];
    sendSuccess(res, data);
    expect(res.status).toHaveBeenCalledWith(200);
    expect(res.send).toHaveBeenCalledWith(data);
  });
});

describe("verifyAdminKey", () => {
  const originalEnv = process.env;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...originalEnv };
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  it("returns true when no admin key is configured (development mode)", () => {
    delete process.env.ADMIN_API_KEY;
    expect(verifyAdminKey("any-key")).toBe(true);
    expect(verifyAdminKey(undefined)).toBe(true);
  });

  it("returns true when admin key matches", () => {
    process.env.ADMIN_API_KEY = "secret-admin-key";
    expect(verifyAdminKey("secret-admin-key")).toBe(true);
  });

  it("returns false when admin key does not match", () => {
    process.env.ADMIN_API_KEY = "secret-admin-key";
    expect(verifyAdminKey("wrong-key")).toBe(false);
  });

  it("returns false when admin key is undefined but expected", () => {
    process.env.ADMIN_API_KEY = "secret-admin-key";
    expect(verifyAdminKey(undefined)).toBe(false);
  });

  it("returns false when admin key is empty string but expected", () => {
    process.env.ADMIN_API_KEY = "secret-admin-key";
    expect(verifyAdminKey("")).toBe(false);
  });
});



========================================
FILE: functions/src/utils/http.ts
========================================

/**
 * HTTP Utilities for Cloud Functions
 *
 * Shared utilities for CORS handling and authentication verification.
 */

import type { Response } from "express";
import * as admin from "firebase-admin";

/**
 * Allowed origins for CORS
 * In production, this should be restricted to the actual domain
 */
const ALLOWED_ORIGINS = [
  "https://three-man-league.web.app",
  "https://three-man-league.firebaseapp.com",
  // Allow localhost for development
  "http://localhost:5173",
  "http://localhost:5000",
  "http://127.0.0.1:5173",
  "http://127.0.0.1:5000",
];

/**
 * Set CORS headers for cross-origin requests
 *
 * In production, restricts to allowed origins.
 * Allows localhost for development convenience.
 *
 * Note: The origin parameter is optional. If not provided, defaults to production domain.
 * For proper CORS handling, pass req.headers.origin when available.
 */
export function setCors(res: Response, origin?: string): void {
  let allowedOrigin: string;

  if (origin) {
    // Check if origin is in allowed list or is a localhost origin
    if (ALLOWED_ORIGINS.includes(origin)) {
      allowedOrigin = origin;
    } else if (origin.includes("localhost") || origin.includes("127.0.0.1")) {
      // Allow localhost for development
      allowedOrigin = origin;
    } else {
      // Unknown origin - use production domain
      allowedOrigin = ALLOWED_ORIGINS[0];
    }
  } else {
    // No origin header - use production domain
    allowedOrigin = ALLOWED_ORIGINS[0];
  }

  res.set("Access-Control-Allow-Origin", allowedOrigin);
  res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.set("Access-Control-Allow-Credentials", "true");
}

/**
 * Verify Firebase Auth token and return userId
 * 
 * @param authHeader - The Authorization header value (e.g., "Bearer <token>")
 * @returns The user ID if valid, null otherwise
 */
export async function verifyAuth(authHeader: string | undefined): Promise<string | null> {
  if (!authHeader?.startsWith("Bearer ")) return null;
  try {
    const token = authHeader.slice(7);
    const decoded = await admin.auth().verifyIdToken(token);
    return decoded.uid;
  } catch {
    return null;
  }
}

/**
 * Handle OPTIONS preflight request
 * 
 * @returns true if this was a preflight request (caller should return early)
 */
export function handlePreflight(method: string, res: Response): boolean {
  if (method === "OPTIONS") {
    res.status(204).send("");
    return true;
  }
  return false;
}

/**
 * Send a standardized error response
 */
export function sendError(res: Response, status: number, message: string): void {
  res.status(status).send({ error: message });
}

/**
 * Send a standardized success response
 */
export function sendSuccess<T>(res: Response, data: T): void {
  res.status(200).send(data);
}

/**
 * Verify admin API key for protected admin endpoints
 *
 * Admin endpoints should include an X-Admin-Key header with the admin key.
 * The admin key is set via the ADMIN_API_KEY environment variable.
 *
 * @returns true if the admin key is valid, false otherwise
 */
export function verifyAdminKey(adminKeyHeader: string | undefined): boolean {
  const expectedKey = process.env.ADMIN_API_KEY;

  // If no admin key is configured, allow access (for development)
  if (!expectedKey) {
    console.warn("ADMIN_API_KEY not configured - admin endpoints are unprotected");
    return true;
  }

  return adminKeyHeader === expectedKey;
}



--- BACKEND TESTS ---

========================================
SUMMARY
========================================
Frontend files: 39
Backend files: 12
Test files: 0
Total lines in review file: 12859
